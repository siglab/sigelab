{"remainingRequest":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/fullcalendar-scheduler/dist/scheduler.js","dependencies":[{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/fullcalendar-scheduler/dist/scheduler.js","mtime":1522262989000},{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/cache-loader/dist/cjs.js","mtime":1553019068977},{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/*!\n * FullCalendar Scheduler v1.9.4\n * Docs & License: https://fullcalendar.io/scheduler/\n * (c) 2018 Adam Shaw\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (typeof exports === 'object' && typeof module === 'object')\n        module.exports = factory(require(\"fullcalendar\"), require(\"jquery\"), require(\"moment\"));\n    else if (typeof define === 'function' && define.amd)\n        define([\"fullcalendar\", \"jquery\", \"moment\"], factory);\n    else {\n        var a = typeof exports === 'object' ? factory(require(\"fullcalendar\"), require(\"jquery\"), require(\"moment\")) : factory(root[\"FullCalendar\"], root[\"jQuery\"], root[\"moment\"]);\n        for (var i in a)\n            (typeof exports === 'object' ? exports : root)[i] = a[i];\n    }\n})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_15__) {\n    return /******/ (function (modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/\n        /******/ // The require function\n        /******/ function __webpack_require__(moduleId) {\n            /******/\n            /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n                /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n                /******/ \n            };\n            /******/\n            /******/ // Execute the module function\n            /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n            /******/\n            /******/ // Flag the module as loaded\n            /******/ module.l = true;\n            /******/\n            /******/ // Return the exports of the module\n            /******/ return module.exports;\n            /******/ \n        }\n        /******/\n        /******/\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/ __webpack_require__.m = modules;\n        /******/\n        /******/ // expose the module cache\n        /******/ __webpack_require__.c = installedModules;\n        /******/\n        /******/ // define getter function for harmony exports\n        /******/ __webpack_require__.d = function (exports, name, getter) {\n            /******/ if (!__webpack_require__.o(exports, name)) {\n                /******/ Object.defineProperty(exports, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                    /******/ \n                });\n                /******/ }\n            /******/ \n        };\n        /******/\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __webpack_require__.n = function (module) {\n            /******/ var getter = module && module.__esModule ?\n                /******/ function getDefault() { return module['default']; } :\n                /******/ function getModuleExports() { return module; };\n            /******/ __webpack_require__.d(getter, 'a', getter);\n            /******/ return getter;\n            /******/ \n        };\n        /******/\n        /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n        /******/\n        /******/ // __webpack_public_path__\n        /******/ __webpack_require__.p = \"\";\n        /******/\n        /******/ // Load entry module and return exports\n        /******/ return __webpack_require__(__webpack_require__.s = 36);\n        /******/ \n    })([\n        /* 0 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n            /***/ \n        }),\n        /* 1 */\n        /***/ (function (module, exports) {\n            /*\n            derived from:\n            https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js\n            \n            only include the helpers we need, to keep down filesize\n            */\n            var extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) {\n                    for (var p in b)\n                        if (b.hasOwnProperty(p))\n                            d[p] = b[p];\n                };\n            exports.__extends = function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n            /***/ \n        }),\n        /* 2 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n            /***/ \n        }),\n        /* 3 */ ,\n        /* 4 */ ,\n        /* 5 */ ,\n        /* 6 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceComponentFootprint = (function (_super) {\n                tslib_1.__extends(ResourceComponentFootprint, _super);\n                function ResourceComponentFootprint(unzonedRange, isAllDay, resourceId) {\n                    var _this = _super.call(this, unzonedRange, isAllDay) || this;\n                    _this.resourceId = resourceId;\n                    return _this;\n                }\n                ResourceComponentFootprint.prototype.toLegacy = function (calendar) {\n                    var obj = _super.prototype.toLegacy.call(this, calendar);\n                    obj.resourceId = this.resourceId;\n                    return obj;\n                };\n                return ResourceComponentFootprint;\n            }(fullcalendar_1.ComponentFootprint));\n            exports.default = ResourceComponentFootprint;\n            /***/ \n        }),\n        /* 7 */ ,\n        /* 8 */ ,\n        /* 9 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceViewMixin = (function (_super) {\n                tslib_1.__extends(ResourceViewMixin, _super);\n                function ResourceViewMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ResourceViewMixin.mixInto = function (destClass) {\n                    var _this = this;\n                    fullcalendar_1.Mixin.mixInto.call(this, destClass);\n                    [\n                        'bindBaseRenderHandlers',\n                        'queryScroll',\n                        'applyScroll',\n                        'triggerDayClick',\n                        'triggerSelect',\n                        'triggerExternalDrop',\n                        'handleResourceAdd',\n                        'handleResourceRemove'\n                    ].forEach(function (methodName) {\n                        destClass.prototype[methodName] = _this.prototype[methodName];\n                    });\n                };\n                ResourceViewMixin.prototype.initResourceView = function () {\n                    var _this = this;\n                    // new task\n                    var resourceDeps = ['hasResources'];\n                    if (!this.canHandleSpecificResources) {\n                        resourceDeps.push('displayingDates');\n                    }\n                    this.watch('displayingResources', resourceDeps, function () {\n                        _this.requestResourcesRender(_this.get('currentResources'));\n                    }, function () {\n                        _this.requestResourcesUnrender();\n                    });\n                    // start relying on displayingResources\n                    this.watch('displayingBusinessHours', [\n                        'businessHourGenerator',\n                        'displayingResources',\n                        'displayingDates'\n                    ], function (deps) {\n                        _this.requestBusinessHoursRender(deps.businessHourGenerator);\n                    }, function () {\n                        _this.requestBusinessHoursUnrender();\n                    });\n                    // start relying on resource displaying rather than just current resources\n                    this.watch('displayingEvents', ['displayingResources', 'hasEvents'], function () {\n                        _this.requestEventsRender(_this.get('currentEvents'));\n                    }, function () {\n                        _this.requestEventsUnrender();\n                    });\n                };\n                // Logic: base render trigger should fire when BOTH the resources and dates have rendered,\n                // but the unrender trigger should fire after ONLY the dates are about to be unrendered.\n                ResourceViewMixin.prototype.bindBaseRenderHandlers = function () {\n                    var isResourcesRendered = false;\n                    var isDatesRendered = false;\n                    this.on('resourcesRendered', function () {\n                        if (!isResourcesRendered) {\n                            isResourcesRendered = true;\n                            if (isDatesRendered) {\n                                this.whenSizeUpdated(this.triggerViewRender);\n                            }\n                        }\n                    });\n                    this.on('datesRendered', function () {\n                        if (!isDatesRendered) {\n                            isDatesRendered = true;\n                            if (isResourcesRendered) {\n                                this.whenSizeUpdated(this.triggerViewRender);\n                            }\n                        }\n                    });\n                    this.on('before:resourcesUnrendered', function () {\n                        if (isResourcesRendered) {\n                            isResourcesRendered = false;\n                        }\n                    });\n                    this.on('before:datesUnrendered', function () {\n                        if (isDatesRendered) {\n                            isDatesRendered = false;\n                            this.triggerViewDestroy();\n                        }\n                    });\n                };\n                // Scroll\n                // ----------------------------------------------------------------------------------------------\n                ResourceViewMixin.prototype.queryScroll = function () {\n                    var scroll = fullcalendar_1.View.prototype.queryScroll.apply(this, arguments);\n                    if (this.isResourcesRendered) {\n                        $.extend(scroll, this.queryResourceScroll());\n                    }\n                    return scroll;\n                };\n                ResourceViewMixin.prototype.applyScroll = function (scroll) {\n                    fullcalendar_1.View.prototype.applyScroll.apply(this, arguments);\n                    if (this.isResourcesRendered) {\n                        this.applyResourceScroll(scroll);\n                    }\n                };\n                ResourceViewMixin.prototype.queryResourceScroll = function () {\n                    return {}; // subclasses must implement\n                };\n                ResourceViewMixin.prototype.applyResourceScroll = function () {\n                    // subclasses must implement\n                };\n                // Rendering Utils\n                // ----------------------------------------------------------------------------------------------\n                ResourceViewMixin.prototype.getResourceText = function (resource) {\n                    return this.getResourceTextFunc()(resource);\n                };\n                ResourceViewMixin.prototype.getResourceTextFunc = function () {\n                    if (this.resourceTextFunc) {\n                        return this.resourceTextFunc;\n                    }\n                    else {\n                        var func = this.opt('resourceText');\n                        if (typeof func !== 'function') {\n                            func = function (resource) { return resource.title || resource.id; };\n                        }\n                        this.resourceTextFunc = func;\n                        return func;\n                    }\n                };\n                // Resource Change Handling\n                // ----------------------------------------------------------------------------------------------\n                ResourceViewMixin.prototype.handleResourceAdd = function (resource) {\n                    this.requestResourceRender(resource);\n                };\n                ResourceViewMixin.prototype.handleResourceRemove = function (resource) {\n                    this.requestResourceUnrender(resource);\n                };\n                // Resource Rendering\n                // ----------------------------------------------------------------------------------------------\n                ResourceViewMixin.prototype.requestResourcesRender = function (resources) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeResourcesRender(resources);\n                    }, 'resource', 'init');\n                };\n                ResourceViewMixin.prototype.requestResourcesUnrender = function () {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeResourcesUnrender();\n                    }, 'resource', 'destroy');\n                };\n                ResourceViewMixin.prototype.requestResourceRender = function (resource) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeResourceRender(resource);\n                    }, 'resource', 'add');\n                };\n                ResourceViewMixin.prototype.requestResourceUnrender = function (resource) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeResourceUnrender(resource);\n                    }, 'resource', 'remove');\n                };\n                // Resource High-level Rendering/Unrendering\n                // ----------------------------------------------------------------------------------------------\n                ResourceViewMixin.prototype.executeResourcesRender = function (resources) {\n                    this.renderResources(resources);\n                    this.isResourcesRendered = true;\n                    this.trigger('resourcesRendered');\n                };\n                ResourceViewMixin.prototype.executeResourcesUnrender = function () {\n                    this.trigger('before:resourcesUnrendered');\n                    this.unrenderResources();\n                    this.isResourcesRendered = false;\n                };\n                ResourceViewMixin.prototype.executeResourceRender = function (resource) {\n                    this.renderResource(resource);\n                };\n                ResourceViewMixin.prototype.executeResourceUnrender = function (resource) {\n                    this.unrenderResource(resource);\n                };\n                // Triggering\n                // ----------------------------------------------------------------------------------------------\n                /*\n                footprint is a ResourceComponentFootprint\n                */\n                ResourceViewMixin.prototype.triggerDayClick = function (footprint, dayEl, ev) {\n                    var dateProfile = this.calendar.footprintToDateProfile(footprint);\n                    this.publiclyTrigger('dayClick', {\n                        context: dayEl,\n                        args: [\n                            dateProfile.start,\n                            ev,\n                            this,\n                            footprint.resourceId ?\n                                this.calendar.resourceManager.getResourceById(footprint.resourceId) :\n                                null\n                        ]\n                    });\n                };\n                /*\n                footprint is a ResourceComponentFootprint\n                */\n                ResourceViewMixin.prototype.triggerSelect = function (footprint, ev) {\n                    var dateProfile = this.calendar.footprintToDateProfile(footprint);\n                    this.publiclyTrigger('select', {\n                        context: this,\n                        args: [\n                            dateProfile.start,\n                            dateProfile.end,\n                            ev,\n                            this,\n                            footprint.resourceId ?\n                                this.calendar.resourceManager.getResourceById(footprint.resourceId) :\n                                null\n                        ]\n                    });\n                };\n                // override the view's default trigger in order to provide a resourceId to the `drop` event\n                // TODO: make more DRY with core\n                ResourceViewMixin.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {\n                    // trigger 'drop' regardless of whether element represents an event\n                    this.publiclyTrigger('drop', {\n                        context: el[0],\n                        args: [\n                            singleEventDef.dateProfile.start.clone(),\n                            ev,\n                            ui,\n                            singleEventDef.getResourceIds()[0],\n                            this\n                        ]\n                    });\n                    if (isEvent) {\n                        // signal an external event landed\n                        this.publiclyTrigger('eventReceive', {\n                            context: this,\n                            args: [\n                                singleEventDef.buildInstance().toLegacy(),\n                                this\n                            ]\n                        });\n                    }\n                };\n                return ResourceViewMixin;\n            }(fullcalendar_1.Mixin));\n            exports.default = ResourceViewMixin;\n            ResourceViewMixin.prototype.isResourcesRendered = false;\n            /***/ \n        }),\n        /* 10 */ ,\n        /* 11 */ ,\n        /* 12 */ ,\n        /* 13 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceDayTableMixin_1 = __webpack_require__(21);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            var ResourceDayGrid = (function (_super) {\n                tslib_1.__extends(ResourceDayGrid, _super);\n                function ResourceDayGrid(view) {\n                    var _this = _super.call(this, view) || this;\n                    _this.isResourceFootprintsEnabled = true;\n                    return _this;\n                }\n                ResourceDayGrid.prototype.renderDates = function (dateProfile) {\n                    this.dateProfile = dateProfile;\n                };\n                ResourceDayGrid.prototype.renderResources = function (resources) {\n                    this.registerResources(resources);\n                    this.renderGrid();\n                    if (this.headContainerEl) {\n                        this.processHeadResourceEls(this.headContainerEl);\n                    }\n                };\n                // TODO: make DRY with ResourceTimeGrid\n                ResourceDayGrid.prototype.getHitFootprint = function (hit) {\n                    var plainFootprint = _super.prototype.getHitFootprint.call(this, hit);\n                    return new ResourceComponentFootprint_1.default(plainFootprint.unzonedRange, plainFootprint.isAllDay, this.getColResource(hit.col).id);\n                };\n                ResourceDayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    var resourceCnt = this.resourceCnt;\n                    var genericSegs = this.datesAboveResources ?\n                        this.sliceRangeByDay(componentFootprint.unzonedRange) : // each day-per-resource will need its own column\n                        this.sliceRangeByRow(componentFootprint.unzonedRange);\n                    var resourceSegs = [];\n                    for (var _i = 0, genericSegs_1 = genericSegs; _i < genericSegs_1.length; _i++) {\n                        var seg = genericSegs_1[_i];\n                        for (var resourceIndex = 0; resourceIndex < resourceCnt; resourceIndex++) {\n                            var resourceObj = this.flattenedResources[resourceIndex];\n                            if (!(componentFootprint instanceof ResourceComponentFootprint_1.default) ||\n                                (componentFootprint.resourceId === resourceObj.id)) {\n                                var copy = $.extend({}, seg);\n                                copy.resource = resourceObj;\n                                if (this.isRTL) {\n                                    copy.leftCol = this.indicesToCol(resourceIndex, seg.lastRowDayIndex);\n                                    copy.rightCol = this.indicesToCol(resourceIndex, seg.firstRowDayIndex);\n                                }\n                                else {\n                                    copy.leftCol = this.indicesToCol(resourceIndex, seg.firstRowDayIndex);\n                                    copy.rightCol = this.indicesToCol(resourceIndex, seg.lastRowDayIndex);\n                                }\n                                resourceSegs.push(copy);\n                            }\n                        }\n                    }\n                    return resourceSegs;\n                };\n                return ResourceDayGrid;\n            }(fullcalendar_1.DayGrid));\n            exports.default = ResourceDayGrid;\n            ResourceDayTableMixin_1.default.mixInto(ResourceDayGrid);\n            /***/ \n        }),\n        /* 14 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var moment = __webpack_require__(15);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ClippedScroller_1 = __webpack_require__(24);\n            var ScrollerCanvas_1 = __webpack_require__(25);\n            var ScrollJoiner_1 = __webpack_require__(16);\n            var ScrollFollower_1 = __webpack_require__(26);\n            var TimelineEventRenderer_1 = __webpack_require__(17);\n            var TimelineFillRenderer_1 = __webpack_require__(28);\n            var TimelineHelperRenderer_1 = __webpack_require__(29);\n            var TimelineEventDragging_1 = __webpack_require__(40);\n            var TimelineEventResizing_1 = __webpack_require__(41);\n            var TimelineView_defaults_1 = __webpack_require__(42);\n            var TimelineView = (function (_super) {\n                tslib_1.__extends(TimelineView, _super);\n                function TimelineView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.emphasizeWeeks = false;\n                    _this.isTimeBodyScrolled = false;\n                    _this.slotWidth = _this.opt('slotWidth');\n                    return _this;\n                }\n                // Footprints\n                // ------------------------------------------------------------------------------------------------------------------\n                /*\n                TODO: avoid using Moments. use slat system somehow\n                THEN, can have componentFootprintToSegs handle this on its own\n                */\n                TimelineView.prototype.normalizeComponentFootprint = function (componentFootprint) {\n                    var adjustedEnd;\n                    var adjustedStart;\n                    var unzonedRange = componentFootprint.unzonedRange;\n                    if (this.isTimeScale) {\n                        adjustedStart = this.normalizeGridDate(unzonedRange.getStart());\n                        adjustedEnd = this.normalizeGridDate(unzonedRange.getEnd());\n                    }\n                    else {\n                        var dayRange = this.computeDayRange(unzonedRange);\n                        if (this.largeUnit) {\n                            adjustedStart = dayRange.start.clone().startOf(this.largeUnit);\n                            adjustedEnd = dayRange.end.clone().startOf(this.largeUnit);\n                            // if date is partially through the interval, or is in the same interval as the start,\n                            // make the exclusive end be the *next* interval\n                            if (!adjustedEnd.isSame(dayRange.end) || !adjustedEnd.isAfter(adjustedStart)) {\n                                adjustedEnd.add(this.slotDuration);\n                            }\n                        }\n                        else {\n                            adjustedStart = dayRange.start;\n                            adjustedEnd = dayRange.end;\n                        }\n                    }\n                    return new fullcalendar_1.ComponentFootprint(new fullcalendar_1.UnzonedRange(adjustedStart, adjustedEnd), !this.isTimeScale // isAllDay\n                    );\n                };\n                TimelineView.prototype.componentFootprintToSegs = function (footprint) {\n                    var footprintStart = footprint.unzonedRange.getStart();\n                    var footprintEnd = footprint.unzonedRange.getEnd();\n                    var normalFootprint = this.normalizeComponentFootprint(footprint);\n                    var segs = [];\n                    // protect against when the span is entirely in an invalid date region\n                    if (this.computeDateSnapCoverage(footprintStart) < this.computeDateSnapCoverage(footprintEnd)) {\n                        // intersect the footprint's range with the grid'd range\n                        var segRange = normalFootprint.unzonedRange.intersect(this.normalizedUnzonedRange);\n                        if (segRange) {\n                            var segStart = segRange.getStart();\n                            var segEnd = segRange.getEnd();\n                            segs.push({\n                                start: segStart,\n                                end: segEnd,\n                                isStart: segRange.isStart && this.isValidDate(segStart),\n                                isEnd: segRange.isEnd && this.isValidDate(segEnd.clone().subtract(1))\n                            });\n                        }\n                    }\n                    // TODO: what if month slots? should round it to nearest month\n                    // TODO: dragging/resizing in this situation? deltas for dragging/resizing breaks down\n                    return segs;\n                };\n                // Date Computation\n                // ------------------------------------------------------------------------------------------------------------------\n                /*\n                Makes the given date consistent with isTimeScale/largeUnit,\n                so, either removes the times, ensures a time, or makes it the startOf largeUnit.\n                Strips all timezones. Returns new copy.\n                TODO: should maybe be called \"normalizeRangeDate\".\n                */\n                TimelineView.prototype.normalizeGridDate = function (date) {\n                    var normalDate = date.clone();\n                    this.calendar.localizeMoment(normalDate); // mostly for startOf\n                    if (this.isTimeScale) {\n                        if (!normalDate.hasTime()) {\n                            normalDate.time(0);\n                        }\n                    }\n                    else {\n                        normalDate = normalDate.clone().stripTime();\n                        if (this.largeUnit) {\n                            normalDate.startOf(this.largeUnit);\n                        }\n                    }\n                    return normalDate;\n                };\n                TimelineView.prototype.isValidDate = function (date) {\n                    if (this.isHiddenDay(date)) {\n                        return false;\n                    }\n                    else if (this.isTimeScale) {\n                        // determine if the time is within minTime/maxTime, which may have wacky values\n                        var ms = date.time() - this.dateProfile.minTime; // milliseconds since minTime\n                        ms = ((ms % 86400000) + 86400000) % 86400000; // make negative values wrap to 24hr clock\n                        return ms < this.timeWindowMs; // before the maxTime?\n                    }\n                    else {\n                        return true;\n                    }\n                };\n                TimelineView.prototype.updateGridDates = function () {\n                    var snapIndex = -1;\n                    var snapDiff = 0; // index of the diff :(\n                    var snapDiffToIndex = [];\n                    var snapIndexToDiff = [];\n                    var date = this.normalizedUnzonedStart.clone();\n                    while (date < this.normalizedUnzonedEnd) {\n                        if (this.isValidDate(date)) {\n                            snapIndex++;\n                            snapDiffToIndex.push(snapIndex);\n                            snapIndexToDiff.push(snapDiff);\n                        }\n                        else {\n                            snapDiffToIndex.push(snapIndex + 0.5);\n                        }\n                        date.add(this.snapDuration);\n                        snapDiff++;\n                    }\n                    this.snapDiffToIndex = snapDiffToIndex;\n                    this.snapIndexToDiff = snapIndexToDiff;\n                    this.snapCnt = snapIndex + 1; // is always one behind\n                    this.slotCnt = this.snapCnt / this.snapsPerSlot;\n                };\n                // Skeleton Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.renderSkeleton = function () {\n                    this.el.addClass('fc-timeline');\n                    if (this.opt('eventOverlap') === false) {\n                        this.el.addClass('fc-no-overlap');\n                    }\n                    this.el.html(this.renderSkeletonHtml());\n                    this.timeHeadEl = this.el.find('thead .fc-time-area');\n                    this.timeBodyEl = this.el.find('tbody .fc-time-area');\n                    this.timeHeadScroller = new ClippedScroller_1.default({\n                        overflowX: 'clipped-scroll',\n                        overflowY: 'hidden'\n                    });\n                    this.timeHeadScroller.canvas = new ScrollerCanvas_1.default();\n                    this.timeHeadScroller.render();\n                    this.timeHeadScroller.el.appendTo(this.timeHeadEl);\n                    this.timeBodyScroller = new ClippedScroller_1.default();\n                    this.timeBodyScroller.canvas = new ScrollerCanvas_1.default();\n                    this.timeBodyScroller.render();\n                    this.timeBodyScroller.el.appendTo(this.timeBodyEl);\n                    this.isTimeBodyScrolled = false; // because if the grid has been rerendered, it will get a zero scroll\n                    this.timeBodyScroller.on('scroll', fullcalendar_1.proxy(this, 'handleTimeBodyScrolled'));\n                    this.slatContainerEl = $('<div class=\"fc-slats\"/>').appendTo(this.timeBodyScroller.canvas.bgEl);\n                    this.segContainerEl = $('<div class=\"fc-event-container\"/>').appendTo(this.timeBodyScroller.canvas.contentEl);\n                    this.bgSegContainerEl = this.timeBodyScroller.canvas.bgEl;\n                    this.timeBodyBoundCache = new fullcalendar_1.CoordCache({\n                        els: this.timeBodyScroller.canvas.el,\n                        isHorizontal: true,\n                        isVertical: true\n                    });\n                    this.timeScrollJoiner = new ScrollJoiner_1.default('horizontal', [this.timeHeadScroller, this.timeBodyScroller]);\n                    // the date/time text on the top axis that stays put while scrolling happens\n                    this.headDateFollower = new ScrollFollower_1.default(this.timeHeadScroller, true); // allowPointerEvents=true\n                    // the event titles that stay put while scrolling happens\n                    this.eventTitleFollower = new ScrollFollower_1.default(this.timeBodyScroller);\n                    this.eventTitleFollower.minTravel = 50;\n                    //\n                    if (this.isRTL) {\n                        this.eventTitleFollower.containOnNaturalRight = true;\n                    }\n                    else {\n                        this.eventTitleFollower.containOnNaturalLeft = true;\n                    }\n                    _super.prototype.renderSkeleton.call(this);\n                };\n                TimelineView.prototype.renderSkeletonHtml = function () {\n                    var theme = this.calendar.theme;\n                    return \"<table class=\\\"\" + theme.getClass('tableGrid') + \"\\\"> <thead class=\\\"fc-head\\\"> <tr> <td class=\\\"fc-time-area \" + theme.getClass('widgetHeader') + \"\\\"></td> </tr> </thead> <tbody class=\\\"fc-body\\\"> <tr> <td class=\\\"fc-time-area \" + theme.getClass('widgetContent') + \"\\\"></td> </tr> </tbody> </table>\";\n                };\n                TimelineView.prototype.unrenderSkeleton = function () {\n                    this.handleTimeBodyScrolled(0);\n                    _super.prototype.unrenderSkeleton.call(this);\n                };\n                // Date Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.renderDates = function (dateProfile) {\n                    TimelineView_defaults_1.initScaleProps(this);\n                    this.timeWindowMs = dateProfile.maxTime - dateProfile.minTime;\n                    // makes sure zone is stripped\n                    this.normalizedUnzonedStart = this.normalizeGridDate(dateProfile.renderUnzonedRange.getStart());\n                    this.normalizedUnzonedEnd = this.normalizeGridDate(dateProfile.renderUnzonedRange.getEnd());\n                    // apply minTime/maxTime\n                    // TODO: move towards .time(), but didn't play well with negatives.\n                    // TODO: View should be responsible.\n                    if (this.isTimeScale) {\n                        this.normalizedUnzonedStart.add(dateProfile.minTime);\n                        this.normalizedUnzonedEnd.subtract(1, 'day').add(dateProfile.maxTime);\n                    }\n                    this.normalizedUnzonedRange = new fullcalendar_1.UnzonedRange(this.normalizedUnzonedStart, this.normalizedUnzonedEnd);\n                    var slotDates = [];\n                    var date = this.normalizedUnzonedStart.clone();\n                    this.calendar.localizeMoment(date);\n                    while (date < this.normalizedUnzonedEnd) {\n                        if (this.isValidDate(date)) {\n                            slotDates.push(date.clone());\n                        }\n                        date.add(this.slotDuration);\n                    }\n                    this.slotDates = slotDates;\n                    this.updateGridDates();\n                    var slatHtmlRes = this.renderSlatHtml();\n                    this.timeHeadScroller.canvas.contentEl.html(slatHtmlRes.headHtml);\n                    this.timeHeadColEls = this.timeHeadScroller.canvas.contentEl.find('col');\n                    this.slatContainerEl.html(slatHtmlRes.bodyHtml);\n                    this.slatColEls = this.slatContainerEl.find('col');\n                    this.slatEls = this.slatContainerEl.find('td');\n                    this.slatCoordCache = new fullcalendar_1.CoordCache({\n                        els: this.slatEls,\n                        isHorizontal: true\n                    });\n                    // for the inner divs within the slats\n                    // used for event rendering and scrollTime, to disregard slat border\n                    this.slatInnerCoordCache = new fullcalendar_1.CoordCache({\n                        els: this.slatEls.find('> div'),\n                        isHorizontal: true,\n                        // we use this coord cache for getPosition* for event rendering.\n                        // workaround for .fc-content's negative margins.\n                        offsetParent: this.timeBodyScroller.canvas.el\n                    });\n                    for (var i = 0; i < this.slotDates.length; i++) {\n                        date = this.slotDates[i];\n                        this.publiclyTrigger('dayRender', {\n                            context: this,\n                            args: [date, this.slatEls.eq(i), this]\n                        });\n                    }\n                    if (this.headDateFollower) {\n                        this.headDateFollower.setSpriteEls(this.timeHeadEl.find('tr:not(:last-child) .fc-cell-text'));\n                    }\n                };\n                TimelineView.prototype.unrenderDates = function () {\n                    if (this.headDateFollower) {\n                        this.headDateFollower.clearSprites();\n                    }\n                    this.timeHeadScroller.canvas.contentEl.empty();\n                    this.slatContainerEl.empty();\n                    // clear the widths,\n                    // for no jupiness when navigating\n                    this.timeHeadScroller.canvas.clearWidth();\n                    this.timeBodyScroller.canvas.clearWidth();\n                };\n                TimelineView.prototype.renderSlatHtml = function () {\n                    var cell;\n                    var date;\n                    var rowCells;\n                    var format;\n                    var theme = this.calendar.theme;\n                    var labelInterval = this.labelInterval;\n                    var formats = this.headerFormats;\n                    var cellRows = formats.map(function (format) { return []; }); // indexed by row,col\n                    var leadingCell = null;\n                    var prevWeekNumber = null;\n                    var slotDates = this.slotDates;\n                    var slotCells = []; // meta\n                    var rowUnits = formats.map(function (format) { return (fullcalendar_1.queryMostGranularFormatUnit(format)); });\n                    for (var _i = 0, slotDates_1 = slotDates; _i < slotDates_1.length; _i++) {\n                        date = slotDates_1[_i];\n                        var weekNumber = date.week();\n                        var isWeekStart = this.emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber);\n                        for (var row = 0; row < formats.length; row++) {\n                            format = formats[row];\n                            rowCells = cellRows[row];\n                            leadingCell = rowCells[rowCells.length - 1];\n                            var isSuperRow = (formats.length > 1) && (row < (formats.length - 1)); // more than one row and not the last\n                            var newCell = null;\n                            if (isSuperRow) {\n                                var text = date.format(format);\n                                if (!leadingCell || (leadingCell.text !== text)) {\n                                    newCell = this.buildCellObject(date, text, rowUnits[row]);\n                                }\n                                else {\n                                    leadingCell.colspan += 1;\n                                }\n                            }\n                            else {\n                                if (!leadingCell || fullcalendar_1.isInt(fullcalendar_1.divideRangeByDuration(this.normalizedUnzonedStart, date, labelInterval))) {\n                                    var text = date.format(format);\n                                    newCell = this.buildCellObject(date, text, rowUnits[row]);\n                                }\n                                else {\n                                    leadingCell.colspan += 1;\n                                }\n                            }\n                            if (newCell) {\n                                newCell.weekStart = isWeekStart;\n                                rowCells.push(newCell);\n                            }\n                        }\n                        slotCells.push({ weekStart: isWeekStart });\n                        prevWeekNumber = weekNumber;\n                    }\n                    var isChrono = labelInterval > this.slotDuration;\n                    var isSingleDay = this.slotDuration.as('days') === 1;\n                    var html = '<table class=\"' + theme.getClass('tableGrid') + '\">';\n                    html += '<colgroup>';\n                    for (var _a = 0, slotDates_2 = slotDates; _a < slotDates_2.length; _a++) {\n                        date = slotDates_2[_a];\n                        html += '<col/>';\n                    }\n                    html += '</colgroup>';\n                    html += '<tbody>';\n                    for (var i = 0; i < cellRows.length; i++) {\n                        rowCells = cellRows[i];\n                        var isLast = i === (cellRows.length - 1);\n                        html += '<tr' + (isChrono && isLast ? ' class=\"fc-chrono\"' : '') + '>';\n                        for (var _b = 0, rowCells_1 = rowCells; _b < rowCells_1.length; _b++) {\n                            cell = rowCells_1[_b];\n                            var headerCellClassNames = [theme.getClass('widgetHeader')];\n                            if (cell.weekStart) {\n                                headerCellClassNames.push('fc-em-cell');\n                            }\n                            if (isSingleDay) {\n                                headerCellClassNames = headerCellClassNames.concat(this.getDayClasses(cell.date, true) // adds \"today\" class and other day-based classes\n                                );\n                            }\n                            html +=\n                                '<th class=\"' + headerCellClassNames.join(' ') + '\"' +\n                                    ' data-date=\"' + cell.date.format() + '\"' +\n                                    (cell.colspan > 1 ? ' colspan=\"' + cell.colspan + '\"' : '') +\n                                    '>' +\n                                    '<div class=\"fc-cell-content\">' +\n                                    cell.spanHtml +\n                                    '</div>' +\n                                    '</th>';\n                        }\n                        html += '</tr>';\n                    }\n                    html += '</tbody></table>';\n                    var slatHtml = '<table class=\"' + theme.getClass('tableGrid') + '\">';\n                    slatHtml += '<colgroup>';\n                    for (var _c = 0, slotCells_1 = slotCells; _c < slotCells_1.length; _c++) {\n                        cell = slotCells_1[_c];\n                        slatHtml += '<col/>';\n                    }\n                    slatHtml += '</colgroup>';\n                    slatHtml += '<tbody><tr>';\n                    for (var i = 0; i < slotCells.length; i++) {\n                        cell = slotCells[i];\n                        date = slotDates[i];\n                        slatHtml += this.slatCellHtml(date, cell.weekStart);\n                    }\n                    slatHtml += '</tr></tbody></table>';\n                    return { headHtml: html, bodyHtml: slatHtml };\n                };\n                TimelineView.prototype.buildCellObject = function (date, text, rowUnit) {\n                    date = date.clone(); // ensure our own reference\n                    var spanHtml = this.buildGotoAnchorHtml({\n                        date: date,\n                        type: rowUnit,\n                        forceOff: !rowUnit\n                    }, {\n                        'class': 'fc-cell-text'\n                    }, fullcalendar_1.htmlEscape(text));\n                    return { text: text, spanHtml: spanHtml, date: date, colspan: 1 };\n                };\n                TimelineView.prototype.slatCellHtml = function (date, isEm) {\n                    var classes;\n                    var theme = this.calendar.theme;\n                    if (this.isTimeScale) {\n                        classes = [];\n                        classes.push(fullcalendar_1.isInt(fullcalendar_1.divideRangeByDuration(this.normalizedUnzonedStart, date, this.labelInterval)) ?\n                            'fc-major' :\n                            'fc-minor');\n                    }\n                    else {\n                        classes = this.getDayClasses(date);\n                        classes.push('fc-day');\n                    }\n                    classes.unshift(theme.getClass('widgetContent'));\n                    if (isEm) {\n                        classes.push('fc-em-cell');\n                    }\n                    return '<td class=\"' + classes.join(' ') + '\"' +\n                        ' data-date=\"' + date.format() + '\"' +\n                        '><div /></td>';\n                };\n                // Business Hours\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.renderBusinessHours = function (businessHourPayload) {\n                    if (!this.largeUnit) {\n                        return _super.prototype.renderBusinessHours.call(this, businessHourPayload);\n                    }\n                };\n                // Now Indicator\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.getNowIndicatorUnit = function () {\n                    // TODO: converge with largeUnit. precompute\n                    if (this.isTimeScale) {\n                        return fullcalendar_1.computeGreatestUnit(this.slotDuration);\n                    }\n                };\n                // will only execute if isTimeScale\n                TimelineView.prototype.renderNowIndicator = function (date) {\n                    var nodes = [];\n                    date = this.normalizeGridDate(date);\n                    if (this.normalizedUnzonedRange.containsDate(date)) {\n                        var coord = this.dateToCoord(date);\n                        var css = this.isRTL ?\n                            { right: -coord } :\n                            { left: coord };\n                        nodes.push($(\"<div class='fc-now-indicator fc-now-indicator-arrow'></div>\")\n                            .css(css)\n                            .appendTo(this.timeHeadScroller.canvas.el)[0]);\n                        nodes.push($(\"<div class='fc-now-indicator fc-now-indicator-line'></div>\")\n                            .css(css)\n                            .appendTo(this.timeBodyScroller.canvas.el)[0]);\n                    }\n                    this.nowIndicatorEls = $(nodes);\n                };\n                // will only execute if isTimeScale\n                TimelineView.prototype.unrenderNowIndicator = function () {\n                    if (this.nowIndicatorEls) {\n                        this.nowIndicatorEls.remove();\n                        this.nowIndicatorEls = null;\n                    }\n                };\n                // Sizing\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    var bodyHeight;\n                    var containerMinWidth;\n                    var containerWidth;\n                    var nonLastSlotWidth;\n                    if (isAuto) {\n                        bodyHeight = 'auto';\n                    }\n                    else {\n                        bodyHeight = totalHeight - this.headHeight() - this.queryMiscHeight();\n                    }\n                    this.timeBodyScroller.setHeight(bodyHeight);\n                    // reason for this complicated method is that things went wrong when:\n                    //  slots/headers didn't fill content area and needed to be stretched\n                    //  cells wouldn't align (rounding issues with available width calculated\n                    //  differently because of padding VS scrollbar trick)\n                    var isDatesRendered = this.timeHeadColEls; // TODO: refactor use of this\n                    if (isDatesRendered) {\n                        var slotWidth = Math.round(this.slotWidth || (this.slotWidth = this.computeSlotWidth()));\n                        containerWidth = slotWidth * this.slotDates.length;\n                        containerMinWidth = '';\n                        nonLastSlotWidth = slotWidth;\n                        var availableWidth = this.timeBodyScroller.getClientWidth();\n                        if (availableWidth > containerWidth) {\n                            containerMinWidth = availableWidth;\n                            containerWidth = '';\n                            nonLastSlotWidth = Math.floor(availableWidth / this.slotDates.length);\n                        }\n                    }\n                    else {\n                        containerWidth = '';\n                        containerMinWidth = '';\n                    }\n                    this.timeHeadScroller.canvas.setWidth(containerWidth);\n                    this.timeHeadScroller.canvas.setMinWidth(containerMinWidth);\n                    this.timeBodyScroller.canvas.setWidth(containerWidth);\n                    this.timeBodyScroller.canvas.setMinWidth(containerMinWidth);\n                    if (isDatesRendered) {\n                        this.timeHeadColEls.slice(0, -1).add(this.slatColEls.slice(0, -1))\n                            .css('width', nonLastSlotWidth);\n                    }\n                    this.timeHeadScroller.updateSize();\n                    this.timeBodyScroller.updateSize();\n                    this.timeScrollJoiner.update();\n                    if (isDatesRendered) {\n                        this.buildCoords();\n                        // TODO: left/right CSS assignment also happens earlier in renderFgSegs\n                        this.updateSegPositions();\n                        // this updateSize method is triggered by callers who don't always subsequently call updateNowIndicator,\n                        // and updateSize always has the risk of changing horizontal spacing which will affect nowIndicator positioning,\n                        // so always call it here too. will often rerender twice unfortunately.\n                        // TODO: more closely integrate updateSize with updateNowIndicator\n                        this.updateNowIndicator();\n                    }\n                    if (this.headDateFollower) {\n                        this.headDateFollower.update();\n                    }\n                    if (this.eventTitleFollower) {\n                        this.eventTitleFollower.update();\n                    }\n                };\n                TimelineView.prototype.queryMiscHeight = function () {\n                    return this.el.outerHeight() -\n                        this.timeHeadScroller.el.outerHeight() -\n                        this.timeBodyScroller.el.outerHeight();\n                };\n                TimelineView.prototype.computeSlotWidth = function () {\n                    var maxInnerWidth = 0; // TODO: harness core's `matchCellWidths` for this\n                    var innerEls = this.timeHeadEl.find('tr:last-child th .fc-cell-text'); // TODO: cache\n                    innerEls.each(function (i, node) {\n                        var innerWidth = $(node).outerWidth();\n                        return maxInnerWidth = Math.max(maxInnerWidth, innerWidth);\n                    });\n                    var headerWidth = maxInnerWidth + 1; // assume no padding, and one pixel border\n                    var slotsPerLabel = fullcalendar_1.divideDurationByDuration(this.labelInterval, this.slotDuration); // TODO: rename labelDuration?\n                    var slotWidth = Math.ceil(headerWidth / slotsPerLabel);\n                    var minWidth = this.timeHeadColEls.eq(0).css('min-width');\n                    if (minWidth) {\n                        minWidth = parseInt(minWidth, 10);\n                        if (minWidth) {\n                            slotWidth = Math.max(slotWidth, minWidth);\n                        }\n                    }\n                    return slotWidth;\n                };\n                // Coordinates\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.buildCoords = function () {\n                    this.timeBodyBoundCache.build();\n                    this.slatCoordCache.build();\n                    this.slatInnerCoordCache.build();\n                };\n                // returned value is between 0 and the number of snaps\n                TimelineView.prototype.computeDateSnapCoverage = function (date) {\n                    var snapDiff = fullcalendar_1.divideRangeByDuration(this.normalizedUnzonedStart, date, this.snapDuration);\n                    if (snapDiff < 0) {\n                        return 0;\n                    }\n                    else if (snapDiff >= this.snapDiffToIndex.length) {\n                        return this.snapCnt;\n                    }\n                    else {\n                        var snapDiffInt = Math.floor(snapDiff);\n                        var snapCoverage = this.snapDiffToIndex[snapDiffInt];\n                        if (fullcalendar_1.isInt(snapCoverage)) {\n                            snapCoverage += snapDiff - snapDiffInt; // add the remainder\n                        }\n                        else {\n                            // a fractional value, meaning the date is not visible\n                            // always round up in this case. works for start AND end dates in a range.\n                            snapCoverage = Math.ceil(snapCoverage);\n                        }\n                        return snapCoverage;\n                    }\n                };\n                // for LTR, results range from 0 to width of area\n                // for RTL, results range from negative width of area to 0\n                TimelineView.prototype.dateToCoord = function (date) {\n                    var snapCoverage = this.computeDateSnapCoverage(date);\n                    var slotCoverage = snapCoverage / this.snapsPerSlot;\n                    var slotIndex = Math.floor(slotCoverage);\n                    slotIndex = Math.min(slotIndex, this.slotCnt - 1);\n                    var partial = slotCoverage - slotIndex;\n                    var coordCache = this.slatInnerCoordCache;\n                    if (this.isRTL) {\n                        return (coordCache.getRightPosition(slotIndex) -\n                            (coordCache.getWidth(slotIndex) * partial)) - this.timeBodyBoundCache.getWidth(0);\n                    }\n                    else {\n                        return (coordCache.getLeftPosition(slotIndex) +\n                            (coordCache.getWidth(slotIndex) * partial));\n                    }\n                };\n                TimelineView.prototype.rangeToCoords = function (range) {\n                    if (this.isRTL) {\n                        return { right: this.dateToCoord(range.start), left: this.dateToCoord(range.end) };\n                    }\n                    else {\n                        return { left: this.dateToCoord(range.start), right: this.dateToCoord(range.end) };\n                    }\n                };\n                // a getter / setter\n                TimelineView.prototype.headHeight = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var table = this.timeHeadScroller.canvas.contentEl.find('table');\n                    return table.height.apply(table, args);\n                };\n                // this needs to be called if v scrollbars appear on body container. or zooming\n                TimelineView.prototype.updateSegPositions = function () {\n                    var segs = [].concat(this.getEventSegs(), this.getBusinessHourSegs());\n                    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                        var seg = segs_1[_i];\n                        var coords = this.rangeToCoords(seg);\n                        seg.el.css({\n                            left: (seg.left = coords.left),\n                            right: -(seg.right = coords.right)\n                        });\n                    }\n                };\n                // Scrolling\n                // ---------------------------------------------------------------------------------\n                TimelineView.prototype.handleTimeBodyScrolled = function (top) {\n                    if (top) {\n                        if (!this.isTimeBodyScrolled) {\n                            this.isTimeBodyScrolled = true;\n                            this.el.addClass('fc-scrolled');\n                        }\n                    }\n                    else {\n                        if (this.isTimeBodyScrolled) {\n                            this.isTimeBodyScrolled = false;\n                            this.el.removeClass('fc-scrolled');\n                        }\n                    }\n                };\n                TimelineView.prototype.computeInitialDateScroll = function () {\n                    var unzonedRange = this.get('dateProfile').activeUnzonedRange;\n                    var left = 0;\n                    if (this.isTimeScale) {\n                        var scrollTime = this.opt('scrollTime');\n                        if (scrollTime) {\n                            scrollTime = moment.duration(scrollTime);\n                            left = this.dateToCoord(unzonedRange.getStart().time(scrollTime)); // TODO: fix this for RTL\n                        }\n                    }\n                    return { left: left };\n                };\n                TimelineView.prototype.queryDateScroll = function () {\n                    return { left: this.timeBodyScroller.getScrollLeft() };\n                };\n                TimelineView.prototype.applyDateScroll = function (scroll) {\n                    if (scroll.left != null) {\n                        // TODO: workaround for FF. the ScrollJoiner sibling won't react fast enough\n                        // to override the native initial crappy scroll that FF applies.\n                        // TODO: have the ScrollJoiner handle this\n                        // Similar code in ResourceTimelineView::setScroll\n                        this.timeHeadScroller.setScrollLeft(scroll.left);\n                        this.timeBodyScroller.setScrollLeft(scroll.left);\n                    }\n                };\n                // Hit System\n                // ------------------------------------------------------------------------------------------------------------------\n                TimelineView.prototype.prepareHits = function () {\n                    this.buildCoords();\n                };\n                // FYI: we don't want to clear the slatCoordCache in releaseHits()\n                // because those coordinates are needed for dateToCoord()\n                TimelineView.prototype.queryHit = function (leftOffset, topOffset) {\n                    var snapsPerSlot = this.snapsPerSlot;\n                    var slatCoordCache = this.slatCoordCache;\n                    var timeBodyBoundCache = this.timeBodyBoundCache;\n                    // within scroll container's content rectangle?\n                    if (timeBodyBoundCache.isPointInBounds(leftOffset, topOffset)) {\n                        var slatIndex = slatCoordCache.getHorizontalIndex(leftOffset);\n                        if (slatIndex != null) {\n                            var localSnapIndex = void 0;\n                            var partial = void 0;\n                            var snapIndex = void 0;\n                            var snapLeft = void 0;\n                            var snapRight = void 0;\n                            var slatWidth = slatCoordCache.getWidth(slatIndex);\n                            if (this.isRTL) {\n                                var slatRight = slatCoordCache.getRightOffset(slatIndex);\n                                partial = (slatRight - leftOffset) / slatWidth;\n                                localSnapIndex = Math.floor(partial * snapsPerSlot);\n                                snapIndex = (slatIndex * snapsPerSlot) + localSnapIndex;\n                                snapRight = slatRight - ((localSnapIndex / snapsPerSlot) * slatWidth);\n                                snapLeft = snapRight - (((localSnapIndex + 1) / snapsPerSlot) * slatWidth);\n                            }\n                            else {\n                                var slatLeft = slatCoordCache.getLeftOffset(slatIndex);\n                                partial = (leftOffset - slatLeft) / slatWidth;\n                                localSnapIndex = Math.floor(partial * snapsPerSlot);\n                                snapIndex = (slatIndex * snapsPerSlot) + localSnapIndex;\n                                snapLeft = slatLeft + ((localSnapIndex / snapsPerSlot) * slatWidth);\n                                snapRight = slatLeft + (((localSnapIndex + 1) / snapsPerSlot) * slatWidth);\n                            }\n                            return {\n                                snap: snapIndex,\n                                component: this,\n                                left: snapLeft,\n                                right: snapRight,\n                                top: timeBodyBoundCache.getTopOffset(0),\n                                bottom: timeBodyBoundCache.getBottomOffset(0)\n                            };\n                        }\n                    }\n                };\n                TimelineView.prototype.getHitFootprint = function (hit) {\n                    return new fullcalendar_1.ComponentFootprint(this.getSnapUnzonedRange(hit.snap), !this.isTimeScale // isAllDay\n                    );\n                };\n                TimelineView.prototype.getHitEl = function (hit) {\n                    return this.getSnapEl(hit.snap); // TODO: write a test for this\n                };\n                /*\n                TODO: avoid using moments\n                */\n                TimelineView.prototype.getSnapUnzonedRange = function (snapIndex) {\n                    var start = this.normalizedUnzonedStart.clone();\n                    start.add(fullcalendar_1.multiplyDuration(this.snapDuration, this.snapIndexToDiff[snapIndex]));\n                    var end = start.clone().add(this.snapDuration);\n                    return new fullcalendar_1.UnzonedRange(start, end);\n                };\n                TimelineView.prototype.getSnapEl = function (snapIndex) {\n                    return this.slatEls.eq(Math.floor(snapIndex / this.snapsPerSlot));\n                };\n                // Event Resizing\n                // ------------------------------------------------------------------------------------------------------------------\n                // Renders a visual indication of an event being resized\n                TimelineView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    for (var _i = 0, eventFootprints_1 = eventFootprints; _i < eventFootprints_1.length; _i++) {\n                        var eventFootprint = eventFootprints_1[_i];\n                        this.renderHighlight(eventFootprint.componentFootprint);\n                    }\n                    return this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\n                };\n                // Unrenders a visual indication of an event being resized\n                TimelineView.prototype.unrenderEventResize = function () {\n                    this.unrenderHighlight();\n                    return this.helperRenderer.unrender();\n                };\n                // DnD\n                // ------------------------------------------------------------------------------------------------------------------\n                // TODO: different technique based on scale.\n                //  when dragging, middle of event is the drop.\n                //  should be the edges when isTimeScale.\n                TimelineView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    if (seg) {\n                        this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\n                        return true; // signal helper rendered\n                    }\n                    else {\n                        for (var _i = 0, eventFootprints_2 = eventFootprints; _i < eventFootprints_2.length; _i++) {\n                            var eventFootprint = eventFootprints_2[_i];\n                            this.renderHighlight(eventFootprint.componentFootprint);\n                        }\n                        return false; // signal helper not rendered\n                    }\n                };\n                TimelineView.prototype.unrenderDrag = function () {\n                    this.helperRenderer.unrender();\n                    return this.unrenderHighlight();\n                };\n                return TimelineView;\n            }(fullcalendar_1.View));\n            exports.default = TimelineView;\n            // config\n            TimelineView.prototype.usesMinMaxTime = true; // for View. indicates that minTime/maxTime affects rendering\n            // TODO: rename these\n            TimelineView.prototype.eventRendererClass = TimelineEventRenderer_1.default;\n            TimelineView.prototype.fillRendererClass = TimelineFillRenderer_1.default;\n            TimelineView.prototype.businessHourRendererClass = fullcalendar_1.BusinessHourRenderer;\n            TimelineView.prototype.helperRendererClass = TimelineHelperRenderer_1.default;\n            TimelineView.prototype.eventDraggingClass = TimelineEventDragging_1.default;\n            TimelineView.prototype.eventResizingClass = TimelineEventResizing_1.default;\n            fullcalendar_1.StandardInteractionsMixin.mixInto(TimelineView);\n            /***/ \n        }),\n        /* 15 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE_15__;\n            /***/ \n        }),\n        /* 16 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var ScrollJoiner = /*@__PURE__*/ (function () {\n                function ScrollJoiner(axis, scrollers) {\n                    this.axis = axis;\n                    this.scrollers = scrollers;\n                    for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n                        var scroller = _a[_i];\n                        this.initScroller(scroller);\n                    }\n                }\n                ScrollJoiner.prototype.initScroller = function (scroller) {\n                    var _this = this;\n                    // when the user scrolls via mousewheel, we know for sure the target\n                    // scroller should be the master. capture the various x-browser events that fire.\n                    scroller.scrollEl.on('wheel mousewheel DomMouseScroll MozMousePixelScroll', function () {\n                        _this.assignMasterScroller(scroller);\n                    });\n                    scroller.on('scrollStart', function () {\n                        if (!_this.masterScroller) {\n                            _this.assignMasterScroller(scroller);\n                        }\n                    }).on('scroll', function () {\n                        if (scroller === _this.masterScroller) {\n                            for (var _i = 0, _a = _this.scrollers; _i < _a.length; _i++) {\n                                var otherScroller = _a[_i];\n                                if (otherScroller !== scroller) {\n                                    switch (_this.axis) {\n                                        case 'horizontal':\n                                            otherScroller.setNativeScrollLeft(scroller.getNativeScrollLeft());\n                                            break;\n                                        case 'vertical':\n                                            otherScroller.setScrollTop(scroller.getScrollTop());\n                                            break;\n                                    }\n                                }\n                            }\n                        }\n                    }).on('scrollEnd', function () {\n                        if (scroller === _this.masterScroller) {\n                            _this.unassignMasterScroller();\n                        }\n                    });\n                };\n                ScrollJoiner.prototype.assignMasterScroller = function (scroller) {\n                    this.unassignMasterScroller();\n                    this.masterScroller = scroller;\n                    for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n                        var otherScroller = _a[_i];\n                        if (otherScroller !== scroller) {\n                            otherScroller.disableTouchScroll();\n                        }\n                    }\n                };\n                ScrollJoiner.prototype.unassignMasterScroller = function () {\n                    if (this.masterScroller) {\n                        for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n                            var otherScroller = _a[_i];\n                            otherScroller.enableTouchScroll();\n                        }\n                        this.masterScroller = null;\n                    }\n                };\n                ScrollJoiner.prototype.update = function () {\n                    var allWidths = this.scrollers.map(function (scroller) { return scroller.getScrollbarWidths(); });\n                    var maxLeft = 0;\n                    var maxRight = 0;\n                    var maxTop = 0;\n                    var maxBottom = 0;\n                    var scroller;\n                    var widths;\n                    var i;\n                    for (var _i = 0, allWidths_1 = allWidths; _i < allWidths_1.length; _i++) {\n                        widths = allWidths_1[_i];\n                        maxLeft = Math.max(maxLeft, widths.left);\n                        maxRight = Math.max(maxRight, widths.right);\n                        maxTop = Math.max(maxTop, widths.top);\n                        maxBottom = Math.max(maxBottom, widths.bottom);\n                    }\n                    for (i = 0; i < this.scrollers.length; i++) {\n                        scroller = this.scrollers[i];\n                        widths = allWidths[i];\n                        scroller.canvas.setGutters(this.axis === 'horizontal' ?\n                            {\n                                left: maxLeft - widths.left,\n                                right: maxRight - widths.right\n                            } :\n                            {\n                                top: maxTop - widths.top,\n                                bottom: maxBottom - widths.bottom\n                            });\n                    }\n                };\n                return ScrollJoiner;\n            }());\n            exports.default = ScrollJoiner;\n            /***/ \n        }),\n        /* 17 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ScrollFollowerSprite_1 = __webpack_require__(27);\n            var TimelineEventRenderer = (function (_super) {\n                tslib_1.__extends(TimelineEventRenderer, _super);\n                function TimelineEventRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                component must be { segContainerEl, segContainerHeight, rangeToCoords }\n                */\n                TimelineEventRenderer.prototype.computeDisplayEventTime = function () {\n                    return !this.view.isTimeScale; // because times should be obvious via axis\n                };\n                TimelineEventRenderer.prototype.computeDisplayEventEnd = function () {\n                    return false;\n                };\n                // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n                TimelineEventRenderer.prototype.computeEventTimeFormat = function () {\n                    return this.view.opt('extraSmallTimeFormat');\n                };\n                TimelineEventRenderer.prototype.renderFgSegs = function (segs) {\n                    var eventTitleFollower = this.view.eventTitleFollower;\n                    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                        var seg = segs_1[_i];\n                        // TODO: centralize logic (also in updateSegPositions)\n                        var coords = this.component.rangeToCoords(seg);\n                        seg.el.css({\n                            left: (seg.left = coords.left),\n                            right: -(seg.right = coords.right)\n                        });\n                    }\n                    // attach segs\n                    for (var _a = 0, segs_2 = segs; _a < segs_2.length; _a++) {\n                        var seg = segs_2[_a];\n                        seg.el.appendTo(this.component.segContainerEl);\n                    }\n                    // compute seg verticals\n                    for (var _b = 0, segs_3 = segs; _b < segs_3.length; _b++) {\n                        var seg = segs_3[_b];\n                        seg.height = seg.el.outerHeight(true); // include margin\n                    }\n                    this.buildSegLevels(segs);\n                    this.component.segContainerHeight = computeOffsetForSegs(segs); // returns this value!\n                    // assign seg verticals\n                    for (var _c = 0, segs_4 = segs; _c < segs_4.length; _c++) {\n                        var seg = segs_4[_c];\n                        seg.el.css('top', seg.top);\n                    }\n                    this.component.segContainerEl.height(this.component.segContainerHeight);\n                    for (var _d = 0, segs_5 = segs; _d < segs_5.length; _d++) {\n                        var seg = segs_5[_d];\n                        var titleEl = seg.el.find('.fc-title');\n                        if (titleEl.length) {\n                            seg.scrollFollowerSprite = new ScrollFollowerSprite_1.default(titleEl);\n                            eventTitleFollower.addSprite(seg.scrollFollowerSprite);\n                        }\n                    }\n                };\n                // NOTE: this modifies the order of segs\n                TimelineEventRenderer.prototype.buildSegLevels = function (segs) {\n                    var segLevels = [];\n                    this.sortEventSegs(segs);\n                    for (var _i = 0, segs_6 = segs; _i < segs_6.length; _i++) {\n                        var unplacedSeg = segs_6[_i];\n                        unplacedSeg.above = [];\n                        // determine the first level with no collisions\n                        var level = 0; // level index\n                        while (level < segLevels.length) {\n                            var isLevelCollision = false;\n                            // determine collisions\n                            for (var _a = 0, _b = segLevels[level]; _a < _b.length; _a++) {\n                                var placedSeg = _b[_a];\n                                if (timeRowSegsCollide(unplacedSeg, placedSeg)) {\n                                    unplacedSeg.above.push(placedSeg);\n                                    isLevelCollision = true;\n                                }\n                            }\n                            if (isLevelCollision) {\n                                level += 1;\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // insert into the first non-colliding level. create if necessary\n                        (segLevels[level] || (segLevels[level] = []))\n                            .push(unplacedSeg);\n                        // record possible colliding segments below (TODO: automated test for this)\n                        level += 1;\n                        while (level < segLevels.length) {\n                            for (var _c = 0, _d = segLevels[level]; _c < _d.length; _c++) {\n                                var belowSeg = _d[_c];\n                                if (timeRowSegsCollide(unplacedSeg, belowSeg)) {\n                                    belowSeg.above.push(unplacedSeg);\n                                }\n                            }\n                            level += 1;\n                        }\n                    }\n                    return segLevels;\n                };\n                TimelineEventRenderer.prototype.unrenderFgSegs = function (segs) {\n                    if (this.component.segContainerEl) {\n                        var eventTitleFollower = this.view.eventTitleFollower;\n                        for (var _i = 0, segs_7 = segs; _i < segs_7.length; _i++) {\n                            var seg = segs_7[_i];\n                            if (seg.scrollFollowerSprite) {\n                                eventTitleFollower.removeSprite(seg.scrollFollowerSprite);\n                            }\n                        }\n                        this.component.segContainerEl.empty();\n                        this.component.segContainerEl.height('');\n                        this.component.segContainerHeight = null;\n                    }\n                };\n                TimelineEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\n                    var eventDef = seg.footprint.eventDef;\n                    var isDraggable = this.view.isEventDefDraggable(eventDef);\n                    var isResizableFromStart = seg.isStart && this.view.isEventDefResizableFromStart(eventDef);\n                    var isResizableFromEnd = seg.isEnd && this.view.isEventDefResizableFromEnd(eventDef);\n                    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n                    classes.unshift('fc-timeline-event', 'fc-h-event');\n                    var timeText = this.getTimeText(seg.footprint);\n                    return '<a class=\"' + classes.join(' ') + '\" style=\"' + fullcalendar_1.cssToStr(this.getSkinCss(seg.footprint.eventDef)) + '\"' +\n                        (eventDef.url ?\n                            ' href=\"' + fullcalendar_1.htmlEscape(eventDef.url) + '\"' :\n                            '') +\n                        '>' +\n                        '<div class=\"fc-content\">' +\n                        (timeText ?\n                            '<span class=\"fc-time\">' +\n                                fullcalendar_1.htmlEscape(timeText) +\n                                '</span>'\n                            :\n                                '') +\n                        '<span class=\"fc-title\">' +\n                        (eventDef.title ? fullcalendar_1.htmlEscape(eventDef.title) : '&nbsp;') +\n                        '</span>' +\n                        '</div>' +\n                        '<div class=\"fc-bg\" />' +\n                        (isResizableFromStart ?\n                            '<div class=\"fc-resizer fc-start-resizer\"></div>' :\n                            '') +\n                        (isResizableFromEnd ?\n                            '<div class=\"fc-resizer fc-end-resizer\"></div>' :\n                            '') +\n                        '</a>';\n                };\n                return TimelineEventRenderer;\n            }(fullcalendar_1.EventRenderer));\n            exports.default = TimelineEventRenderer;\n            // Seg Rendering Utils\n            // ----------------------------------------------------------------------------------------------------------------------\n            function computeOffsetForSegs(segs) {\n                var max = 0;\n                for (var _i = 0, segs_8 = segs; _i < segs_8.length; _i++) {\n                    var seg = segs_8[_i];\n                    max = Math.max(max, computeOffsetForSeg(seg));\n                }\n                return max;\n            }\n            function computeOffsetForSeg(seg) {\n                if ((seg.top == null)) {\n                    seg.top = computeOffsetForSegs(seg.above);\n                }\n                return seg.top + seg.height;\n            }\n            function timeRowSegsCollide(seg0, seg1) {\n                return (seg0.left < seg1.right) && (seg0.right > seg1.left);\n            }\n            /***/ \n        }),\n        /* 18 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var util_1 = __webpack_require__(44);\n            /*\n            An abstract node in a row-hierarchy tree.\n            May be a self-contained single row, a row with subrows,\n            OR a grouping of rows without its own distinct row.\n            */\n            var RowParent = (function (_super) {\n                tslib_1.__extends(RowParent, _super);\n                function RowParent(view) {\n                    var _this = _super.call(this, view) // will assign this.view\n                        || this;\n                    _this.children = [];\n                    _this.depth = 0;\n                    _this.trHash = {};\n                    _this.trs = $();\n                    _this.isExpanded = _this.view.opt('resourcesInitiallyExpanded');\n                    return _this;\n                }\n                // Hierarchy\n                // ------------------------------------------------------------------------------------------------------------------\n                /*\n                Adds the given node as a child.\n                Will be inserted at the `index`. If not given, will be appended to the end.\n                */\n                RowParent.prototype.addChildRowNode = function (child, index) {\n                    child.removeFromParentAndDom(); // in case it belonged somewhere else previously\n                    var children = this.children;\n                    // insert into the children array\n                    if (index != null) {\n                        children.splice(index, 0, child);\n                    }\n                    else {\n                        index = children.length;\n                        children.push(child);\n                    }\n                    // compute the previous sibling of child\n                    child.prevSibling =\n                        index > 0 ?\n                            children[index - 1] :\n                            null;\n                    // update the next sibling's prevSibling\n                    if (index < (children.length - 1)) {\n                        children[index + 1].prevSibling = child;\n                    }\n                    child.parent = this;\n                    child.depth = this.depth + (this.hasOwnRow ? 1 : 0);\n                    this.descendantAdded(child);\n                };\n                /*\n                Removes the given child from the node. Assumes it is a direct child.\n                If not a direct child, returns false and nothing happens.\n                */\n                RowParent.prototype.removeChild = function (child) {\n                    var i;\n                    var children = this.children;\n                    var isFound = false;\n                    // look for the node in the children array\n                    for (i = 0; i < children.length; i++) {\n                        var testChild = children[i];\n                        if (testChild === child) {\n                            isFound = true;\n                            break; // after this, `i` will contain the index\n                        }\n                    }\n                    if (!isFound) {\n                        return false; // return false if not found\n                    }\n                    else {\n                        // rewire the next sibling's prevSibling to skip\n                        if (i < (children.length - 1)) {\n                            children[i + 1].prevSibling = child.prevSibling;\n                        }\n                        children.splice(i, 1); // remove node from the array\n                        // unwire child from the parent/siblings\n                        child.parent = null;\n                        child.prevSibling = null;\n                        this.descendantRemoved(child);\n                        return child; // return on success (needed?)\n                    }\n                };\n                /*\n                Removes all of the node's children from the hierarchy.\n                */\n                RowParent.prototype.removeChildren = function () {\n                    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        this.descendantRemoved(child);\n                    }\n                    this.children = [];\n                };\n                /*\n                Removes this node from its parent\n                */\n                RowParent.prototype.removeFromParentAndDom = function () {\n                    if (this.parent) {\n                        this.parent.removeChild(this);\n                    }\n                    if (this.get('isInDom')) {\n                        this.removeElement();\n                    }\n                };\n                /*\n                Gets the last direct child node\n                */\n                RowParent.prototype.getLastChild = function () {\n                    var children = this.children;\n                    return children[children.length - 1];\n                };\n                /*\n                Walks backward in the hierarchy to find the previous row leaf node.\n                When looking at the hierarchy in a flat linear fashion, this is the revealed row just before the current.\n                */\n                RowParent.prototype.getPrevRowInDom = function () {\n                    var node = this;\n                    while (node) {\n                        if (node.prevSibling) {\n                            // attempt to go into the deepest last child of the previous sibling\n                            var lastChild = void 0;\n                            node = node.prevSibling;\n                            while ((lastChild = node.getLastChild())) {\n                                node = lastChild;\n                            }\n                        }\n                        else {\n                            // otherwise, move up to the parent\n                            node = node.parent;\n                        }\n                        // return this \"previous\" node if it has an exposed row\n                        if (node && node.get('isInDom') && node.hasOwnRow) {\n                            return node;\n                        }\n                    }\n                    return null;\n                };\n                /*\n                Returns the first node in the subtree that has a revealed row\n                */\n                RowParent.prototype.getLeadingRow = function () {\n                    if (this.hasOwnRow) {\n                        return this;\n                    }\n                    else if (this.isExpanded && this.children.length) {\n                        return this.children[0].getLeadingRow();\n                    }\n                };\n                /*\n                Generates a flat array containing all the row-nodes of the subtree. Descendants + self\n                */\n                RowParent.prototype.getRows = function (batchArray) {\n                    if (batchArray === void 0) {\n                        batchArray = [];\n                    }\n                    if (this.hasOwnRow) {\n                        batchArray.push(this);\n                    }\n                    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        child.getRows(batchArray);\n                    }\n                    return batchArray;\n                };\n                /*\n                Generates a flat array containing all the nodes (row/non-row) of the subtree. Descendants + self\n                */\n                RowParent.prototype.getNodes = function (batchArray) {\n                    if (batchArray === void 0) {\n                        batchArray = [];\n                    }\n                    batchArray.push(this);\n                    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        child.getNodes(batchArray);\n                    }\n                    return batchArray;\n                };\n                /*\n                Generates a flat array containing all the descendant nodes the current node\n                */\n                RowParent.prototype.getDescendants = function () {\n                    var batchArray = [];\n                    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        child.getNodes(batchArray);\n                    }\n                    return batchArray;\n                };\n                // Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                RowParent.prototype.show = function () {\n                    if (!this.get('isInDom')) {\n                        this.renderSkeleton();\n                    }\n                };\n                RowParent.prototype.hide = function () {\n                    if (this.get('isInDom')) {\n                        this.removeElement();\n                    }\n                };\n                /*\n                Builds and populates the TRs for each row type. Inserts them into the DOM.\n                Does this only for this single row. Not recursive. If not a row (hasOwnRow=false), does not render anything.\n                PRECONDITION: assumes the parent has already been rendered.\n                */\n                RowParent.prototype.renderSkeleton = function () {\n                    this.trHash = {};\n                    var trNodes = [];\n                    if (this.hasOwnRow) {\n                        var prevRow = this.getPrevRowInDom(); // the row before this row, in the overall linear flat list\n                        // let the view's tbody structure determine which TRs should be rendered\n                        for (var type in this.view.tbodyHash) {\n                            // build the TR and record it\n                            // assign before calling the render methods, because they might rely\n                            var tbody = this.view.tbodyHash[type];\n                            var tr = $('<tr/>');\n                            this.trHash[type] = tr;\n                            trNodes.push(tr[0]);\n                            // call the subclass' render method for this row type (if available)\n                            var renderMethodName = 'render' + fullcalendar_1.capitaliseFirstLetter(type) + 'Skeleton';\n                            if (this[renderMethodName]) {\n                                this[renderMethodName](tr);\n                            }\n                            // insert the TR into the DOM\n                            if (prevRow) {\n                                prevRow.trHash[type].after(tr);\n                            }\n                            else {\n                                tbody.prepend(tr); // belongs in the very first position\n                            }\n                        }\n                        // build a single jQuery object. use event delegation for calling toggleExpanded\n                        this.trs = $(trNodes)\n                            .on('click', '.fc-expander', fullcalendar_1.proxy(this, 'toggleExpanded'));\n                        this.thisRowShown();\n                    }\n                    this.set('isInDom', true);\n                    if (this.isExpanded) {\n                        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            child.renderSkeleton();\n                        }\n                    }\n                };\n                /*\n                Unpopulates and removes all of this row's TRs from the DOM. Only for this single row. Not recursive.\n                Will trigger \"hidden\".\n                */\n                RowParent.prototype.removeElement = function () {\n                    // call the subclass' render method for each row type (if available)\n                    for (var type in this.trHash) {\n                        var tr = this.trHash[type];\n                        var unrenderMethodName = 'unrender' + fullcalendar_1.capitaliseFirstLetter(type) + 'Skeleton';\n                        if (this[unrenderMethodName]) {\n                            this[unrenderMethodName](tr);\n                        }\n                    }\n                    this.unset('isInDom');\n                    this.thisRowHidden();\n                    this.trHash = {};\n                    this.trs.remove(); // remove from DOM\n                    this.trs = $();\n                    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        if (child.get('isInDom')) {\n                            child.removeElement();\n                        }\n                    }\n                };\n                /*\n                A simple getter for retrieving a TR jQuery object of a certain row type\n                */\n                RowParent.prototype.getTr = function (type) {\n                    return this.trHash[type];\n                };\n                // Expanding / Collapsing\n                // ------------------------------------------------------------------------------------------------------------------\n                // Use by row groups and rows with subrows\n                /*\n                Reveals this node's children if they have not already been revealed. Changes any expander icon.\n                */\n                RowParent.prototype.expand = function () {\n                    if (!this.isExpanded) {\n                        this.isExpanded = true;\n                        this.indicateExpanded();\n                        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            child.show();\n                        }\n                        this.view.calendar.updateViewSize(); // notify view of dimension change\n                        this.animateExpand();\n                    }\n                };\n                /*\n                Hides this node's children if they are not already hidden. Changes any expander icon.\n                */\n                RowParent.prototype.collapse = function () {\n                    if (this.isExpanded) {\n                        this.isExpanded = false;\n                        this.indicateCollapsed();\n                        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            child.hide();\n                        }\n                        this.view.calendar.updateViewSize(); // notify view of dimension change\n                    }\n                };\n                /*\n                Switches between expanded/collapsed states\n                */\n                RowParent.prototype.toggleExpanded = function () {\n                    if (this.isExpanded) {\n                        this.collapse();\n                    }\n                    else {\n                        this.expand();\n                    }\n                };\n                /*\n                Changes the expander icon to the \"expanded\" state\n                */\n                RowParent.prototype.indicateExpanded = function () {\n                    this.trs.find('.fc-expander .fc-icon')\n                        .removeClass(this.getCollapsedIcon())\n                        .addClass(this.getExpandedIcon());\n                };\n                /*\n                Changes the expander icon to the \"collapsed\" state\n                */\n                RowParent.prototype.indicateCollapsed = function () {\n                    this.trs.find('.fc-expander .fc-icon')\n                        .removeClass(this.getExpandedIcon())\n                        .addClass(this.getCollapsedIcon());\n                };\n                RowParent.prototype.indicateExpandingEnabled = function () {\n                    this.trs.find('.fc-expander-space')\n                        .addClass('fc-expander');\n                    if (this.isExpanded) {\n                        this.indicateExpanded();\n                    }\n                    else {\n                        this.indicateCollapsed();\n                    }\n                };\n                RowParent.prototype.indicateExpandingDisabled = function () {\n                    this.trs.find('.fc-expander-space')\n                        .removeClass('fc-expander')\n                        .find('.fc-icon')\n                        .removeClass(this.getExpandedIcon())\n                        .removeClass(this.getCollapsedIcon());\n                };\n                RowParent.prototype.updateExpandingEnabled = function () {\n                    if (this.hasOwnRow && this.children.length) {\n                        this.indicateExpandingEnabled();\n                    }\n                    else {\n                        this.indicateExpandingDisabled();\n                    }\n                };\n                RowParent.prototype.getExpandedIcon = function () {\n                    return 'fc-icon-down-triangle';\n                };\n                RowParent.prototype.getCollapsedIcon = function () {\n                    var dir = this.view.isRTL ? 'left' : 'right';\n                    return 'fc-icon-' + dir + '-triangle';\n                };\n                /*\n                Causes a slide-down CSS transition to demonstrate that the expand has happened\n                */\n                RowParent.prototype.animateExpand = function () {\n                    var firstChild = this.children[0];\n                    var leadingRow = firstChild && firstChild.getLeadingRow();\n                    var trs = leadingRow && leadingRow.trs;\n                    if (trs) {\n                        trs.addClass('fc-collapsed');\n                        setTimeout(function () {\n                            trs.addClass('fc-transitioning'); // enable transitioning\n                            trs.removeClass('fc-collapsed'); // transition back to non-collapsed state\n                        });\n                        // cross-browser way to determine when the transition finishes\n                        trs.one('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function () {\n                            trs.removeClass('fc-transitioning'); // will remove the overflow:hidden\n                        });\n                    }\n                };\n                // Sizing\n                // ------------------------------------------------------------------------------------------------------------------\n                /*\n                Find each TRs \"inner div\" (div within first cell). This div controls each TRs height.\n                Returns the max pixel height.\n                */\n                RowParent.prototype.getMaxTrInnerHeight = function () {\n                    var max = 0;\n                    $.each(this.trHash, function (type, tr) {\n                        // exclude multi-rowspans (probably done for row grouping)\n                        var innerEl = util_1.getOwnCells(tr).find('> div:not(.fc-cell-content):first');\n                        max = Math.max(innerEl.height(), max);\n                    });\n                    return max;\n                };\n                /*\n                Find each TRs \"inner div\" and sets all of their heights to the same value.\n                */\n                RowParent.prototype.setTrInnerHeight = function (height) {\n                    // exclude multi-rowspans (probably done for row grouping)\n                    $.each(this.trHash, function (type, tr) {\n                        util_1.getOwnCells(tr).find('> div:not(.fc-cell-content):first')\n                            .height(height);\n                    });\n                };\n                // Triggering\n                // ------------------------------------------------------------------------------------------------------------------\n                RowParent.prototype.descendantAdded = function (row) {\n                    if (this.get('isInDom') && this.hasOwnRow && (this.children.length === 1)) {\n                        this.indicateExpandingEnabled();\n                    }\n                    (this.parent || this.view).descendantAdded(row);\n                };\n                RowParent.prototype.descendantRemoved = function (row) {\n                    if (this.get('isInDom') && this.hasOwnRow && (this.children.length === 0)) {\n                        this.indicateExpandingDisabled();\n                    }\n                    (this.parent || this.view).descendantRemoved(row);\n                };\n                RowParent.prototype.thisRowShown = function () {\n                    (this.parent || this.view).descendantShown(this);\n                };\n                RowParent.prototype.thisRowHidden = function () {\n                    (this.parent || this.view).descendantHidden(this);\n                };\n                RowParent.prototype.descendantShown = function (row) {\n                    (this.parent || this.view).descendantShown(row);\n                };\n                RowParent.prototype.descendantHidden = function (row) {\n                    (this.parent || this.view).descendantHidden(row);\n                };\n                return RowParent;\n            }(fullcalendar_1.DateComponent));\n            exports.default = RowParent;\n            RowParent.prototype.hasOwnRow = false;\n            /***/ \n        }),\n        /* 19 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var Resource = /*@__PURE__*/ (function () {\n                function Resource() {\n                }\n                Resource.extractIds = function (rawProps, calendar) {\n                    var resourceField = calendar.opt('eventResourceField') || 'resourceId';\n                    var resourceIds = [];\n                    if (rawProps.resourceIds) {\n                        for (var _i = 0, _a = rawProps.resourceIds; _i < _a.length; _i++) {\n                            var rawResourceId = _a[_i];\n                            resourceIds.push(Resource.normalizeId(rawResourceId));\n                        }\n                    }\n                    if (rawProps[resourceField] != null) {\n                        resourceIds.push(Resource.normalizeId(rawProps[resourceField]));\n                    }\n                    return resourceIds;\n                };\n                Resource.normalizeId = function (rawId) {\n                    return String(rawId);\n                };\n                return Resource;\n            }());\n            exports.default = Resource;\n            /***/ \n        }),\n        /* 20 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceViewMixin_1 = __webpack_require__(9);\n            var ResourceDayGrid_1 = __webpack_require__(13);\n            var ResourceTimeGrid_1 = __webpack_require__(38);\n            var ResourceAgendaView = (function (_super) {\n                tslib_1.__extends(ResourceAgendaView, _super);\n                function ResourceAgendaView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.initResourceView();\n                    return _this;\n                }\n                return ResourceAgendaView;\n            }(fullcalendar_1.AgendaView));\n            exports.default = ResourceAgendaView;\n            ResourceAgendaView.prototype.timeGridClass = ResourceTimeGrid_1.default;\n            ResourceAgendaView.prototype.dayGridClass = ResourceDayGrid_1.default;\n            ResourceViewMixin_1.default.mixInto(ResourceAgendaView);\n            /***/ \n        }),\n        /* 21 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            /*\n            Requirements:\n            - must be a Grid\n            - grid must have a view that's a ResourceView\n            - DayTableMixin must already be mixed in\n            */\n            var ResourceDayTableMixin = (function (_super) {\n                tslib_1.__extends(ResourceDayTableMixin, _super);\n                function ResourceDayTableMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ResourceDayTableMixin.mixInto = function (destClass) {\n                    var _this = this;\n                    fullcalendar_1.Mixin.mixInto.call(this, destClass);\n                    [\n                        'updateDayTableCols',\n                        'computeColCnt',\n                        'getColDayIndex',\n                        'renderHeadTrHtml',\n                        'renderBgCellsHtml',\n                        'renderBusinessHours',\n                        'allowCrossResource'\n                    ].forEach(function (methodName) {\n                        destClass.prototype[methodName] = _this.prototype[methodName];\n                    });\n                };\n                // Resource Data\n                // ----------------------------------------------------------------------------------------------\n                // does not do any rendering. rendering is responsibility of host object\n                ResourceDayTableMixin.prototype.registerResources = function (resources) {\n                    this.flattenedResources = this.flattenResources(resources);\n                    this.resourceCnt = this.flattenedResources.length;\n                    this.updateDayTable(); // will call computeColCnt\n                };\n                // flattens and sorts\n                ResourceDayTableMixin.prototype.flattenResources = function (resources) {\n                    var sortFunc;\n                    var orderVal = this.opt('resourceOrder');\n                    if (orderVal) {\n                        var orderSpecs_1 = fullcalendar_1.parseFieldSpecs(orderVal);\n                        sortFunc = function (a, b) { return fullcalendar_1.compareByFieldSpecs(a, b, orderSpecs_1); };\n                    }\n                    else {\n                        sortFunc = null;\n                    }\n                    var res = [];\n                    this.accumulateResources(resources, sortFunc, res);\n                    return res;\n                };\n                // just flattens\n                ResourceDayTableMixin.prototype.accumulateResources = function (resources, sortFunc, res) {\n                    var sortedResources;\n                    if (sortFunc) {\n                        sortedResources = resources.slice(0); // make copy\n                        sortedResources.sort(sortFunc); // sorts in place\n                    }\n                    else {\n                        sortedResources = resources;\n                    }\n                    for (var _i = 0, sortedResources_1 = sortedResources; _i < sortedResources_1.length; _i++) {\n                        var resource = sortedResources_1[_i];\n                        res.push(resource);\n                        this.accumulateResources(resource.children, sortFunc, res);\n                    }\n                };\n                // Table Layout\n                // ----------------------------------------------------------------------------------------------\n                ResourceDayTableMixin.prototype.updateDayTableCols = function () {\n                    this.datesAboveResources = this.opt('groupByDateAndResource');\n                    fullcalendar_1.DayTableMixin.prototype.updateDayTableCols.call(this);\n                };\n                ResourceDayTableMixin.prototype.computeColCnt = function () {\n                    return this.resourceCnt * this.daysPerRow;\n                };\n                ResourceDayTableMixin.prototype.getColDayIndex = function (col) {\n                    if (this.isRTL) {\n                        col = this.colCnt - 1 - col;\n                    }\n                    if (this.datesAboveResources) {\n                        return Math.floor(col / (this.resourceCnt || 1));\n                    }\n                    else {\n                        return col % this.daysPerRow;\n                    }\n                };\n                ResourceDayTableMixin.prototype.getColResource = function (col) {\n                    return this.flattenedResources[this.getColResourceIndex(col)];\n                };\n                ResourceDayTableMixin.prototype.getColResourceIndex = function (col) {\n                    if (this.isRTL) {\n                        col = this.colCnt - 1 - col;\n                    }\n                    if (this.datesAboveResources) {\n                        return col % (this.resourceCnt || 1);\n                    }\n                    else {\n                        return Math.floor(col / this.daysPerRow);\n                    }\n                };\n                ResourceDayTableMixin.prototype.indicesToCol = function (resourceIndex, dayIndex) {\n                    var col = this.datesAboveResources ?\n                        (dayIndex * (this.resourceCnt || 1)) + resourceIndex :\n                        (resourceIndex * this.daysPerRow) + dayIndex;\n                    if (this.isRTL) {\n                        col = this.colCnt - 1 - col;\n                    }\n                    return col;\n                };\n                // Header Rendering\n                // ----------------------------------------------------------------------------------------------\n                ResourceDayTableMixin.prototype.renderHeadTrHtml = function () {\n                    if (this.daysPerRow > 1) {\n                        // do two levels\n                        if (this.datesAboveResources) {\n                            return this.renderHeadDateAndResourceHtml();\n                        }\n                        else {\n                            return this.renderHeadResourceAndDateHtml();\n                        }\n                    }\n                    else {\n                        // do one level\n                        return this.renderHeadResourceHtml();\n                    }\n                };\n                // renders one row of resources header cell\n                ResourceDayTableMixin.prototype.renderHeadResourceHtml = function () {\n                    var _this = this;\n                    var resourceHtmls = this.flattenedResources.map(function (resource) { return (_this.renderHeadResourceCellHtml(resource)); });\n                    if (!resourceHtmls.length) {\n                        resourceHtmls.push('<td>&nbsp;</td>');\n                    }\n                    return this.wrapTr(resourceHtmls, 'renderHeadIntroHtml');\n                };\n                // renders resource cells above date cells\n                ResourceDayTableMixin.prototype.renderHeadResourceAndDateHtml = function () {\n                    var resourceHtmls = [];\n                    var dateHtmls = [];\n                    var daysPerRow = this.daysPerRow;\n                    for (var _i = 0, _a = this.flattenedResources; _i < _a.length; _i++) {\n                        var resource = _a[_i];\n                        resourceHtmls.push(this.renderHeadResourceCellHtml(resource, null, this.daysPerRow));\n                        for (var dayIndex = 0; dayIndex < daysPerRow; dayIndex++) {\n                            var date = this.dayDates[dayIndex].clone();\n                            dateHtmls.push(this.renderHeadResourceDateCellHtml(date, resource));\n                        }\n                    }\n                    if (!resourceHtmls.length) {\n                        resourceHtmls.push('<td>&nbsp;</td>');\n                    }\n                    if (!dateHtmls.length) {\n                        dateHtmls.push('<td>&nbsp;</td>');\n                    }\n                    return this.wrapTr(resourceHtmls, 'renderHeadIntroHtml') +\n                        this.wrapTr(dateHtmls, 'renderHeadIntroHtml');\n                };\n                // renders date cells above resource cells\n                ResourceDayTableMixin.prototype.renderHeadDateAndResourceHtml = function () {\n                    var dateHtmls = [];\n                    var resourceHtmls = [];\n                    var daysPerRow = this.daysPerRow;\n                    for (var dayIndex = 0; dayIndex < daysPerRow; dayIndex++) {\n                        var date = this.dayDates[dayIndex].clone();\n                        dateHtmls.push(this.renderHeadDateCellHtml(date, this.resourceCnt) // with colspan\n                        );\n                        for (var _i = 0, _a = this.flattenedResources; _i < _a.length; _i++) {\n                            var resource = _a[_i];\n                            resourceHtmls.push(this.renderHeadResourceCellHtml(resource, date));\n                        }\n                    }\n                    if (!dateHtmls.length) {\n                        dateHtmls.push('<td>&nbsp;</td>');\n                    }\n                    if (!resourceHtmls.length) {\n                        resourceHtmls.push('<td>&nbsp;</td>');\n                    }\n                    return this.wrapTr(dateHtmls, 'renderHeadIntroHtml') +\n                        this.wrapTr(resourceHtmls, 'renderHeadIntroHtml');\n                };\n                // given a resource and an optional date\n                ResourceDayTableMixin.prototype.renderHeadResourceCellHtml = function (resource, date, colspan) {\n                    if (colspan === void 0) {\n                        colspan = 1;\n                    }\n                    return '<th class=\"fc-resource-cell\"' +\n                        ' data-resource-id=\"' + resource.id + '\"' +\n                        (date ?\n                            ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\n                            '') +\n                        (colspan > 1 ?\n                            ' colspan=\"' + colspan + '\"' :\n                            '') +\n                        '>' +\n                        fullcalendar_1.htmlEscape(this.view.getResourceText(resource)) +\n                        '</th>';\n                };\n                // given a date and a required resource\n                ResourceDayTableMixin.prototype.renderHeadResourceDateCellHtml = function (date, resource, colspan) {\n                    if (colspan === void 0) {\n                        colspan = 1;\n                    }\n                    return this.renderHeadDateCellHtml(date, colspan, 'data-resource-id=\"' + resource.id + '\"');\n                };\n                // given a container with already rendered resource cells\n                ResourceDayTableMixin.prototype.processHeadResourceEls = function (containerEl) {\n                    var _this = this;\n                    containerEl.find('.fc-resource-cell').each(function (col, node) {\n                        var resource;\n                        if (_this.datesAboveResources) {\n                            // each resource <td> is a distinct column\n                            resource = _this.getColResource(col);\n                        }\n                        else {\n                            // each resource <td> covers multiple columns of dates\n                            resource = _this.flattenedResources[_this.isRTL ?\n                                _this.flattenedResources.length - 1 - col :\n                                col];\n                        }\n                        _this.publiclyTrigger('resourceRender', {\n                            context: resource,\n                            args: [\n                                resource,\n                                $(node),\n                                $(),\n                                _this.view\n                            ]\n                        });\n                    });\n                };\n                // Bg Rendering\n                // ----------------------------------------------------------------------------------------------\n                // TODO: unify with DayTableMixin more, instead of completely redefining\n                ResourceDayTableMixin.prototype.renderBgCellsHtml = function (row) {\n                    var htmls = [];\n                    var colCnt = this.colCnt;\n                    for (var col = 0; col < colCnt; col++) {\n                        var date = this.getCellDate(row, col);\n                        var resource = this.getColResource(col);\n                        htmls.push(this.renderResourceBgCellHtml(date, resource));\n                    }\n                    if (!htmls.length) {\n                        htmls.push('<td>&nbsp;</td>');\n                    }\n                    return htmls.join(''); // already accounted for RTL\n                };\n                ResourceDayTableMixin.prototype.renderResourceBgCellHtml = function (date, resource) {\n                    return this.renderBgCellHtml(date, 'data-resource-id=\"' + resource.id + '\"');\n                };\n                // Rendering Utils\n                // ----------------------------------------------------------------------------------------------\n                // only works for when given cells are ordered chronologically\n                // mutates cellHtmls\n                // TODO: make this a DayTableMixin utility\n                ResourceDayTableMixin.prototype.wrapTr = function (cellHtmls, introMethodName) {\n                    if (this.isRTL) {\n                        cellHtmls.reverse();\n                        return '<tr>' +\n                            cellHtmls.join('') +\n                            this[introMethodName]() +\n                            '</tr>';\n                    }\n                    else {\n                        return '<tr>' +\n                            this[introMethodName]() +\n                            cellHtmls.join('') +\n                            '</tr>';\n                    }\n                };\n                // Business Hours\n                // ----------------------------------------------------------------------------------------------\n                ResourceDayTableMixin.prototype.renderBusinessHours = function (businessHourGenerator) {\n                    var isAllDay = this.hasAllDayBusinessHours;\n                    var unzonedRange = this.dateProfile.activeUnzonedRange;\n                    var eventFootprints = [];\n                    for (var _i = 0, _a = this.flattenedResources; _i < _a.length; _i++) {\n                        var resource = _a[_i];\n                        var eventInstanceGroup = (resource.businessHourGenerator || businessHourGenerator)\n                            .buildEventInstanceGroup(isAllDay, unzonedRange);\n                        if (eventInstanceGroup) {\n                            for (var _b = 0, _c = eventInstanceGroup.sliceRenderRanges(unzonedRange); _b < _c.length; _b++) {\n                                var eventRange = _c[_b];\n                                eventFootprints.push(new fullcalendar_1.EventFootprint(new ResourceComponentFootprint_1.default(eventRange.unzonedRange, isAllDay, resource.id), eventRange.eventDef, eventRange.eventInstance));\n                            }\n                        }\n                    }\n                    return this.businessHourRenderer.renderEventFootprints(eventFootprints);\n                };\n                return ResourceDayTableMixin;\n            }(fullcalendar_1.Mixin));\n            exports.default = ResourceDayTableMixin;\n            ResourceDayTableMixin.prototype.resourceCnt = 0;\n            ResourceDayTableMixin.prototype.datesAboveResources = false;\n            ResourceDayTableMixin.prototype.allowCrossResource = false;\n            /***/ \n        }),\n        /* 22 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceViewMixin_1 = __webpack_require__(9);\n            var ResourceDayGrid_1 = __webpack_require__(13);\n            var ResourceBasicView = (function (_super) {\n                tslib_1.__extends(ResourceBasicView, _super);\n                function ResourceBasicView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.initResourceView();\n                    return _this;\n                }\n                return ResourceBasicView;\n            }(fullcalendar_1.BasicView));\n            exports.default = ResourceBasicView;\n            ResourceBasicView.prototype.dayGridClass = ResourceDayGrid_1.default;\n            ResourceViewMixin_1.default.mixInto(ResourceBasicView);\n            /***/ \n        }),\n        /* 23 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceViewMixin_1 = __webpack_require__(9);\n            var ResourceDayGrid_1 = __webpack_require__(13);\n            var ResourceMonthView = (function (_super) {\n                tslib_1.__extends(ResourceMonthView, _super);\n                function ResourceMonthView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.initResourceView();\n                    return _this;\n                }\n                return ResourceMonthView;\n            }(fullcalendar_1.MonthView));\n            exports.default = ResourceMonthView;\n            ResourceMonthView.prototype.dayGridClass = ResourceDayGrid_1.default;\n            ResourceViewMixin_1.default.mixInto(ResourceMonthView);\n            /***/ \n        }),\n        /* 24 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var EnhancedScroller_1 = __webpack_require__(39);\n            /*\n            A Scroller, but with a wrapping div that allows \"clipping\" away of native scrollbars,\n            giving the appearance that there are no scrollbars.\n            */\n            var ClippedScroller = (function (_super) {\n                tslib_1.__extends(ClippedScroller, _super);\n                /*\n                Received overflows can be set to 'clipped', meaning scrollbars shouldn't be visible\n                to the user, but the area should still scroll.\n                */\n                function ClippedScroller(options) {\n                    var _this = _super.call(this, options) || this;\n                    _this.isHScrollbarsClipped = false;\n                    _this.isVScrollbarsClipped = false;\n                    if (_this.overflowX === 'clipped-scroll') {\n                        _this.overflowX = 'scroll';\n                        _this.isHScrollbarsClipped = true;\n                    }\n                    if (_this.overflowY === 'clipped-scroll') {\n                        _this.overflowY = 'scroll';\n                        _this.isVScrollbarsClipped = true;\n                    }\n                    return _this;\n                }\n                ClippedScroller.prototype.renderEl = function () {\n                    var scrollEl = _super.prototype.renderEl.call(this);\n                    return $('<div class=\"fc-scroller-clip\" />').append(scrollEl); // return value\n                };\n                ClippedScroller.prototype.updateSize = function () {\n                    var scrollEl = this.scrollEl;\n                    var scrollbarWidths = fullcalendar_1.getScrollbarWidths(scrollEl); // the native ones\n                    var cssProps = { marginLeft: 0, marginRight: 0, marginTop: 0, marginBottom: 0 };\n                    // give the inner scrolling div negative margins so that its scrollbars\n                    // are nudged outside of the bounding box of the wrapper, which is overflow:hidden\n                    if (this.isHScrollbarsClipped) {\n                        cssProps.marginTop = -scrollbarWidths.top;\n                        cssProps.marginBottom = -scrollbarWidths.bottom;\n                    }\n                    if (this.isVScrollbarsClipped) {\n                        cssProps.marginLeft = -scrollbarWidths.left;\n                        cssProps.marginRight = -scrollbarWidths.right;\n                    }\n                    scrollEl.css(cssProps);\n                    // if we are attempting to hide the scrollbars offscreen, OSX/iOS will still\n                    // display the floating scrollbars. attach a className to force-hide them.\n                    return scrollEl.toggleClass('fc-no-scrollbars', (this.isHScrollbarsClipped || (this.overflowX === 'hidden')) && // should never show?\n                        (this.isVScrollbarsClipped || (this.overflowY === 'hidden')) && // should never show?\n                        !(scrollbarWidths.top ||\n                            scrollbarWidths.bottom ||\n                            scrollbarWidths.left ||\n                            scrollbarWidths.right));\n                };\n                /*\n                Accounts for 'clipped' scrollbars\n                */\n                ClippedScroller.prototype.getScrollbarWidths = function () {\n                    var widths = fullcalendar_1.getScrollbarWidths(this.scrollEl);\n                    if (this.isHScrollbarsClipped) {\n                        widths.top = 0;\n                        widths.bottom = 0;\n                    }\n                    if (this.isVScrollbarsClipped) {\n                        widths.left = 0;\n                        widths.right = 0;\n                    }\n                    return widths;\n                };\n                return ClippedScroller;\n            }(EnhancedScroller_1.default));\n            exports.default = ClippedScroller;\n            /***/ \n        }),\n        /* 25 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            /*\n            A rectangular area of content that lives within a Scroller.\n            Can have \"gutters\", areas of dead spacing around the perimeter.\n            Also very useful for forcing a width, which a Scroller cannot do alone.\n            Has a content area that lives above a background area.\n            */\n            var ScrollerCanvas = /*@__PURE__*/ (function () {\n                function ScrollerCanvas() {\n                    this.gutters = {};\n                }\n                ScrollerCanvas.prototype.render = function () {\n                    this.el = $(\"<div class=\\\"fc-scroller-canvas\\\"> <div class=\\\"fc-content\\\"></div> <div class=\\\"fc-bg\\\"></div> </div>\");\n                    this.contentEl = this.el.find('.fc-content');\n                    this.bgEl = this.el.find('.fc-bg');\n                };\n                /*\n                If falsy, resets all the gutters to 0\n                */\n                ScrollerCanvas.prototype.setGutters = function (gutters) {\n                    if (!gutters) {\n                        this.gutters = {};\n                    }\n                    else {\n                        $.extend(this.gutters, gutters);\n                    }\n                    this.updateSize();\n                };\n                ScrollerCanvas.prototype.setWidth = function (width) {\n                    this.width = width;\n                    this.updateSize();\n                };\n                ScrollerCanvas.prototype.setMinWidth = function (minWidth) {\n                    this.minWidth = minWidth;\n                    this.updateSize();\n                };\n                ScrollerCanvas.prototype.clearWidth = function () {\n                    this.width = null;\n                    this.minWidth = null;\n                    this.updateSize();\n                };\n                ScrollerCanvas.prototype.updateSize = function () {\n                    var gutters = this.gutters;\n                    this.el // is border-box (width includes padding)\n                        .toggleClass('fc-gutter-left', Boolean(gutters.left))\n                        .toggleClass('fc-gutter-right', Boolean(gutters.right))\n                        .toggleClass('fc-gutter-top', Boolean(gutters.top))\n                        .toggleClass('fc-gutter-bottom', Boolean(gutters.bottom))\n                        .css({\n                        paddingLeft: gutters.left || '',\n                        paddingRight: gutters.right || '',\n                        paddingTop: gutters.top || '',\n                        paddingBottom: gutters.bottom || '',\n                        width: (this.width != null) ?\n                            this.width + (gutters.left || 0) + (gutters.right || 0) :\n                            '',\n                        minWidth: (this.minWidth != null) ?\n                            this.minWidth + (gutters.left || 0) + (gutters.right || 0) :\n                            ''\n                    });\n                    this.bgEl.css({\n                        left: gutters.left || '',\n                        right: gutters.right || '',\n                        top: gutters.top || '',\n                        bottom: gutters.bottom || ''\n                    });\n                };\n                return ScrollerCanvas;\n            }());\n            exports.default = ScrollerCanvas;\n            /***/ \n        }),\n        /* 26 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ScrollFollowerSprite_1 = __webpack_require__(27);\n            var ScrollFollower = /*@__PURE__*/ (function () {\n                function ScrollFollower(scroller, allowPointerEvents) {\n                    if (allowPointerEvents === void 0) {\n                        allowPointerEvents = false;\n                    }\n                    var _this = this;\n                    this.isHFollowing = true;\n                    this.isVFollowing = false;\n                    this.allowPointerEvents = false;\n                    this.containOnNaturalLeft = false;\n                    this.containOnNaturalRight = false;\n                    this.minTravel = 0;\n                    this.allowPointerEvents = allowPointerEvents;\n                    this.scroller = scroller;\n                    this.spritesById = {};\n                    scroller.on('scroll', function () {\n                        if (scroller.isTouchedEver) {\n                            // touch devices should only updated after the scroll is over\n                            _this.isTouch = true;\n                            _this.isForcedRelative = true; // touch devices scroll too quick to make absolute ever look good\n                        }\n                        else {\n                            _this.isTouch = false;\n                            // this.isForcedRelative = false // why?\n                            _this.handleScroll();\n                        }\n                    });\n                    // for touch devices\n                    scroller.on('scrollEnd', function () {\n                        _this.handleScroll();\n                    });\n                }\n                // TODO: have a destroy method.\n                // View's whose skeletons get destroyed should unregister their scrollfollowers.\n                /*\n                `els` is as a jQuery set of elements.\n                If elements are already position:relative, is a performance benefit.\n                */\n                ScrollFollower.prototype.setSpriteEls = function (els) {\n                    var _this = this;\n                    this.clearSprites();\n                    els.each(function (i, node) {\n                        _this.addSprite(new ScrollFollowerSprite_1.default($(node)));\n                    });\n                };\n                ScrollFollower.prototype.clearSprites = function () {\n                    this.iterSprites(function (sprite) { return sprite.clear(); });\n                    this.spritesById = {};\n                };\n                ScrollFollower.prototype.addSprite = function (sprite) {\n                    sprite.follower = this;\n                    this.spritesById[sprite.id] = sprite;\n                };\n                ScrollFollower.prototype.removeSprite = function (sprite) {\n                    sprite.clear();\n                    delete this.spritesById[sprite.id];\n                };\n                ScrollFollower.prototype.handleScroll = function () {\n                    this.updateViewport();\n                    this.updatePositions();\n                };\n                ScrollFollower.prototype.cacheDimensions = function () {\n                    this.updateViewport();\n                    this.scrollbarWidths = this.scroller.getScrollbarWidths();\n                    this.contentOffset = this.scroller.canvas.el.offset();\n                    this.iterSprites(function (sprite) { return sprite.cacheDimensions(); });\n                };\n                ScrollFollower.prototype.updateViewport = function () {\n                    var scroller = this.scroller;\n                    var left = scroller.getScrollFromLeft();\n                    var top = scroller.getScrollTop();\n                    // TODO: use getViewportRect() for getting this rect\n                    return this.viewportRect = {\n                        left: left,\n                        right: left + scroller.getClientWidth(),\n                        top: top,\n                        bottom: top + scroller.getClientHeight()\n                    };\n                };\n                ScrollFollower.prototype.forceRelative = function () {\n                    if (!this.isForcedRelative) {\n                        this.isForcedRelative = true;\n                        this.iterSprites(function (sprite) {\n                            if (sprite.doAbsolute) {\n                                return sprite.assignPosition();\n                            }\n                        });\n                    }\n                };\n                ScrollFollower.prototype.clearForce = function () {\n                    if (this.isForcedRelative && !this.isTouch) {\n                        this.isForcedRelative = false;\n                        this.iterSprites(function (sprite) { return sprite.assignPosition(); });\n                    }\n                };\n                ScrollFollower.prototype.update = function () {\n                    this.cacheDimensions();\n                    this.updatePositions();\n                };\n                ScrollFollower.prototype.updatePositions = function () {\n                    this.iterSprites(function (sprite) { return sprite.updatePosition(); });\n                };\n                // relative to inner content pane\n                ScrollFollower.prototype.getContentRect = function (el) {\n                    return fullcalendar_1.getContentRect(el, this.contentOffset);\n                };\n                // relative to inner content pane\n                ScrollFollower.prototype.getBoundingRect = function (el) {\n                    return fullcalendar_1.getOuterRect(el, this.contentOffset);\n                };\n                ScrollFollower.prototype.iterSprites = function (func) {\n                    for (var id in this.spritesById) {\n                        var sprite = this.spritesById[id];\n                        func(sprite, id);\n                    }\n                };\n                return ScrollFollower;\n            }());\n            exports.default = ScrollFollower;\n            /***/ \n        }),\n        /* 27 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ScrollFollowerSprite = /*@__PURE__*/ (function () {\n                /*\n                If given el is already position:relative, is a performance gain\n                */\n                function ScrollFollowerSprite(el) {\n                    this.isEnabled = true;\n                    this.isHFollowing = false;\n                    this.isVFollowing = false;\n                    this.doAbsolute = false;\n                    this.isAbsolute = false;\n                    this.isCentered = false;\n                    this.isBlock = false;\n                    this.el = el;\n                    this.id = String(ScrollFollowerSprite.uid++);\n                    this.isBlock = this.el.css('display') === 'block';\n                    if (this.el.css('position') !== 'relative') {\n                        this.el.css('position', 'relative');\n                    }\n                }\n                ScrollFollowerSprite.prototype.disable = function () {\n                    if (this.isEnabled) {\n                        this.isEnabled = false;\n                        this.resetPosition();\n                        this.unabsolutize();\n                    }\n                };\n                ScrollFollowerSprite.prototype.enable = function () {\n                    if (!this.isEnabled) {\n                        this.isEnabled = true;\n                        this.assignPosition();\n                    }\n                };\n                ScrollFollowerSprite.prototype.clear = function () {\n                    this.disable();\n                    this.follower = null;\n                    this.absoluteEl = null;\n                };\n                ScrollFollowerSprite.prototype.cacheDimensions = function () {\n                    var isHFollowing = false;\n                    var isVFollowing = false;\n                    var isCentered = false;\n                    this.naturalWidth = this.el.width();\n                    this.resetPosition();\n                    var follower = this.follower;\n                    var naturalRect = (this.naturalRect = follower.getBoundingRect(this.el));\n                    var parentEl = this.el.parent();\n                    this.parentRect = follower.getBoundingRect(parentEl);\n                    var containerRect = (this.containerRect = joinRects(follower.getContentRect(parentEl), naturalRect));\n                    var minTravel = follower.minTravel;\n                    if (follower.containOnNaturalLeft) {\n                        containerRect.left = naturalRect.left;\n                    }\n                    if (follower.containOnNaturalRight) {\n                        containerRect.right = naturalRect.right;\n                    }\n                    if (follower.isHFollowing) {\n                        if ((getRectWidth(containerRect) - getRectWidth(naturalRect)) >= minTravel) {\n                            isCentered = this.el.css('text-align') === 'center';\n                            isHFollowing = true;\n                        }\n                    }\n                    if (follower.isVFollowing) {\n                        if ((getRectHeight(containerRect) - getRectHeight(naturalRect)) >= minTravel) {\n                            isVFollowing = true;\n                        }\n                    }\n                    this.isHFollowing = isHFollowing;\n                    this.isVFollowing = isVFollowing;\n                    this.isCentered = isCentered;\n                };\n                ScrollFollowerSprite.prototype.updatePosition = function () {\n                    this.computePosition();\n                    this.assignPosition();\n                };\n                ScrollFollowerSprite.prototype.resetPosition = function () {\n                    this.el.css({\n                        top: '',\n                        left: ''\n                    });\n                };\n                ScrollFollowerSprite.prototype.computePosition = function () {\n                    var viewportRect = this.follower.viewportRect;\n                    var parentRect = this.parentRect;\n                    var containerRect = this.containerRect;\n                    var visibleParentRect = fullcalendar_1.intersectRects(viewportRect, parentRect);\n                    var rect = null;\n                    var doAbsolute = false;\n                    if (visibleParentRect) {\n                        rect = copyRect(this.naturalRect);\n                        var subjectRect = fullcalendar_1.intersectRects(rect, parentRect);\n                        // will we need to reposition?\n                        if ((this.isCentered && !testRectContains(viewportRect, parentRect)) || // centering and container not completely in view?\n                            (subjectRect && !testRectContains(viewportRect, subjectRect))) {\n                            doAbsolute = true;\n                            if (this.isHFollowing) {\n                                if (this.isCentered) {\n                                    var rectWidth = getRectWidth(rect);\n                                    rect.left = ((visibleParentRect.left + visibleParentRect.right) / 2) - (rectWidth / 2);\n                                    rect.right = rect.left + rectWidth;\n                                }\n                                else {\n                                    if (!hContainRect(rect, viewportRect)) {\n                                        doAbsolute = false;\n                                    }\n                                }\n                                if (hContainRect(rect, containerRect)) {\n                                    doAbsolute = false;\n                                }\n                            }\n                            if (this.isVFollowing) {\n                                if (!vContainRect(rect, viewportRect)) {\n                                    doAbsolute = false;\n                                }\n                                if (vContainRect(rect, containerRect)) {\n                                    doAbsolute = false;\n                                }\n                            }\n                            if (!testRectContains(viewportRect, rect)) {\n                                doAbsolute = false;\n                            }\n                        }\n                    }\n                    this.rect = rect;\n                    this.doAbsolute = doAbsolute;\n                };\n                ScrollFollowerSprite.prototype.assignPosition = function () {\n                    if (this.isEnabled) {\n                        if (!this.rect) {\n                            this.unabsolutize();\n                        }\n                        else if (this.doAbsolute && !this.follower.isForcedRelative) {\n                            this.absolutize();\n                            this.absoluteEl.css({\n                                top: (this.rect.top - this.follower.viewportRect.top) + this.follower.scrollbarWidths.top,\n                                left: (this.rect.left - this.follower.viewportRect.left) + this.follower.scrollbarWidths.left,\n                                width: this.isBlock ? this.naturalWidth : ''\n                            });\n                        }\n                        else {\n                            var top_1 = this.rect.top - this.naturalRect.top;\n                            var left = this.rect.left - this.naturalRect.left;\n                            this.unabsolutize();\n                            this.el.toggleClass('fc-following', Boolean(top_1 || left))\n                                .css({\n                                top: top_1,\n                                left: left\n                            });\n                        }\n                    }\n                };\n                ScrollFollowerSprite.prototype.absolutize = function () {\n                    if (!this.isAbsolute) {\n                        if (!this.absoluteEl) {\n                            this.absoluteEl = this.buildAbsoluteEl();\n                        }\n                        this.absoluteEl.appendTo(this.follower.scroller.el);\n                        this.el.css('visibility', 'hidden');\n                        this.isAbsolute = true;\n                    }\n                };\n                ScrollFollowerSprite.prototype.unabsolutize = function () {\n                    if (this.isAbsolute) {\n                        this.absoluteEl.detach();\n                        this.el.css('visibility', '');\n                        this.isAbsolute = false;\n                    }\n                };\n                ScrollFollowerSprite.prototype.buildAbsoluteEl = function () {\n                    var el = this.el.clone().addClass('fc-following');\n                    el.css({\n                        'position': 'absolute',\n                        'z-index': 1000,\n                        'font-weight': this.el.css('font-weight'),\n                        'font-size': this.el.css('font-size'),\n                        'font-family': this.el.css('font-family'),\n                        'text-decoration': this.el.css('text-decoration'),\n                        'color': this.el.css('color'),\n                        'padding-top': this.el.css('padding-top'),\n                        'padding-bottom': this.el.css('padding-bottom'),\n                        'padding-left': this.el.css('padding-left'),\n                        'padding-right': this.el.css('padding-right')\n                    });\n                    if (!this.follower.allowPointerEvents) {\n                        el.css('pointer-events', 'none');\n                    }\n                    return el;\n                };\n                ScrollFollowerSprite.uid = 0;\n                return ScrollFollowerSprite;\n            }());\n            exports.default = ScrollFollowerSprite;\n            // Geometry Utils\n            // ----------------------------------------------------------------------------------------------------------------------\n            // TODO: move somewhere more common\n            function copyRect(rect) {\n                return {\n                    left: rect.left,\n                    right: rect.right,\n                    top: rect.top,\n                    bottom: rect.bottom\n                };\n            }\n            function getRectWidth(rect) {\n                return rect.right - rect.left;\n            }\n            function getRectHeight(rect) {\n                return rect.bottom - rect.top;\n            }\n            function testRectContains(rect, innerRect) {\n                return testRectHContains(rect, innerRect) && testRectVContains(rect, innerRect);\n            }\n            function testRectHContains(rect, innerRect) {\n                return (innerRect.left >= rect.left) && (innerRect.right <= rect.right);\n            }\n            function testRectVContains(rect, innerRect) {\n                return (innerRect.top >= rect.top) && (innerRect.bottom <= rect.bottom);\n            }\n            function hContainRect(rect, outerRect) {\n                if (rect.left < outerRect.left) {\n                    rect.right = outerRect.left + getRectWidth(rect);\n                    rect.left = outerRect.left;\n                    return true;\n                }\n                else if (rect.right > outerRect.right) {\n                    rect.left = outerRect.right - getRectWidth(rect);\n                    rect.right = outerRect.right;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            function vContainRect(rect, outerRect) {\n                if (rect.top < outerRect.top) {\n                    rect.bottom = outerRect.top + getRectHeight(rect);\n                    rect.top = outerRect.top;\n                    return true;\n                }\n                else if (rect.bottom > outerRect.bottom) {\n                    rect.top = outerRect.bottom - getRectHeight(rect);\n                    rect.bottom = outerRect.bottom;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            function joinRects(rect1, rect2) {\n                return {\n                    left: Math.min(rect1.left, rect2.left),\n                    right: Math.max(rect1.right, rect2.right),\n                    top: Math.min(rect1.top, rect2.top),\n                    bottom: Math.max(rect1.bottom, rect2.bottom)\n                };\n            }\n            /***/ \n        }),\n        /* 28 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var TimelineFillRenderer = (function (_super) {\n                tslib_1.__extends(TimelineFillRenderer, _super);\n                function TimelineFillRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                component must be { bgSegContainerEl, rangeToCoords }\n                */\n                TimelineFillRenderer.prototype.attachSegEls = function (type, segs) {\n                    if (segs.length) {\n                        var className = void 0;\n                        if (type === 'businessHours') {\n                            className = 'bgevent';\n                        }\n                        else {\n                            className = type.toLowerCase();\n                        }\n                        // making a new container each time is OKAY\n                        // all types of segs (background or business hours or whatever) are rendered in one pass\n                        var containerEl = $('<div class=\"fc-' + className + '-container\" />')\n                            .appendTo(this.component.bgSegContainerEl);\n                        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                            var seg = segs_1[_i];\n                            var coords = this.component.rangeToCoords(seg); // TODO: make DRY\n                            seg.el.css({\n                                left: (seg.left = coords.left),\n                                right: -(seg.right = coords.right)\n                            });\n                            seg.el.appendTo(containerEl);\n                        }\n                        return containerEl; // return value\n                    }\n                };\n                return TimelineFillRenderer;\n            }(fullcalendar_1.FillRenderer));\n            exports.default = TimelineFillRenderer;\n            /***/ \n        }),\n        /* 29 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var TimelineHelperRenderer = (function (_super) {\n                tslib_1.__extends(TimelineHelperRenderer, _super);\n                function TimelineHelperRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                component must be { innerEl, rangeToCoords, ?resource }\n                */\n                TimelineHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\n                    var helperNodes = []; // .fc-event-container\n                    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                        var seg = segs_1[_i];\n                        // TODO: centralize logic (also in renderFgSegsInContainers)\n                        var coords = this.component.rangeToCoords(seg);\n                        seg.el.css({\n                            left: (seg.left = coords.left),\n                            right: -(seg.right = coords.right)\n                        });\n                        // TODO: detangle the concept of resources\n                        // TODO: how to identify these two segs as the same!?\n                        if (sourceSeg && (sourceSeg.resourceId === (this.component.resource != null ? this.component.resource.id : undefined))) {\n                            seg.el.css('top', sourceSeg.el.css('top'));\n                        }\n                        else {\n                            seg.el.css('top', 0);\n                        }\n                    }\n                    var helperContainerEl = $('<div class=\"fc-event-container fc-helper-container\"/>')\n                        .appendTo(this.component.innerEl);\n                    helperNodes.push(helperContainerEl[0]);\n                    for (var _a = 0, segs_2 = segs; _a < segs_2.length; _a++) {\n                        var seg = segs_2[_a];\n                        helperContainerEl.append(seg.el);\n                    }\n                    return $(helperNodes); // return value. TODO: need to accumulate across calls?\n                };\n                return TimelineHelperRenderer;\n            }(fullcalendar_1.HelperRenderer));\n            exports.default = TimelineHelperRenderer;\n            /***/ \n        }),\n        /* 30 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ScrollJoiner_1 = __webpack_require__(16);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            var ResourceViewMixin_1 = __webpack_require__(9);\n            var TimelineView_1 = __webpack_require__(14);\n            var Spreadsheet_1 = __webpack_require__(43);\n            var ResourceTimelineEventRenderer_1 = __webpack_require__(45);\n            var RowParent_1 = __webpack_require__(18);\n            var ResourceRow_1 = __webpack_require__(46);\n            var HRowGroup_1 = __webpack_require__(47);\n            var VRowGroup_1 = __webpack_require__(31);\n            var EventRow_1 = __webpack_require__(33);\n            var ResourceTimelineView = (function (_super) {\n                tslib_1.__extends(ResourceTimelineView, _super);\n                function ResourceTimelineView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.canHandleSpecificResources = true;\n                    _this.isResourceFootprintsEnabled = true;\n                    _this.nestingCnt = 0;\n                    _this.indiBizCnt = 0;\n                    _this.isIndiBizRendered = false;\n                    _this.isGenericBizRendered = false;\n                    _this.initResourceView();\n                    _this.processResourceOptions();\n                    _this.spreadsheet = new Spreadsheet_1.default(_this);\n                    _this.rowHierarchy = new RowParent_1.default(_this);\n                    _this.rowHierarchy.isExpanded = true; // hack to always show, regardless of resourcesInitiallyExpanded\n                    _this.resourceRowHash = {};\n                    return _this;\n                }\n                // Resource Options\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.processResourceOptions = function () {\n                    var allColSpecs = this.opt('resourceColumns') || [];\n                    var labelText = this.opt('resourceLabelText'); // TODO: view.override\n                    var defaultLabelText = 'Resources'; // TODO: view.defaults\n                    var superHeaderText = null;\n                    if (!allColSpecs.length) {\n                        allColSpecs.push({\n                            labelText: labelText || defaultLabelText,\n                            text: this.getResourceTextFunc()\n                        });\n                    }\n                    else {\n                        superHeaderText = labelText;\n                    }\n                    var plainColSpecs = [];\n                    var groupColSpecs = [];\n                    var groupSpecs = [];\n                    var isVGrouping = false;\n                    var isHGrouping = false;\n                    for (var _i = 0, allColSpecs_1 = allColSpecs; _i < allColSpecs_1.length; _i++) {\n                        var colSpec = allColSpecs_1[_i];\n                        if (colSpec.group) {\n                            groupColSpecs.push(colSpec);\n                        }\n                        else {\n                            plainColSpecs.push(colSpec);\n                        }\n                    }\n                    plainColSpecs[0].isMain = true;\n                    if (groupColSpecs.length) {\n                        groupSpecs = groupColSpecs;\n                        isVGrouping = true;\n                    }\n                    else {\n                        var hGroupField = this.opt('resourceGroupField');\n                        if (hGroupField) {\n                            isHGrouping = true;\n                            groupSpecs.push({\n                                field: hGroupField,\n                                text: this.opt('resourceGroupText'),\n                                render: this.opt('resourceGroupRender')\n                            });\n                        }\n                    }\n                    var allOrderSpecs = fullcalendar_1.parseFieldSpecs(this.opt('resourceOrder'));\n                    var plainOrderSpecs = [];\n                    for (var _a = 0, allOrderSpecs_1 = allOrderSpecs; _a < allOrderSpecs_1.length; _a++) {\n                        var orderSpec = allOrderSpecs_1[_a];\n                        var isGroup = false;\n                        for (var _b = 0, groupSpecs_1 = groupSpecs; _b < groupSpecs_1.length; _b++) {\n                            var groupSpec = groupSpecs_1[_b];\n                            if (groupSpec.field === orderSpec.field) {\n                                groupSpec.order = orderSpec.order; // -1, 0, 1\n                                isGroup = true;\n                                break;\n                            }\n                        }\n                        if (!isGroup) {\n                            plainOrderSpecs.push(orderSpec);\n                        }\n                    }\n                    this.superHeaderText = superHeaderText;\n                    this.isVGrouping = isVGrouping;\n                    this.isHGrouping = isHGrouping;\n                    this.groupSpecs = groupSpecs;\n                    this.colSpecs = groupColSpecs.concat(plainColSpecs);\n                    this.orderSpecs = plainOrderSpecs;\n                };\n                // Skeleton Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderSkeleton = function () {\n                    _super.prototype.renderSkeleton.call(this);\n                    var theme = this.calendar.theme;\n                    this.spreadsheet.el = this.el.find('tbody .fc-resource-area');\n                    this.spreadsheet.headEl = this.el.find('thead .fc-resource-area');\n                    this.spreadsheet.renderSkeleton();\n                    // ^ is not a Grid/DateComponent\n                    // only non-resource grid needs this, so kill it\n                    // TODO: look into better solution\n                    this.segContainerEl.remove();\n                    this.segContainerEl = null;\n                    var timeBodyContainerEl = $(\"<div class=\\\"fc-rows\\\"> <table class=\\\"\" + theme.getClass('tableGrid') + \"\\\"> <tbody/> </table> </div>\").appendTo(this.timeBodyScroller.canvas.contentEl);\n                    this.timeBodyTbodyEl = timeBodyContainerEl.find('tbody');\n                    this.tbodyHash = {\n                        spreadsheet: this.spreadsheet.tbodyEl,\n                        event: this.timeBodyTbodyEl\n                    };\n                    this.resourceScrollJoiner = new ScrollJoiner_1.default('vertical', [\n                        this.spreadsheet.bodyScroller,\n                        this.timeBodyScroller\n                    ]);\n                    this.initDividerMoving();\n                };\n                ResourceTimelineView.prototype.renderSkeletonHtml = function () {\n                    var theme = this.calendar.theme;\n                    return \"<table class=\\\"\" + theme.getClass('tableGrid') + \"\\\"> <thead class=\\\"fc-head\\\"> <tr> <td class=\\\"fc-resource-area \" + theme.getClass('widgetHeader') + \"\\\"></td> <td class=\\\"fc-divider fc-col-resizer \" + theme.getClass('widgetHeader') + \"\\\"></td> <td class=\\\"fc-time-area \" + theme.getClass('widgetHeader') + \"\\\"></td> </tr> </thead> <tbody class=\\\"fc-body\\\"> <tr> <td class=\\\"fc-resource-area \" + theme.getClass('widgetContent') + \"\\\"></td> <td class=\\\"fc-divider fc-col-resizer \" + theme.getClass('widgetHeader') + \"\\\"></td> <td class=\\\"fc-time-area \" + theme.getClass('widgetContent') + \"\\\"></td> </tr> </tbody> </table>\";\n                };\n                // Divider Moving\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.initDividerMoving = function () {\n                    var _this = this;\n                    var left = this.opt('resourceAreaWidth');\n                    this.dividerEls = this.el.find('.fc-divider');\n                    // tableWidth available after spreadsheet.renderSkeleton\n                    this.dividerWidth = left != null ? left : this.spreadsheet.tableWidth;\n                    if (this.dividerWidth != null) {\n                        this.positionDivider(this.dividerWidth);\n                    }\n                    this.dividerEls.on('mousedown', function (ev) {\n                        _this.dividerMousedown(ev);\n                    });\n                };\n                ResourceTimelineView.prototype.dividerMousedown = function (ev) {\n                    var _this = this;\n                    var isRTL = this.opt('isRTL');\n                    var minWidth = 30;\n                    var maxWidth = this.el.width() - 30;\n                    var origWidth = this.getNaturalDividerWidth();\n                    var dragListener = new fullcalendar_1.DragListener({\n                        dragStart: function () {\n                            _this.dividerEls.addClass('fc-active');\n                        },\n                        drag: function (dx, dy) {\n                            var width;\n                            if (isRTL) {\n                                width = origWidth - dx;\n                            }\n                            else {\n                                width = origWidth + dx;\n                            }\n                            width = Math.max(width, minWidth);\n                            width = Math.min(width, maxWidth);\n                            _this.dividerWidth = width;\n                            _this.positionDivider(width);\n                            _this.calendar.updateViewSize();\n                        },\n                        dragEnd: function () {\n                            _this.dividerEls.removeClass('fc-active');\n                        }\n                    });\n                    dragListener.startInteraction(ev);\n                };\n                ResourceTimelineView.prototype.getNaturalDividerWidth = function () {\n                    return this.el.find('.fc-resource-area').width(); // TODO: don't we have this cached?\n                };\n                ResourceTimelineView.prototype.positionDivider = function (w) {\n                    this.el.find('.fc-resource-area').css('width', w); // TODO: don't we have this cached?\n                };\n                // Sizing\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    var bodyHeight;\n                    if (this.rowsNeedingHeightSync) {\n                        this.syncRowHeights(this.rowsNeedingHeightSync);\n                        this.rowsNeedingHeightSync = null;\n                    }\n                    else {\n                        this.syncRowHeights(); // sync all\n                    }\n                    var headHeight = this.syncHeadHeights();\n                    if (isAuto) {\n                        bodyHeight = 'auto';\n                    }\n                    else {\n                        bodyHeight = totalHeight - headHeight - this.queryMiscHeight();\n                    }\n                    this.timeBodyScroller.setHeight(bodyHeight);\n                    this.spreadsheet.bodyScroller.setHeight(bodyHeight);\n                    this.spreadsheet.updateSize();\n                    // do children AFTER because of ScrollFollowerSprite abs position issues\n                    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    // do once spreadsheet area and event slat area have correct height, for gutters\n                    this.resourceScrollJoiner.update();\n                };\n                ResourceTimelineView.prototype.queryMiscHeight = function () {\n                    return this.el.outerHeight() -\n                        Math.max(this.spreadsheet.headScroller.el.outerHeight(), this.timeHeadScroller.el.outerHeight()) -\n                        Math.max(this.spreadsheet.bodyScroller.el.outerHeight(), this.timeBodyScroller.el.outerHeight());\n                };\n                ResourceTimelineView.prototype.syncHeadHeights = function () {\n                    this.spreadsheet.headHeight('auto');\n                    this.headHeight('auto');\n                    var headHeight = Math.max(this.spreadsheet.headHeight(), this.headHeight());\n                    this.spreadsheet.headHeight(headHeight);\n                    this.headHeight(headHeight);\n                    return headHeight;\n                };\n                // Scrolling\n                // ------------------------------------------------------------------------------------------------------------------\n                // this is useful for scrolling prev/next dates while resource is scrolled down\n                ResourceTimelineView.prototype.queryResourceScroll = function () {\n                    var scroll = {};\n                    var scrollerTop = this.timeBodyScroller.scrollEl.offset().top; // TODO: use getClientRect\n                    for (var _i = 0, _a = this.getVisibleRows(); _i < _a.length; _i++) {\n                        var rowObj = _a[_i];\n                        if (rowObj.resource) {\n                            var el = rowObj.getTr('event');\n                            var elBottom = el.offset().top + el.outerHeight();\n                            if (elBottom > scrollerTop) {\n                                scroll.resourceId = rowObj.resource.id;\n                                scroll.bottom = elBottom - scrollerTop;\n                                break;\n                            }\n                        }\n                    }\n                    // TODO: what about left scroll state for spreadsheet area?\n                    return scroll;\n                };\n                ResourceTimelineView.prototype.applyResourceScroll = function (scroll) {\n                    if (scroll.resourceId) {\n                        var row = this.getResourceRow(scroll.resourceId);\n                        if (row) {\n                            var el = row.getTr('event');\n                            if (el) {\n                                var innerTop = this.timeBodyScroller.canvas.el.offset().top; // TODO: use -scrollHeight or something\n                                var elBottom = el.offset().top + el.outerHeight();\n                                var scrollTop = elBottom - scroll.bottom - innerTop;\n                                this.timeBodyScroller.setScrollTop(scrollTop);\n                                this.spreadsheet.bodyScroller.setScrollTop(scrollTop);\n                            }\n                        }\n                    }\n                };\n                ResourceTimelineView.prototype.scrollToResource = function (resource) {\n                    var row = this.getResourceRow(resource.id);\n                    if (row) {\n                        var el = row.getTr('event');\n                        if (el) {\n                            var innerTop = this.timeBodyScroller.canvas.el.offset().top; // TODO: use -scrollHeight or something\n                            var scrollTop = el.offset().top - innerTop;\n                            this.timeBodyScroller.setScrollTop(scrollTop);\n                            this.spreadsheet.bodyScroller.setScrollTop(scrollTop);\n                        }\n                    }\n                };\n                // Hit System\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.prepareHits = function () {\n                    var shownEventRows = [];\n                    _super.prototype.prepareHits.call(this);\n                    this.eventRows = this.getEventRows();\n                    this.eventRows.forEach(function (row) {\n                        if (row.get('isInDom')) {\n                            shownEventRows.push(row);\n                        }\n                    });\n                    var trArray = shownEventRows.map(function (row) { return (row.getTr('event')[0]); });\n                    this.shownEventRows = shownEventRows;\n                    this.rowCoordCache = new fullcalendar_1.CoordCache({\n                        els: trArray,\n                        isVertical: true\n                    });\n                    this.rowCoordCache.build();\n                };\n                ResourceTimelineView.prototype.releaseHits = function () {\n                    _super.prototype.releaseHits.call(this);\n                    this.eventRows = null;\n                    this.shownEventRows = null;\n                    this.rowCoordCache.clear();\n                };\n                ResourceTimelineView.prototype.queryHit = function (leftOffset, topOffset) {\n                    var simpleHit = _super.prototype.queryHit.call(this, leftOffset, topOffset);\n                    if (simpleHit) {\n                        var rowIndex = this.rowCoordCache.getVerticalIndex(topOffset);\n                        if (rowIndex != null) {\n                            return {\n                                resourceId: this.shownEventRows[rowIndex].resource.id,\n                                snap: simpleHit.snap,\n                                component: this,\n                                left: simpleHit.left,\n                                right: simpleHit.right,\n                                top: this.rowCoordCache.getTopOffset(rowIndex),\n                                bottom: this.rowCoordCache.getBottomOffset(rowIndex)\n                            };\n                        }\n                    }\n                };\n                ResourceTimelineView.prototype.getHitFootprint = function (hit) {\n                    var componentFootprint = _super.prototype.getHitFootprint.call(this, hit);\n                    return new ResourceComponentFootprint_1.default(componentFootprint.unzonedRange, componentFootprint.isAllDay, hit.resourceId);\n                };\n                ResourceTimelineView.prototype.getHitEl = function (hit) {\n                    return this.getSnapEl(hit.snap);\n                };\n                // Resource Data\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderResources = function (resources) {\n                    for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {\n                        var resource = resources_1[_i];\n                        this.renderResource(resource);\n                    }\n                };\n                ResourceTimelineView.prototype.unrenderResources = function () {\n                    this.rowHierarchy.removeElement();\n                    this.rowHierarchy.removeChildren();\n                    for (var id in this.resourceRowHash) {\n                        this.removeChild(this.resourceRowHash[id]); // for DateComponent!\n                    }\n                    this.resourceRowHash = {};\n                };\n                ResourceTimelineView.prototype.renderResource = function (resource) {\n                    this.insertResource(resource);\n                };\n                ResourceTimelineView.prototype.unrenderResource = function (resource) {\n                    this.removeResource(resource);\n                };\n                // Event Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.executeEventRender = function (eventsPayload) {\n                    var payloadsByResourceId = {};\n                    var genericPayload = {};\n                    var resourceId;\n                    for (var eventDefId in eventsPayload) {\n                        var eventInstanceGroup = eventsPayload[eventDefId];\n                        var eventDef = eventInstanceGroup.getEventDef();\n                        var resourceIds = eventDef.getResourceIds();\n                        if (resourceIds.length) {\n                            for (var _i = 0, resourceIds_1 = resourceIds; _i < resourceIds_1.length; _i++) {\n                                resourceId = resourceIds_1[_i];\n                                var bucket = payloadsByResourceId[resourceId] || (payloadsByResourceId[resourceId] = {});\n                                bucket[eventDefId] = eventInstanceGroup;\n                            }\n                            // only render bg segs that have no resources\n                        }\n                        else if (eventDef.hasBgRendering()) {\n                            genericPayload[eventDefId] = eventInstanceGroup;\n                        }\n                    }\n                    this.eventRenderer.render(genericPayload);\n                    for (resourceId in payloadsByResourceId) {\n                        var resourceEventsPayload = payloadsByResourceId[resourceId];\n                        var row = this.getResourceRow(resourceId);\n                        if (row) {\n                            row.executeEventRender(resourceEventsPayload);\n                        }\n                    }\n                };\n                // Business Hours Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderBusinessHours = function (businessHourGenerator) {\n                    this.genericBiz = businessHourGenerator; // save for later\n                    this.isIndiBizRendered = false;\n                    this.isGenericBizRendered = false;\n                    if (this.indiBizCnt) {\n                        this.isIndiBizRendered = true;\n                        for (var _i = 0, _a = this.getEventRows(); _i < _a.length; _i++) {\n                            var row = _a[_i];\n                            row.renderBusinessHours(row.resource.businessHourGenerator ||\n                                businessHourGenerator);\n                        }\n                    }\n                    else {\n                        this.isGenericBizRendered = true;\n                        this.businessHourRenderer.render(businessHourGenerator);\n                    }\n                };\n                ResourceTimelineView.prototype.updateIndiBiz = function () {\n                    if ((this.indiBizCnt && this.isGenericBizRendered) ||\n                        (!this.indiBizCnt && this.isIndiBizRendered)) {\n                        this.unrenderBusinessHours();\n                        this.renderBusinessHours(this.genericBiz);\n                    }\n                };\n                // Row Management\n                // ------------------------------------------------------------------------------------------------------------------\n                // creates a row for the given resource and inserts it into the hierarchy.\n                // if `parentResourceRow` is given, inserts it as a direct child\n                // does not render\n                ResourceTimelineView.prototype.insertResource = function (resource, parentResourceRow) {\n                    var noExplicitParent = !parentResourceRow;\n                    var row = new ResourceRow_1.default(this, resource);\n                    if (!parentResourceRow) {\n                        if (resource.parent) {\n                            parentResourceRow = this.getResourceRow(resource.parent.id);\n                        }\n                        else if (resource.parentId) {\n                            parentResourceRow = this.getResourceRow(resource.parentId);\n                        }\n                    }\n                    if (parentResourceRow) {\n                        this.insertRowAsChild(row, parentResourceRow);\n                    }\n                    else {\n                        this.insertRow(row);\n                    }\n                    this.addChild(row); // for DateComponent!\n                    this.resourceRowHash[resource.id] = row;\n                    if (resource.businessHourGenerator) {\n                        this.indiBizCnt++;\n                        // hack to get dynamically-added resources with custom business hours to render\n                        if (this.isIndiBizRendered) {\n                            row.businessHourGenerator = resource.businessHourGenerator;\n                        }\n                        this.updateIndiBiz();\n                    }\n                    for (var _i = 0, _a = resource.children; _i < _a.length; _i++) {\n                        var childResource = _a[_i];\n                        this.insertResource(childResource, row);\n                    }\n                    if (noExplicitParent && computeIsChildrenVisible(row.parent)) {\n                        row.renderSkeleton();\n                    }\n                    return row;\n                };\n                // does not unrender\n                ResourceTimelineView.prototype.removeResource = function (resource) {\n                    var row = this.resourceRowHash[resource.id];\n                    if (row) {\n                        delete this.resourceRowHash[resource.id];\n                        this.removeChild(row); // for DateComponent!\n                        row.removeFromParentAndDom();\n                        if (resource.businessHourGenerator) {\n                            this.indiBizCnt--;\n                            this.updateIndiBiz();\n                        }\n                    }\n                    return row;\n                };\n                // inserts the given row into the hierarchy.\n                // `parent` can be any tree root of the hierarchy.\n                // `orderSpecs` will recursively create groups within the root before inserting the row.\n                ResourceTimelineView.prototype.insertRow = function (row, parent, groupSpecs) {\n                    if (parent === void 0) {\n                        parent = this.rowHierarchy;\n                    }\n                    if (groupSpecs === void 0) {\n                        groupSpecs = this.groupSpecs;\n                    }\n                    if (groupSpecs.length) {\n                        var group = this.ensureResourceGroup(row, parent, groupSpecs[0]);\n                        if (group instanceof HRowGroup_1.default) {\n                            this.insertRowAsChild(row, group); // horizontal rows can only be one level deep\n                        }\n                        else {\n                            this.insertRow(row, group, groupSpecs.slice(1));\n                        }\n                    }\n                    else {\n                        this.insertRowAsChild(row, parent);\n                    }\n                };\n                // inserts the given row as a direct child of the given parent\n                ResourceTimelineView.prototype.insertRowAsChild = function (row, parent) {\n                    return parent.addChildRowNode(row, this.computeChildRowPosition(row, parent));\n                };\n                // computes the position at which the given node should be inserted into the parent's children\n                // if no specific position is determined, returns null\n                ResourceTimelineView.prototype.computeChildRowPosition = function (child, parent) {\n                    if (this.orderSpecs.length) {\n                        for (var i = 0; i < parent.children.length; i++) {\n                            var sibling = parent.children[i];\n                            var cmp = this.compareResources(sibling.resource || {}, child.resource || {});\n                            if (cmp > 0) {\n                                return i;\n                            }\n                        }\n                    }\n                    return null;\n                };\n                // given two resources, returns a cmp value (-1, 0, 1)\n                ResourceTimelineView.prototype.compareResources = function (a, b) {\n                    return fullcalendar_1.compareByFieldSpecs(a, b, this.orderSpecs);\n                };\n                // given information on how a row should be inserted into one of the parent's child groups,\n                // ensure a child group exists, creating it if necessary, and then return it.\n                // spec MIGHT NOT HAVE AN ORDER\n                ResourceTimelineView.prototype.ensureResourceGroup = function (row, parent, spec) {\n                    var i;\n                    var testGroup;\n                    var groupValue = (row.resource || {})[spec.field]; // the groupValue of the row\n                    var group = null;\n                    // find an existing group that matches, or determine the position for a new group\n                    if (spec.order) {\n                        for (i = 0; i < parent.children.length; i++) {\n                            testGroup = parent.children[i];\n                            var cmp = fullcalendar_1.flexibleCompare(testGroup.groupValue, groupValue) * spec.order;\n                            if (cmp === 0) {\n                                group = testGroup;\n                                break;\n                            }\n                            else if (cmp > 0) {\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        for (i = 0; i < parent.children.length; i++) {\n                            testGroup = parent.children[i];\n                            if (testGroup.groupValue === groupValue) {\n                                group = testGroup;\n                                break;\n                            }\n                        }\n                    } // `i` will be at the end if group was not found\n                    // create a new group\n                    if (!group) {\n                        if (this.isVGrouping) {\n                            group = new VRowGroup_1.default(this, spec, groupValue);\n                        }\n                        else {\n                            group = new HRowGroup_1.default(this, spec, groupValue);\n                        }\n                        parent.addChildRowNode(group, i);\n                        group.renderSkeleton(); // always immediately render groups\n                    }\n                    return group;\n                };\n                // Row Rendering\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.descendantAdded = function (row) {\n                    var wasNesting = this.isNesting;\n                    var isNesting = Boolean(this.nestingCnt += row.depth ? 1 : 0);\n                    if (wasNesting !== isNesting) {\n                        this.el.toggleClass('fc-nested', isNesting)\n                            .toggleClass('fc-flat', !isNesting);\n                        this.isNesting = isNesting;\n                    }\n                };\n                ResourceTimelineView.prototype.descendantRemoved = function (row) {\n                    var wasNesting = this.isNesting;\n                    var isNesting = Boolean(this.nestingCnt -= row.depth ? 1 : 0);\n                    if (wasNesting !== isNesting) {\n                        this.el.toggleClass('fc-nested', isNesting)\n                            .toggleClass('fc-flat', !isNesting);\n                        this.isNesting = isNesting;\n                    }\n                };\n                ResourceTimelineView.prototype.descendantShown = function (row) {\n                    (this.rowsNeedingHeightSync || (this.rowsNeedingHeightSync = [])).push(row);\n                };\n                ResourceTimelineView.prototype.descendantHidden = function (row) {\n                    if (!this.rowsNeedingHeightSync) {\n                        this.rowsNeedingHeightSync = [];\n                    }\n                };\n                // visibleRows is flat. does not do recursive\n                ResourceTimelineView.prototype.syncRowHeights = function (visibleRows, safe) {\n                    if (visibleRows === void 0) {\n                        visibleRows = this.getVisibleRows();\n                    }\n                    if (safe === void 0) {\n                        safe = false;\n                    }\n                    for (var _i = 0, visibleRows_1 = visibleRows; _i < visibleRows_1.length; _i++) {\n                        var row = visibleRows_1[_i];\n                        row.setTrInnerHeight('');\n                    }\n                    var innerHeights = visibleRows.map(function (row) {\n                        var h = row.getMaxTrInnerHeight();\n                        if (safe) {\n                            h += h % 2; // FF and zoom only like even numbers for alignment\n                        }\n                        return h;\n                    });\n                    for (var i = 0; i < visibleRows.length; i++) {\n                        var row = visibleRows[i];\n                        row.setTrInnerHeight(innerHeights[i]);\n                    }\n                    if (!safe) {\n                        var h1 = this.spreadsheet.tbodyEl.height();\n                        var h2 = this.timeBodyTbodyEl.height();\n                        if (Math.abs(h1 - h2) > 1) {\n                            this.syncRowHeights(visibleRows, true);\n                        }\n                    }\n                };\n                // Row Querying\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.getVisibleRows = function () {\n                    var result = [];\n                    for (var _i = 0, _a = this.rowHierarchy.getRows(); _i < _a.length; _i++) {\n                        var row = _a[_i];\n                        if (row.get('isInDom')) {\n                            result.push(row);\n                        }\n                    }\n                    return result;\n                };\n                ResourceTimelineView.prototype.getEventRows = function () {\n                    return this.rowHierarchy.getRows().filter(function (row) { return (row instanceof EventRow_1.default); });\n                };\n                ResourceTimelineView.prototype.getResourceRow = function (resourceId) {\n                    return this.resourceRowHash[resourceId];\n                };\n                // Selection\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderSelectionFootprint = function (componentFootprint) {\n                    if (componentFootprint.resourceId) {\n                        var rowObj = this.getResourceRow(componentFootprint.resourceId);\n                        if (rowObj) {\n                            return rowObj.renderSelectionFootprint(componentFootprint);\n                        }\n                    }\n                    else {\n                        return _super.prototype.renderSelectionFootprint.call(this, componentFootprint);\n                    }\n                };\n                // Event Resizing (route to rows)\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    var map = groupEventFootprintsByResourceId(eventFootprints);\n                    for (var resourceId in map) {\n                        var resourceEventFootprints = map[resourceId];\n                        var rowObj = this.getResourceRow(resourceId);\n                        // render helpers\n                        rowObj.helperRenderer.renderEventDraggingFootprints(resourceEventFootprints, seg, isTouch);\n                        // render highlight\n                        for (var _i = 0, resourceEventFootprints_1 = resourceEventFootprints; _i < resourceEventFootprints_1.length; _i++) {\n                            var eventFootprint = resourceEventFootprints_1[_i];\n                            rowObj.renderHighlight(eventFootprint.componentFootprint);\n                        }\n                    }\n                };\n                ResourceTimelineView.prototype.unrenderEventResize = function () {\n                    for (var _i = 0, _a = this.getEventRows(); _i < _a.length; _i++) {\n                        var rowObj = _a[_i];\n                        rowObj.helperRenderer.unrender();\n                        rowObj.unrenderHighlight();\n                    }\n                };\n                // DnD (route to rows)\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceTimelineView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    var map = groupEventFootprintsByResourceId(eventFootprints);\n                    var resourceEventFootprints;\n                    var resourceId;\n                    var rowObj;\n                    if (seg) {\n                        // draw helper\n                        for (resourceId in map) {\n                            resourceEventFootprints = map[resourceId];\n                            rowObj = this.getResourceRow(resourceId);\n                            rowObj.helperRenderer.renderEventDraggingFootprints(resourceEventFootprints, seg, isTouch);\n                        }\n                        return true; // signal helper rendered\n                    }\n                    else {\n                        // draw highlight\n                        for (resourceId in map) {\n                            resourceEventFootprints = map[resourceId];\n                            for (var _i = 0, resourceEventFootprints_2 = resourceEventFootprints; _i < resourceEventFootprints_2.length; _i++) {\n                                var eventFootprint = resourceEventFootprints_2[_i];\n                                rowObj = this.getResourceRow(resourceId);\n                                rowObj.renderHighlight(eventFootprint.componentFootprint);\n                            }\n                        }\n                        return false; // signal helper not rendered\n                    }\n                };\n                ResourceTimelineView.prototype.unrenderDrag = function () {\n                    for (var _i = 0, _a = this.getEventRows(); _i < _a.length; _i++) {\n                        var rowObj = _a[_i];\n                        rowObj.helperRenderer.unrender();\n                        rowObj.unrenderHighlight();\n                    }\n                };\n                return ResourceTimelineView;\n            }(TimelineView_1.default));\n            exports.default = ResourceTimelineView;\n            ResourceTimelineView.prototype.eventRendererClass = ResourceTimelineEventRenderer_1.default;\n            ResourceViewMixin_1.default.mixInto(ResourceTimelineView);\n            // Utils\n            // ------------------------------------------------------------------------------------------------------------------\n            function groupEventFootprintsByResourceId(eventFootprints) {\n                var map = {};\n                for (var _i = 0, eventFootprints_1 = eventFootprints; _i < eventFootprints_1.length; _i++) {\n                    var eventFootprint = eventFootprints_1[_i];\n                    (map[eventFootprint.componentFootprint.resourceId] || (map[eventFootprint.componentFootprint.resourceId] = []))\n                        .push(eventFootprint);\n                }\n                return map;\n            }\n            /*\n            if `current` is null, returns true\n            */\n            function computeIsChildrenVisible(current) {\n                while (current) {\n                    if (!current.isExpanded) {\n                        return false;\n                    }\n                    current = current.parent;\n                }\n                return true;\n            }\n            /***/ \n        }),\n        /* 31 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var RowGroup_1 = __webpack_require__(32);\n            /*\n            A row grouping that renders as a tall multi-cell vertical span in the \"spreadsheet\" area\n            */\n            var VRowGroup = (function (_super) {\n                tslib_1.__extends(VRowGroup, _super);\n                function VRowGroup(view, groupSpec, groupValue) {\n                    var _this = _super.call(this, view, groupSpec, groupValue) || this;\n                    _this.rowspan = 0;\n                    return _this;\n                }\n                /*\n                Makes sure the groupTd has the correct rowspan / place in the DOM.\n                PRECONDITION: in the case of multiple group nesting, a child's renderRowspan()\n                will be called before the parent's renderRowspan().\n                */\n                VRowGroup.prototype.renderRowspan = function () {\n                    var leadingTr;\n                    var theme = this.view.calendar.theme;\n                    if (this.rowspan) {\n                        // ensure the TD element\n                        if (!this.groupTd) {\n                            this.groupTd = $('<td class=\"' + theme.getClass('widgetContent') + '\"/>')\n                                .append(this.renderGroupContentEl());\n                        }\n                        this.groupTd.attr('rowspan', this.rowspan);\n                        // (re)insert groupTd if it was never inserted, or the first TR is different\n                        leadingTr = this.getLeadingRow().getTr('spreadsheet');\n                        if (leadingTr !== this.leadingTr) {\n                            if (leadingTr) {\n                                leadingTr.prepend(this.groupTd); // parents will later prepend their own\n                            }\n                            this.leadingTr = leadingTr;\n                        }\n                    }\n                    else {\n                        // remove the TD element if it was rendered\n                        if (this.groupTd) {\n                            this.groupTd.remove();\n                            this.groupTd = null;\n                        }\n                        this.leadingTr = null;\n                    }\n                };\n                /*\n                Called when a row somewhere within the grouping is shown\n                */\n                VRowGroup.prototype.descendantShown = function (row) {\n                    this.rowspan += 1;\n                    this.renderRowspan();\n                    _super.prototype.descendantShown.call(this, row); // will bubble to parent\n                };\n                /*\n                Called when a row somewhere within the grouping is hidden\n                */\n                VRowGroup.prototype.descendantHidden = function (row) {\n                    this.rowspan -= 1;\n                    this.renderRowspan();\n                    _super.prototype.descendantHidden.call(this, row);\n                };\n                return VRowGroup;\n            }(RowGroup_1.default));\n            exports.default = VRowGroup;\n            /***/ \n        }),\n        /* 32 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var RowParent_1 = __webpack_require__(18);\n            /*\n            An abstract node in a row-hierarchy tree that contains other nodes.\n            Will have some sort of rendered label indicating the grouping,\n            up to the subclass for determining what to do with it.\n            */\n            var RowGroup = (function (_super) {\n                tslib_1.__extends(RowGroup, _super);\n                function RowGroup(view, groupSpec, groupValue) {\n                    var _this = _super.call(this, view) || this;\n                    _this.groupSpec = groupSpec;\n                    _this.groupValue = groupValue;\n                    return _this;\n                }\n                /*\n                Called when this row (if it renders a row) or a subrow is removed\n                */\n                RowGroup.prototype.descendantRemoved = function (row) {\n                    _super.prototype.descendantRemoved.call(this, row); // bubble up to the view and let the node be fully removed\n                    // and there are no more children in the group, implictly remove this group as well\n                    if (!this.children.length) {\n                        this.removeFromParentAndDom();\n                    }\n                };\n                /*\n                Renders the content wrapper element that will be inserted into this row's TD cell\n                */\n                RowGroup.prototype.renderGroupContentEl = function () {\n                    var contentEl = $('<div class=\"fc-cell-content\" />')\n                        .append(this.renderGroupTextEl());\n                    var filter = this.groupSpec.render;\n                    if (typeof filter === 'function') {\n                        contentEl = filter(contentEl, this.groupValue) || contentEl;\n                    }\n                    return contentEl;\n                };\n                /*\n                Renders the text span element that will be inserted into this row's TD cell.\n                Goes within the content element.\n                */\n                RowGroup.prototype.renderGroupTextEl = function () {\n                    var text = this.groupValue || ''; // might be null/undefined if an ad-hoc grouping\n                    var filter = this.groupSpec.text;\n                    if (typeof filter === 'function') {\n                        text = filter(text) || text;\n                    }\n                    return $('<span class=\"fc-cell-text\" />').text(text);\n                };\n                return RowGroup;\n            }(RowParent_1.default));\n            exports.default = RowGroup;\n            /***/ \n        }),\n        /* 33 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            var RowParent_1 = __webpack_require__(18);\n            var TimelineFillRenderer_1 = __webpack_require__(28);\n            var TimelineEventRenderer_1 = __webpack_require__(17);\n            var TimelineHelperRenderer_1 = __webpack_require__(29);\n            var EventRow = (function (_super) {\n                tslib_1.__extends(EventRow, _super);\n                function EventRow() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                EventRow.prototype.renderEventSkeleton = function (tr) {\n                    var theme = this.view.calendar.theme;\n                    tr.html(\"<td class=\\\"\" + theme.getClass('widgetContent') + \"\\\"> <div> <div class=\\\"fc-event-container\\\" /> </div> </td>\");\n                    this.segContainerEl = tr.find('.fc-event-container');\n                    this.innerEl = (this.bgSegContainerEl = tr.find('td > div'));\n                };\n                EventRow.prototype.rangeToCoords = function (range) {\n                    return this.view.rangeToCoords(range);\n                };\n                EventRow.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    return this.view.componentFootprintToSegs(componentFootprint);\n                };\n                return EventRow;\n            }(RowParent_1.default));\n            exports.default = EventRow;\n            EventRow.prototype.fillRendererClass = TimelineFillRenderer_1.default;\n            EventRow.prototype.eventRendererClass = TimelineEventRenderer_1.default;\n            EventRow.prototype.helperRendererClass = TimelineHelperRenderer_1.default;\n            EventRow.prototype.businessHourRendererClass = fullcalendar_1.BusinessHourRenderer;\n            EventRow.prototype.hasOwnRow = true;\n            /***/ \n        }),\n        /* 34 */ ,\n        /* 35 */ ,\n        /* 36 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var exportHooks = __webpack_require__(0);\n            // imports solely for side-effects\n            __webpack_require__(37);\n            __webpack_require__(48);\n            __webpack_require__(50);\n            __webpack_require__(51);\n            __webpack_require__(53);\n            __webpack_require__(54);\n            __webpack_require__(55);\n            __webpack_require__(56);\n            __webpack_require__(57);\n            __webpack_require__(58);\n            __webpack_require__(59);\n            __webpack_require__(60);\n            __webpack_require__(61);\n            __webpack_require__(62);\n            __webpack_require__(63);\n            __webpack_require__(64);\n            __webpack_require__(65);\n            __webpack_require__(66);\n            __webpack_require__(67);\n            __webpack_require__(68);\n            var schedulerVersion = '1.9.4';\n            exportHooks.schedulerVersion = schedulerVersion;\n            /*\n            When the required internal version is upped,\n            also update the .json files with a new minor version requirement.\n            Example: bump ~2.7.2 to ~2.8.0\n            Use a tilde to match future patch-level changes only!\n            */\n            if (exportHooks.internalApiVersion !== 12) {\n                throw new Error('v' + schedulerVersion + ' of FullCalendar Scheduler ' +\n                    'is incompatible with v' + exportHooks.version + ' of the core.\\n' +\n                    'Please see http://fullcalendar.io/support/ for more information.');\n            }\n            /***/ \n        }),\n        /* 37 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var exportHooks = __webpack_require__(0);\n            var ResourceAgendaView_1 = __webpack_require__(20);\n            var ResourceBasicView_1 = __webpack_require__(22);\n            var ResourceMonthView_1 = __webpack_require__(23);\n            var TimelineView_1 = __webpack_require__(14);\n            var ResourceTimelineView_1 = __webpack_require__(30);\n            // TODO: find a better way\n            exportHooks.ResourceAgendaView = ResourceAgendaView_1.default;\n            exportHooks.ResourceBasicView = ResourceBasicView_1.default;\n            exportHooks.ResourceMonthView = ResourceMonthView_1.default;\n            exportHooks.TimelineView = TimelineView_1.default;\n            exportHooks.ResourceTimelineView = ResourceTimelineView_1.default;\n            /***/ \n        }),\n        /* 38 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceDayTableMixin_1 = __webpack_require__(21);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            var ResourceTimeGrid = (function (_super) {\n                tslib_1.__extends(ResourceTimeGrid, _super);\n                function ResourceTimeGrid(view) {\n                    var _this = _super.call(this, view) || this;\n                    _this.isResourceFootprintsEnabled = true;\n                    return _this;\n                }\n                ResourceTimeGrid.prototype.renderDates = function (dateProfile) {\n                    this.dateProfile = dateProfile;\n                    this.renderSlats();\n                };\n                ResourceTimeGrid.prototype.renderResources = function (resources) {\n                    this.registerResources(resources);\n                    this.renderColumns();\n                    if (this.headContainerEl) {\n                        this.processHeadResourceEls(this.headContainerEl);\n                    }\n                };\n                // TODO: make DRY with ResourceDayGrid\n                ResourceTimeGrid.prototype.getHitFootprint = function (hit) {\n                    var plainFootprint = _super.prototype.getHitFootprint.call(this, hit);\n                    return new ResourceComponentFootprint_1.default(plainFootprint.unzonedRange, plainFootprint.isAllDay, this.getColResource(hit.col).id);\n                };\n                ResourceTimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    var resourceCnt = this.resourceCnt;\n                    var genericSegs = this.sliceRangeByTimes(componentFootprint.unzonedRange); // no assigned resources\n                    var resourceSegs = [];\n                    for (var _i = 0, genericSegs_1 = genericSegs; _i < genericSegs_1.length; _i++) {\n                        var seg = genericSegs_1[_i];\n                        for (var resourceIndex = 0; resourceIndex < resourceCnt; resourceIndex++) {\n                            var resourceObj = this.flattenedResources[resourceIndex];\n                            if (!(componentFootprint instanceof ResourceComponentFootprint_1.default) ||\n                                (componentFootprint.resourceId === resourceObj.id)) {\n                                var copy = $.extend({}, seg);\n                                copy.resource = resourceObj;\n                                copy.col = this.indicesToCol(resourceIndex, seg.dayIndex);\n                                resourceSegs.push(copy);\n                            }\n                        }\n                    }\n                    return resourceSegs;\n                };\n                return ResourceTimeGrid;\n            }(fullcalendar_1.TimeGrid));\n            exports.default = ResourceTimeGrid;\n            ResourceDayTableMixin_1.default.mixInto(ResourceTimeGrid);\n            /***/ \n        }),\n        /* 39 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var rtlScrollSystem = null;\n            /*\n            A Scroller with additional functionality:\n            - optional ScrollerCanvas for content\n            - fired events for scroll start/end\n            - cross-browser normalization of horizontal scroll for RTL\n            */\n            var EnhancedScroller = (function (_super) {\n                tslib_1.__extends(EnhancedScroller, _super);\n                function EnhancedScroller(options) {\n                    var _this = _super.call(this, options) || this;\n                    _this.isScrolling = false;\n                    _this.isTouching = false;\n                    _this.isTouchedEver = false;\n                    _this.isMoving = false;\n                    _this.isTouchScrollEnabled = true;\n                    _this.requestMovingEnd = fullcalendar_1.debounce(_this.reportMovingEnd, 500);\n                    return _this;\n                }\n                EnhancedScroller.prototype.render = function () {\n                    _super.prototype.render.call(this);\n                    if (this.canvas) {\n                        this.canvas.render();\n                        this.canvas.el.appendTo(this.scrollEl);\n                    }\n                    this.bindHandlers();\n                };\n                EnhancedScroller.prototype.destroy = function () {\n                    _super.prototype.destroy.call(this);\n                    this.unbindHandlers();\n                };\n                // Touch scroll prevention\n                // ----------------------------------------------------------------------------------------------\n                EnhancedScroller.prototype.disableTouchScroll = function () {\n                    this.isTouchScrollEnabled = false;\n                    this.bindPreventTouchScroll(); // will be unbound in enableTouchScroll or reportTouchEnd\n                };\n                EnhancedScroller.prototype.enableTouchScroll = function () {\n                    this.isTouchScrollEnabled = true;\n                    // only immediately unbind if a touch event is NOT in progress.\n                    // otherwise, it will be handled by reportTouchEnd.\n                    if (!this.isTouching) {\n                        this.unbindPreventTouchScroll();\n                    }\n                };\n                EnhancedScroller.prototype.bindPreventTouchScroll = function () {\n                    if (!this.preventTouchScrollHandler) {\n                        this.scrollEl.on('touchmove', (this.preventTouchScrollHandler = fullcalendar_1.preventDefault));\n                    }\n                };\n                EnhancedScroller.prototype.unbindPreventTouchScroll = function () {\n                    if (this.preventTouchScrollHandler) {\n                        this.scrollEl.off('touchmove', this.preventTouchScrollHandler);\n                        this.preventTouchScrollHandler = null;\n                    }\n                };\n                // Handlers\n                // ----------------------------------------------------------------------------------------------\n                EnhancedScroller.prototype.bindHandlers = function () {\n                    return this.listenTo(this.scrollEl, {\n                        scroll: this.reportScroll,\n                        touchstart: this.reportTouchStart,\n                        touchend: this.reportTouchEnd\n                    });\n                };\n                EnhancedScroller.prototype.unbindHandlers = function () {\n                    return this.stopListeningTo(this.scrollEl);\n                };\n                // Scroll Events\n                // ----------------------------------------------------------------------------------------------\n                EnhancedScroller.prototype.reportScroll = function () {\n                    if (!this.isScrolling) {\n                        this.reportScrollStart();\n                    }\n                    this.trigger('scroll');\n                    this.isMoving = true;\n                    this.requestMovingEnd();\n                };\n                EnhancedScroller.prototype.reportScrollStart = function () {\n                    if (!this.isScrolling) {\n                        this.isScrolling = true;\n                        this.trigger('scrollStart', this.isTouching); // created in constructor\n                    }\n                };\n                EnhancedScroller.prototype.reportMovingEnd = function () {\n                    this.isMoving = false;\n                    // only end the scroll if not currently touching.\n                    // if touching, the scrolling will end later, on touchend.\n                    if (!this.isTouching) {\n                        this.reportScrollEnd();\n                    }\n                };\n                EnhancedScroller.prototype.reportScrollEnd = function () {\n                    if (this.isScrolling) {\n                        this.trigger('scrollEnd');\n                        this.isScrolling = false;\n                    }\n                };\n                // Touch Events\n                // ----------------------------------------------------------------------------------------------\n                // will fire *before* the scroll event is fired\n                EnhancedScroller.prototype.reportTouchStart = function () {\n                    this.isTouching = true;\n                    this.isTouchedEver = true;\n                };\n                EnhancedScroller.prototype.reportTouchEnd = function () {\n                    if (this.isTouching) {\n                        this.isTouching = false;\n                        // if touch scrolling was re-enabled during a recent touch scroll\n                        // then unbind the handlers that are preventing it from happening.\n                        if (this.isTouchScrollEnabled) {\n                            this.unbindPreventTouchScroll(); // won't do anything if not bound\n                        }\n                        // if the user ended their touch, and the scroll area wasn't moving,\n                        // we consider this to be the end of the scroll.\n                        if (!this.isMoving) {\n                            this.reportScrollEnd(); // won't fire if already ended\n                        }\n                    }\n                };\n                // Horizontal Scroll Normalization\n                // ----------------------------------------------------------------------------------------------\n                // http://stackoverflow.com/questions/24276619/better-way-to-get-the-viewport-of-a-scrollable-div-in-rtl-mode/24394376#24394376\n                /*\n                If RTL, and scrolled to the left, returns NEGATIVE value (like Firefox)\n                */\n                EnhancedScroller.prototype.getScrollLeft = function () {\n                    var direction = this.scrollEl.css('direction');\n                    var node = this.scrollEl[0];\n                    var val = node.scrollLeft;\n                    if (direction === 'rtl') {\n                        switch (rtlScrollSystem) {\n                            case 'positive':\n                                val = (val + node.clientWidth) - node.scrollWidth;\n                                break;\n                            case 'reverse':\n                                val = -val;\n                                break;\n                        }\n                    }\n                    return val;\n                };\n                /*\n                Accepts a NEGATIVE value for when scrolled in RTL\n                */\n                EnhancedScroller.prototype.setScrollLeft = function (val) {\n                    var direction = this.scrollEl.css('direction');\n                    var node = this.scrollEl[0];\n                    if (direction === 'rtl') {\n                        switch (rtlScrollSystem) {\n                            case 'positive':\n                                val = (val - node.clientWidth) + node.scrollWidth;\n                                break;\n                            case 'reverse':\n                                val = -val;\n                                break;\n                        }\n                    }\n                    node.scrollLeft = val;\n                };\n                /*\n                Always returns the number of pixels scrolled from the leftmost position (even if RTL).\n                Always positive.\n                */\n                EnhancedScroller.prototype.getScrollFromLeft = function () {\n                    var direction = this.scrollEl.css('direction');\n                    var node = this.scrollEl[0];\n                    var val = node.scrollLeft;\n                    if (direction === 'rtl') {\n                        switch (rtlScrollSystem) {\n                            case 'negative':\n                                val = (val - node.clientWidth) + node.scrollWidth;\n                                break;\n                            case 'reverse':\n                                val = (-val - node.clientWidth) + node.scrollWidth;\n                                break;\n                        }\n                    }\n                    return val;\n                };\n                EnhancedScroller.prototype.getNativeScrollLeft = function () {\n                    return this.scrollEl[0].scrollLeft;\n                };\n                EnhancedScroller.prototype.setNativeScrollLeft = function (val) {\n                    this.scrollEl[0].scrollLeft = val;\n                };\n                return EnhancedScroller;\n            }(fullcalendar_1.Scroller));\n            exports.default = EnhancedScroller;\n            fullcalendar_1.EmitterMixin.mixInto(EnhancedScroller);\n            fullcalendar_1.ListenerMixin.mixInto(EnhancedScroller);\n            // Horizontal Scroll System Detection\n            // ----------------------------------------------------------------------------------------------\n            function detectRtlScrollSystem() {\n                var el = $(\"<div style=\\\" position: absolute; top: -1000px; width: 1px; height: 1px; overflow: scroll; direction: rtl; font-size: 100px; \\\">A</div>\").appendTo('body');\n                var node = el[0];\n                var system = (function () {\n                    if (node.scrollLeft > 0) {\n                        return 'positive';\n                    }\n                    else {\n                        node.scrollLeft = 1;\n                        if (node.scrollLeft > 0) {\n                            return 'reverse';\n                        }\n                        else {\n                            return 'negative';\n                        }\n                    }\n                })();\n                el.remove();\n                return system;\n            }\n            $(function () {\n                rtlScrollSystem = detectRtlScrollSystem();\n            });\n            /***/ \n        }),\n        /* 40 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            /*\n            TODO: use pubsub instead?\n            */\n            var TimelineEventDragging = (function (_super) {\n                tslib_1.__extends(TimelineEventDragging, _super);\n                function TimelineEventDragging() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                TimelineEventDragging.prototype.segDragStart = function (seg, ev) {\n                    _super.prototype.segDragStart.call(this, seg, ev);\n                    if (this.component.eventTitleFollower) {\n                        this.component.eventTitleFollower.forceRelative();\n                    }\n                };\n                TimelineEventDragging.prototype.segDragStop = function (seg, ev) {\n                    _super.prototype.segDragStop.call(this, seg, ev);\n                    if (this.component.eventTitleFollower) {\n                        this.component.eventTitleFollower.clearForce();\n                    }\n                };\n                return TimelineEventDragging;\n            }(fullcalendar_1.EventDragging));\n            exports.default = TimelineEventDragging;\n            /***/ \n        }),\n        /* 41 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var fullcalendar_1 = __webpack_require__(0);\n            /*\n            TODO: use pubsub instead?\n            */\n            var TimelineEventResizing = (function (_super) {\n                tslib_1.__extends(TimelineEventResizing, _super);\n                function TimelineEventResizing() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                TimelineEventResizing.prototype.segResizeStart = function (seg, ev) {\n                    _super.prototype.segResizeStart.call(this, seg, ev);\n                    if (this.component.eventTitleFollower) {\n                        return this.component.eventTitleFollower.forceRelative();\n                    }\n                };\n                TimelineEventResizing.prototype.segResizeStop = function (seg, ev) {\n                    _super.prototype.segResizeStop.call(this, seg, ev);\n                    if (this.component.eventTitleFollower) {\n                        return this.component.eventTitleFollower.clearForce();\n                    }\n                };\n                return TimelineEventResizing;\n            }(fullcalendar_1.EventResizing));\n            exports.default = TimelineEventResizing;\n            /***/ \n        }),\n        /* 42 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var moment = __webpack_require__(15);\n            var core = __webpack_require__(0);\n            var MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\n            var MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\n            var MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\n            core.MAX_TIMELINE_SLOTS = 1000;\n            // potential nice values for slot-duration and interval-duration\n            var STOCK_SUB_DURATIONS = [\n                { years: 1 },\n                { months: 1 },\n                { days: 1 },\n                { hours: 1 },\n                { minutes: 30 },\n                { minutes: 15 },\n                { minutes: 10 },\n                { minutes: 5 },\n                { minutes: 1 },\n                { seconds: 30 },\n                { seconds: 15 },\n                { seconds: 10 },\n                { seconds: 5 },\n                { seconds: 1 },\n                { milliseconds: 500 },\n                { milliseconds: 100 },\n                { milliseconds: 10 },\n                { milliseconds: 1 }\n            ];\n            function initScaleProps(timelineView) {\n                timelineView.labelInterval = queryDurationOption(timelineView, 'slotLabelInterval');\n                timelineView.slotDuration = queryDurationOption(timelineView, 'slotDuration');\n                validateLabelAndSlot(timelineView); // validate after computed grid duration\n                ensureLabelInterval(timelineView);\n                ensureSlotDuration(timelineView);\n                var input = timelineView.opt('slotLabelFormat');\n                var type = $.type(input);\n                timelineView.headerFormats =\n                    type === 'array' ?\n                        input\n                        : type === 'string' ?\n                            [input]\n                            :\n                                computeHeaderFormats(timelineView);\n                timelineView.isTimeScale = core.durationHasTime(timelineView.slotDuration);\n                var largeUnit = null;\n                if (!timelineView.isTimeScale) {\n                    var slotUnit = core.computeGreatestUnit(timelineView.slotDuration);\n                    if (/year|month|week/.test(slotUnit)) {\n                        largeUnit = slotUnit;\n                    }\n                }\n                timelineView.largeUnit = largeUnit;\n                timelineView.emphasizeWeeks = (timelineView.slotDuration.as('days') === 1) &&\n                    (timelineView.currentRangeAs('weeks') >= 2) &&\n                    !timelineView.opt('businessHours');\n                /*\n                console.log('label interval =', timelineView.labelInterval.humanize())\n                console.log('slot duration =', timelineView.slotDuration.humanize())\n                console.log('header formats =', timelineView.headerFormats)\n                console.log('isTimeScale', timelineView.isTimeScale)\n                console.log('largeUnit', timelineView.largeUnit)\n                */\n                var rawSnapDuration = timelineView.opt('snapDuration');\n                timelineView.snapDuration =\n                    rawSnapDuration ?\n                        moment.duration(rawSnapDuration) :\n                        timelineView.slotDuration;\n                timelineView.snapsPerSlot = core.divideDurationByDuration(timelineView.slotDuration, timelineView.snapDuration);\n            }\n            exports.initScaleProps = initScaleProps;\n            function queryDurationOption(timelineView, name) {\n                var input = timelineView.opt(name);\n                if (input != null) {\n                    var dur = moment.duration(input);\n                    if (+dur) {\n                        return dur;\n                    }\n                }\n            }\n            function validateLabelAndSlot(timelineView) {\n                var currentUnzonedRange = timelineView.dateProfile.currentUnzonedRange;\n                // make sure labelInterval doesn't exceed the max number of cells\n                if (timelineView.labelInterval) {\n                    var labelCnt = core.divideRangeByDuration(currentUnzonedRange.getStart(), currentUnzonedRange.getEnd(), timelineView.labelInterval);\n                    if (labelCnt > core.MAX_TIMELINE_SLOTS) {\n                        core.warn('slotLabelInterval results in too many cells');\n                        timelineView.labelInterval = null;\n                    }\n                }\n                // make sure slotDuration doesn't exceed the maximum number of cells\n                if (timelineView.slotDuration) {\n                    var slotCnt = core.divideRangeByDuration(currentUnzonedRange.getStart(), currentUnzonedRange.getEnd(), timelineView.slotDuration);\n                    if (slotCnt > core.MAX_TIMELINE_SLOTS) {\n                        core.warn('slotDuration results in too many cells');\n                        timelineView.slotDuration = null;\n                    }\n                }\n                // make sure labelInterval is a multiple of slotDuration\n                if (timelineView.labelInterval && timelineView.slotDuration) {\n                    var slotsPerLabel = core.divideDurationByDuration(timelineView.labelInterval, timelineView.slotDuration);\n                    if (!core.isInt(slotsPerLabel) || (slotsPerLabel < 1)) {\n                        core.warn('slotLabelInterval must be a multiple of slotDuration');\n                        return timelineView.slotDuration = null;\n                    }\n                }\n            }\n            function ensureLabelInterval(timelineView) {\n                var currentUnzonedRange = timelineView.dateProfile.currentUnzonedRange;\n                var labelInterval = timelineView.labelInterval;\n                if (!labelInterval) {\n                    // compute based off the slot duration\n                    // find the largest label interval with an acceptable slots-per-label\n                    var input = void 0;\n                    if (timelineView.slotDuration) {\n                        for (var _i = 0, STOCK_SUB_DURATIONS_1 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_1.length; _i++) {\n                            input = STOCK_SUB_DURATIONS_1[_i];\n                            var tryLabelInterval = moment.duration(input);\n                            var slotsPerLabel = core.divideDurationByDuration(tryLabelInterval, timelineView.slotDuration);\n                            if (core.isInt(slotsPerLabel) && (slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL)) {\n                                labelInterval = tryLabelInterval;\n                                break;\n                            }\n                        }\n                        // use the slot duration as a last resort\n                        if (!labelInterval) {\n                            labelInterval = timelineView.slotDuration;\n                        }\n                        // compute based off the view's duration\n                        // find the largest label interval that yields the minimum number of labels\n                    }\n                    else {\n                        for (var _a = 0, STOCK_SUB_DURATIONS_2 = STOCK_SUB_DURATIONS; _a < STOCK_SUB_DURATIONS_2.length; _a++) {\n                            input = STOCK_SUB_DURATIONS_2[_a];\n                            labelInterval = moment.duration(input);\n                            var labelCnt = core.divideRangeByDuration(currentUnzonedRange.getStart(), currentUnzonedRange.getEnd(), labelInterval);\n                            if (labelCnt >= MIN_AUTO_LABELS) {\n                                break;\n                            }\n                        }\n                    }\n                    timelineView.labelInterval = labelInterval;\n                }\n                return labelInterval;\n            }\n            function ensureSlotDuration(timelineView) {\n                var currentUnzonedRange = timelineView.dateProfile.currentUnzonedRange;\n                var slotDuration = timelineView.slotDuration;\n                if (!slotDuration) {\n                    var labelInterval = ensureLabelInterval(timelineView); // will compute if necessary\n                    // compute based off the label interval\n                    // find the largest slot duration that is different from labelInterval, but still acceptable\n                    for (var _i = 0, STOCK_SUB_DURATIONS_3 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_3.length; _i++) {\n                        var input = STOCK_SUB_DURATIONS_3[_i];\n                        var trySlotDuration = moment.duration(input);\n                        var slotsPerLabel = core.divideDurationByDuration(labelInterval, trySlotDuration);\n                        if (core.isInt(slotsPerLabel) && (slotsPerLabel > 1) && (slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL)) {\n                            slotDuration = trySlotDuration;\n                            break;\n                        }\n                    }\n                    // only allow the value if it won't exceed the view's # of slots limit\n                    if (slotDuration) {\n                        var slotCnt = core.divideRangeByDuration(currentUnzonedRange.getStart(), currentUnzonedRange.getEnd(), slotDuration);\n                        if (slotCnt > MAX_AUTO_CELLS) {\n                            slotDuration = null;\n                        }\n                    }\n                    // use the label interval as a last resort\n                    if (!slotDuration) {\n                        slotDuration = labelInterval;\n                    }\n                    timelineView.slotDuration = slotDuration;\n                }\n                return slotDuration;\n            }\n            function computeHeaderFormats(timelineView) {\n                var format1;\n                var format2;\n                var labelInterval = timelineView.labelInterval;\n                var unit = core.computeGreatestUnit(labelInterval);\n                var weekNumbersVisible = timelineView.opt('weekNumbers');\n                var format0 = (format1 = (format2 = null));\n                // NOTE: weekNumber computation function wont work\n                if ((unit === 'week') && !weekNumbersVisible) {\n                    unit = 'day';\n                }\n                switch (unit) {\n                    case 'year':\n                        format0 = 'YYYY'; // '2015'\n                        break;\n                    case 'month':\n                        if (timelineView.currentRangeAs('years') > 1) {\n                            format0 = 'YYYY'; // '2015'\n                        }\n                        format1 = 'MMM'; // 'Jan'\n                        break;\n                    case 'week':\n                        if (timelineView.currentRangeAs('years') > 1) {\n                            format0 = 'YYYY'; // '2015'\n                        }\n                        format1 = timelineView.opt('shortWeekFormat'); // 'Wk4'\n                        break;\n                    case 'day':\n                        if (timelineView.currentRangeAs('years') > 1) {\n                            format0 = timelineView.opt('monthYearFormat'); // 'January 2014'\n                        }\n                        else if (timelineView.currentRangeAs('months') > 1) {\n                            format0 = 'MMMM'; // 'January'\n                        }\n                        if (weekNumbersVisible) {\n                            format1 = timelineView.opt('weekFormat'); // 'Wk 4'\n                        }\n                        // TODO: would use smallDayDateFormat but the way timeline does RTL,\n                        // we don't want the text to be flipped\n                        format2 = 'dd D'; // @opt('smallDayDateFormat') # 'Su 9'\n                        break;\n                    case 'hour':\n                        if (weekNumbersVisible) {\n                            format0 = timelineView.opt('weekFormat'); // 'Wk 4'\n                        }\n                        if (timelineView.currentRangeAs('days') > 1) {\n                            format1 = timelineView.opt('dayOfMonthFormat'); // 'Fri 9/15'\n                        }\n                        format2 = timelineView.opt('smallTimeFormat'); // '6pm'\n                        break;\n                    case 'minute':\n                        // sufficiently large number of different minute cells?\n                        if ((labelInterval.asMinutes() / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                            format0 = timelineView.opt('hourFormat'); // '6pm'\n                            format1 = '[:]mm'; // ':30'\n                        }\n                        else {\n                            format0 = timelineView.opt('mediumTimeFormat'); // '6:30pm'\n                        }\n                        break;\n                    case 'second':\n                        // sufficiently large number of different second cells?\n                        if ((labelInterval.asSeconds() / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                            format0 = 'LT'; // '8:30 PM'\n                            format1 = '[:]ss'; // ':30'\n                        }\n                        else {\n                            format0 = 'LTS'; // '8:30:45 PM'\n                        }\n                        break;\n                    case 'millisecond':\n                        format0 = 'LTS'; // '8:30:45 PM'\n                        format1 = '[.]SSS'; // '750'\n                        break;\n                }\n                return [].concat(format0 || [], format1 || [], format2 || []);\n            }\n            /***/ \n        }),\n        /* 43 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ClippedScroller_1 = __webpack_require__(24);\n            var ScrollerCanvas_1 = __webpack_require__(25);\n            var ScrollJoiner_1 = __webpack_require__(16);\n            var ScrollFollower_1 = __webpack_require__(26);\n            var VRowGroup_1 = __webpack_require__(31);\n            var COL_MIN_WIDTH = 30;\n            var Spreadsheet = /*@__PURE__*/ (function () {\n                function Spreadsheet(view) {\n                    this.colGroupHtml = '';\n                    this.view = view;\n                    this.isRTL = this.view.opt('isRTL'); // doesn't descend from Grid, so needs to do this\n                    this.givenColWidths = this.colWidths =\n                        this.view.colSpecs.map(function (colSpec) { return colSpec.width; });\n                }\n                Spreadsheet.prototype.renderSkeleton = function () {\n                    var theme = this.view.calendar.theme;\n                    this.headScroller = new ClippedScroller_1.default({\n                        overflowX: 'clipped-scroll',\n                        overflowY: 'hidden'\n                    });\n                    this.headScroller.canvas = new ScrollerCanvas_1.default();\n                    this.headScroller.render();\n                    this.headScroller.canvas.contentEl.html(this.renderHeadHtml());\n                    this.headEl.append(this.headScroller.el);\n                    this.bodyScroller = new ClippedScroller_1.default({ overflowY: 'clipped-scroll' });\n                    this.bodyScroller.canvas = new ScrollerCanvas_1.default();\n                    this.bodyScroller.render();\n                    this.bodyScroller.canvas.contentEl.html(\"<div class=\\\"fc-rows\\\"> <table class=\\\"\" + theme.getClass('tableGrid') + \"\\\">\" + this.colGroupHtml + \"<tbody/> </table> </div>\"); // colGroupHtml hack\n                    this.tbodyEl = this.bodyScroller.canvas.contentEl.find('tbody');\n                    this.el.append(this.bodyScroller.el);\n                    this.scrollJoiner = new ScrollJoiner_1.default('horizontal', [this.headScroller, this.bodyScroller]);\n                    this.headTable = this.headEl.find('table');\n                    this.headColEls = this.headEl.find('col');\n                    this.headCellEls = this.headScroller.canvas.contentEl.find('tr:last-child th');\n                    this.bodyColEls = this.el.find('col');\n                    this.bodyTable = this.el.find('table');\n                    this.colMinWidths = this.computeColMinWidths();\n                    this.applyColWidths();\n                    this.initColResizing();\n                };\n                Spreadsheet.prototype.renderHeadHtml = function () {\n                    var theme = this.view.calendar.theme;\n                    var colSpecs = this.view.colSpecs;\n                    var html = '<table class=\"' + theme.getClass('tableGrid') + '\">';\n                    var colGroupHtml = '<colgroup>';\n                    for (var _i = 0, colSpecs_1 = colSpecs; _i < colSpecs_1.length; _i++) {\n                        var o = colSpecs_1[_i];\n                        if (o.isMain) {\n                            colGroupHtml += '<col class=\"fc-main-col\"/>';\n                        }\n                        else {\n                            colGroupHtml += '<col/>';\n                        }\n                    }\n                    colGroupHtml += '</colgroup>';\n                    this.colGroupHtml = colGroupHtml;\n                    html += colGroupHtml;\n                    html += '<tbody>';\n                    if (this.view.superHeaderText) {\n                        html +=\n                            '<tr class=\"fc-super\">' +\n                                '<th class=\"' + theme.getClass('widgetHeader') + '\" colspan=\"' + colSpecs.length + '\">' +\n                                '<div class=\"fc-cell-content\">' +\n                                '<span class=\"fc-cell-text\">' +\n                                fullcalendar_1.htmlEscape(this.view.superHeaderText) +\n                                '</span>' +\n                                '</div>' +\n                                '</th>' +\n                                '</tr>';\n                    }\n                    html += '<tr>';\n                    for (var i = 0; i < colSpecs.length; i++) {\n                        var o = colSpecs[i];\n                        var isLast = i === (colSpecs.length - 1);\n                        html +=\n                            \"<th class=\\\"\" + theme.getClass('widgetHeader') + \"\\\">\" +\n                                '<div>' +\n                                '<div class=\"fc-cell-content\">' +\n                                (o.isMain ?\n                                    '<span class=\"fc-expander-space\">' +\n                                        '<span class=\"fc-icon\"></span>' +\n                                        '</span>' :\n                                    '') +\n                                '<span class=\"fc-cell-text\">' +\n                                fullcalendar_1.htmlEscape(o.labelText || '') + // what about normalizing this value ahead of time?\n                                '</span>' +\n                                '</div>' +\n                                (!isLast ? '<div class=\"fc-col-resizer\"></div>' : '') +\n                                '</div>' +\n                                '</th>';\n                    }\n                    html += '</tr>';\n                    html += '</tbody></table>';\n                    return html;\n                };\n                Spreadsheet.prototype.initColResizing = function () {\n                    var _this = this;\n                    this.headEl.find('th .fc-col-resizer').each(function (i, resizerEl) {\n                        resizerEl = $(resizerEl);\n                        resizerEl.on('mousedown', function (ev) {\n                            _this.colResizeMousedown(i, ev, resizerEl);\n                        });\n                    });\n                };\n                Spreadsheet.prototype.colResizeMousedown = function (i, ev, resizerEl) {\n                    var _this = this;\n                    var colWidths = (this.colWidths = this.queryColWidths());\n                    colWidths.pop();\n                    colWidths.push(null); // will result in 'auto' or ''\n                    var origColWidth = colWidths[i];\n                    var minWidth = Math.min(this.colMinWidths[i], COL_MIN_WIDTH); // if given width is smaller, allow it\n                    var dragListener = new fullcalendar_1.DragListener({\n                        dragStart: function () {\n                            resizerEl.addClass('fc-active');\n                        },\n                        drag: function (dx, dy) {\n                            var width = origColWidth + (_this.isRTL ? -dx : dx);\n                            width = Math.max(width, minWidth);\n                            colWidths[i] = width;\n                            _this.applyColWidths();\n                        },\n                        dragEnd: function () {\n                            resizerEl.removeClass('fc-active');\n                        }\n                    });\n                    dragListener.startInteraction(ev);\n                };\n                Spreadsheet.prototype.applyColWidths = function () {\n                    var cssWidth;\n                    var i;\n                    var colWidth;\n                    var colMinWidths = this.colMinWidths;\n                    var colWidths = this.colWidths;\n                    var allNumbers = true;\n                    var anyPercentages = false;\n                    var total = 0;\n                    for (var _i = 0, colWidths_1 = colWidths; _i < colWidths_1.length; _i++) {\n                        colWidth = colWidths_1[_i];\n                        if (typeof colWidth === 'number') {\n                            total += colWidth;\n                        }\n                        else {\n                            allNumbers = false;\n                            if (colWidth) {\n                                anyPercentages = true;\n                            }\n                        }\n                    }\n                    // percentage widths play better with 'auto' but h-grouped cells don't\n                    var defaultCssWidth = anyPercentages && !this.view.isHGrouping ?\n                        'auto' :\n                        '';\n                    var cssWidths = colWidths.map(function (colWidth) { return (colWidth != null ? colWidth : defaultCssWidth); });\n                    // if allNumbers\n                    //    cssWidths.pop()\n                    //    cssWidths.push('auto')\n                    var tableMinWidth = 0;\n                    for (i = 0; i < cssWidths.length; i++) {\n                        cssWidth = cssWidths[i];\n                        tableMinWidth +=\n                            typeof cssWidth === 'number' ?\n                                cssWidth :\n                                colMinWidths[i];\n                    }\n                    for (i = 0; i < cssWidths.length; i++) {\n                        cssWidth = cssWidths[i];\n                        this.headColEls.eq(i).css('width', cssWidth);\n                        this.bodyColEls.eq(i).css('width', cssWidth);\n                    }\n                    this.headScroller.canvas.setMinWidth(tableMinWidth); // not really a table width anymore\n                    this.bodyScroller.canvas.setMinWidth(tableMinWidth);\n                    this.tableMinWidth = tableMinWidth;\n                    this.tableWidth = allNumbers ? total : undefined;\n                };\n                Spreadsheet.prototype.computeColMinWidths = function () {\n                    var _this = this;\n                    return this.givenColWidths.map(function (width, i) {\n                        return (typeof width === 'number' ?\n                            width :\n                            parseInt(_this.headColEls.eq(i).css('min-width'), 10) || COL_MIN_WIDTH);\n                    });\n                };\n                Spreadsheet.prototype.queryColWidths = function () {\n                    return this.headCellEls.map(function (i, node) { return ($(node).outerWidth()); }).get();\n                };\n                // Sizing\n                // ---------------------------------------------------------------------------------\n                Spreadsheet.prototype.updateSize = function () {\n                    this.headScroller.updateSize();\n                    this.bodyScroller.updateSize();\n                    this.scrollJoiner.update();\n                    this.updateCellFollower();\n                };\n                Spreadsheet.prototype.headHeight = function () {\n                    var table = this.headScroller.canvas.contentEl.find('table');\n                    return table.height.apply(table, arguments);\n                };\n                // completely reninitializes every time there's add/remove\n                // TODO: optimize\n                Spreadsheet.prototype.updateCellFollower = function () {\n                    if (this.cellFollower) {\n                        this.cellFollower.clearSprites(); // the closest thing to a destroy\n                    }\n                    this.cellFollower = new ScrollFollower_1.default(this.bodyScroller, true); // allowPointerEvents\n                    this.cellFollower.isHFollowing = false;\n                    this.cellFollower.isVFollowing = true;\n                    var nodes = [];\n                    for (var _i = 0, _a = this.view.rowHierarchy.getNodes(); _i < _a.length; _i++) {\n                        var row = _a[_i];\n                        if (row instanceof VRowGroup_1.default) {\n                            if (row.groupTd) {\n                                var cellContent = row.groupTd.find('.fc-cell-content');\n                                if (cellContent.length) {\n                                    nodes.push(cellContent[0]);\n                                }\n                            }\n                        }\n                    }\n                    this.cellFollower.setSpriteEls($(nodes));\n                    this.cellFollower.update();\n                };\n                return Spreadsheet;\n            }());\n            exports.default = Spreadsheet;\n            /***/ \n        }),\n        /* 44 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /*\n            Given a jQuery <tr> set, returns the <td>'s that do not have multi-line rowspans.\n            Would use the [rowspan] selector, but never not defined in IE8.\n            */\n            function getOwnCells(trs) {\n                return trs.find('> td').filter(function (i, tdNode) { return (tdNode.rowSpan <= 1); });\n            }\n            exports.getOwnCells = getOwnCells;\n            /***/ \n        }),\n        /* 45 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var TimelineEventRenderer_1 = __webpack_require__(17);\n            var ResourceTimelineEventRenderer = (function (_super) {\n                tslib_1.__extends(ResourceTimelineEventRenderer, _super);\n                function ResourceTimelineEventRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // don't render any fg segs\n                ResourceTimelineEventRenderer.prototype.renderFgRanges = function (eventRanges) {\n                    // subclasses can implement\n                };\n                ResourceTimelineEventRenderer.prototype.unrenderFgRanges = function () {\n                    // otherwise will try do manip DOM, js error\n                };\n                return ResourceTimelineEventRenderer;\n            }(TimelineEventRenderer_1.default));\n            exports.default = ResourceTimelineEventRenderer;\n            /***/ \n        }),\n        /* 46 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var EventRow_1 = __webpack_require__(33);\n            /*\n            A row that renders information about a particular resource, as well as it events (handled by superclass)\n            */\n            var ResourceRow = (function (_super) {\n                tslib_1.__extends(ResourceRow, _super);\n                function ResourceRow(view, resource) {\n                    var _this = _super.call(this, view) || this;\n                    _this.resource = resource;\n                    _this.eventRenderer.designatedResource = _this.resource;\n                    return _this;\n                }\n                ResourceRow.prototype.renderSkeleton = function () {\n                    _super.prototype.renderSkeleton.call(this);\n                    this.updateExpandingEnabled();\n                    if (this.eventsPayload) {\n                        EventRow_1.default.prototype.executeEventRender.call(this, this.eventsPayload);\n                    }\n                    if (this.businessHourGenerator &&\n                        this.view.dateProfile // hack\n                    ) {\n                        EventRow_1.default.prototype.renderBusinessHours.call(this, this.businessHourGenerator);\n                    }\n                    this.view.publiclyTrigger('resourceRender', {\n                        context: this.resource,\n                        args: [\n                            this.resource,\n                            this.getTr('spreadsheet').find('> td'),\n                            this.getTr('event').find('> td'),\n                            this.view\n                        ]\n                    });\n                };\n                ResourceRow.prototype.removeElement = function () {\n                    _super.prototype.removeElement.call(this);\n                    if (this.eventsPayload) {\n                        EventRow_1.default.prototype.executeEventUnrender.call(this, this.eventsPayload);\n                    }\n                    if (this.businessHourGenerator) {\n                        EventRow_1.default.prototype.unrenderBusinessHours.call(this, this.businessHourGenerator);\n                    }\n                };\n                ResourceRow.prototype.renderEventSkeleton = function (tr) {\n                    _super.prototype.renderEventSkeleton.call(this, tr);\n                    tr.attr('data-resource-id', this.resource.id);\n                };\n                ResourceRow.prototype.executeEventRender = function (eventsPayload) {\n                    this.eventsPayload = eventsPayload;\n                    if (this.get('isInDom')) {\n                        _super.prototype.executeEventRender.call(this, this.eventsPayload);\n                    }\n                };\n                ResourceRow.prototype.executeEventUnrender = function () {\n                    _super.prototype.executeEventUnrender.call(this);\n                    this.eventsPayload = null;\n                };\n                ResourceRow.prototype.renderBusinessHours = function (businessHourGenerator) {\n                    this.businessHourGenerator = businessHourGenerator;\n                    if (this.get('isInDom')) {\n                        _super.prototype.renderBusinessHours.call(this, this.businessHourGenerator);\n                    }\n                };\n                ResourceRow.prototype.unrenderBusinessHours = function () {\n                    _super.prototype.unrenderBusinessHours.call(this);\n                    this.businessHourGenerator = null;\n                };\n                /*\n                Populates the TR with cells containing data about the resource\n                */\n                ResourceRow.prototype.renderSpreadsheetSkeleton = function (tr) {\n                    var theme = this.view.calendar.theme;\n                    var resource = this.resource;\n                    for (var _i = 0, _a = this.view.colSpecs; _i < _a.length; _i++) {\n                        var colSpec = _a[_i];\n                        if (colSpec.group) {\n                            continue;\n                        }\n                        var input = colSpec.field ?\n                            resource[colSpec.field] || null :\n                            resource;\n                        var text = typeof colSpec.text === 'function' ?\n                            colSpec.text(resource, input) : // the colspec provided a text filter function\n                            input;\n                        var contentEl = $('<div class=\"fc-cell-content\">' +\n                            (colSpec.isMain ? this.renderGutterHtml() : '') +\n                            '<span class=\"fc-cell-text\">' +\n                            (text ? fullcalendar_1.htmlEscape(text) : '&nbsp;') +\n                            '</span>' +\n                            '</div>');\n                        if (typeof colSpec.render === 'function') {\n                            contentEl = colSpec.render(resource, contentEl, input) || contentEl;\n                        }\n                        var td = $('<td class=\"' + theme.getClass('widgetContent') + '\"/>')\n                            .append(contentEl);\n                        // the first cell of the row needs to have an inner div for setTrInnerHeight\n                        if (colSpec.isMain) {\n                            td.wrapInner('<div/>');\n                        }\n                        tr.append(td);\n                    }\n                    tr.attr('data-resource-id', resource.id);\n                };\n                /*\n                Renders the HTML responsible for the subrow expander area,\n                as well as the space before it (used to align expanders of similar depths)\n                */\n                ResourceRow.prototype.renderGutterHtml = function () {\n                    var html = '';\n                    var depth = this.depth;\n                    for (var i = 0; i < depth; i++) {\n                        html += '<span class=\"fc-icon\"/>';\n                    }\n                    html +=\n                        '<span class=\"fc-expander-space\">' +\n                            '<span class=\"fc-icon\"></span>' +\n                            '</span>';\n                    return html;\n                };\n                return ResourceRow;\n            }(EventRow_1.default));\n            exports.default = ResourceRow;\n            /***/ \n        }),\n        /* 47 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var RowGroup_1 = __webpack_require__(32);\n            /*\n            A row grouping that renders as a single solid row that spans width-wise (like a horizontal rule)\n            */\n            var HRowGroup = (function (_super) {\n                tslib_1.__extends(HRowGroup, _super);\n                function HRowGroup() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                HRowGroup.prototype.renderSkeleton = function () {\n                    _super.prototype.renderSkeleton.call(this);\n                    this.updateExpandingEnabled();\n                };\n                /*\n                Renders this row's TR for the \"spreadsheet\" quadrant, the area with info about each resource\n                */\n                HRowGroup.prototype.renderSpreadsheetSkeleton = function (tr) {\n                    var contentEl = this.renderGroupContentEl();\n                    // add an expander icon. binding handlers and updating are done by RowParent\n                    contentEl.prepend('<span class=\"fc-expander\">' +\n                        '<span class=\"fc-icon\"></span>' +\n                        '</span>');\n                    return $('<td class=\"fc-divider\" />')\n                        .attr('colspan', this.view.colSpecs.length) // span across all columns\n                        .append($('<div/>').append(contentEl) // needed by setTrInnerHeight\n                    )\n                        .appendTo(tr);\n                };\n                /*\n                Renders this row's TR for the quadrant that contains a resource's events\n                */\n                HRowGroup.prototype.renderEventSkeleton = function (tr) {\n                    // insert a single cell, with a single empty <div> (needed by setTrInnerHeight).\n                    // there will be no content\n                    return tr.append(\"<td class=\\\"fc-divider\\\"> <div/> </td>\");\n                };\n                return HRowGroup;\n            }(RowGroup_1.default));\n            exports.default = HRowGroup;\n            HRowGroup.prototype.hasOwnRow = true; // actually renders its own row and takes up height\n            /***/ \n        }),\n        /* 48 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var Resource_1 = __webpack_require__(19);\n            var ResourceManager_1 = __webpack_require__(49);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            // NOTE: for public methods, always be sure of the return value. for chaining\n            var origMethods = {\n                constructed: fullcalendar_1.Calendar.prototype.constructed,\n                buildSelectFootprint: fullcalendar_1.Calendar.prototype.buildSelectFootprint\n            };\n            // option defaults\n            fullcalendar_1.Calendar.defaults.refetchResourcesOnNavigate = false;\n            fullcalendar_1.Calendar.defaults.filterResourcesWithEvents = false;\n            fullcalendar_1.Calendar.prototype.resourceManager = null;\n            fullcalendar_1.Calendar.prototype.constructed = function () {\n                origMethods.constructed.apply(this, arguments);\n                this.resourceManager = new ResourceManager_1.default(this);\n            };\n            fullcalendar_1.Calendar.prototype.instantiateView = function (viewType) {\n                var spec = this.viewSpecManager.getViewSpec(viewType);\n                var viewClass = spec['class'];\n                if (this.opt('resources') && (spec.options.resources !== false)) {\n                    if (spec.queryResourceClass) {\n                        viewClass = spec.queryResourceClass(spec) || viewClass; // might return falsy\n                    }\n                    else if (spec.resourceClass) {\n                        viewClass = spec.resourceClass;\n                    }\n                }\n                return new viewClass(this, spec);\n            };\n            // for the API only\n            // retrieves what is currently in memory. no fetching\n            fullcalendar_1.Calendar.prototype.getResources = function () {\n                return Array.prototype.slice.call(// make a copy\n                this.resourceManager.topLevelResources);\n            };\n            // assumes all resources already loaded\n            fullcalendar_1.Calendar.prototype.addResource = function (resourceInput, scroll) {\n                var _this = this;\n                if (scroll === void 0) {\n                    scroll = false;\n                }\n                this.resourceManager.addResource(resourceInput)\n                    .then(function (resource) {\n                    if (scroll && _this.view.scrollToResource) {\n                        return _this.view.scrollToResource(resource);\n                    }\n                });\n            };\n            // assumes all resources already loaded\n            fullcalendar_1.Calendar.prototype.removeResource = function (idOrResource) {\n                return this.resourceManager.removeResource(idOrResource);\n            };\n            fullcalendar_1.Calendar.prototype.refetchResources = function () {\n                this.resourceManager.clear();\n                this.view.flash('initialResources');\n            };\n            fullcalendar_1.Calendar.prototype.rerenderResources = function () {\n                this.resourceManager.resetCurrentResources();\n            };\n            fullcalendar_1.Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput, resourceId) {\n                var plainFootprint = origMethods.buildSelectFootprint.apply(this, arguments);\n                if (resourceId) {\n                    return new ResourceComponentFootprint_1.default(plainFootprint.unzonedRange, plainFootprint.isAllDay, resourceId);\n                }\n                else {\n                    return plainFootprint;\n                }\n            };\n            fullcalendar_1.Calendar.prototype.getResourceById = function (id) {\n                return this.resourceManager.getResourceById(id);\n            };\n            // Resources + Events\n            // ----------------------------------------------------------------------------------------\n            // DEPRECATED. for external API backwards compatibility\n            fullcalendar_1.Calendar.prototype.getEventResourceId = function (event) {\n                return this.getEventResourceIds(event)[0];\n            };\n            fullcalendar_1.Calendar.prototype.getEventResourceIds = function (event) {\n                var eventDef = this.eventManager.getEventDefByUid(event._id);\n                if (eventDef) {\n                    return eventDef.getResourceIds();\n                }\n                else {\n                    return [];\n                }\n            };\n            // DEPRECATED\n            fullcalendar_1.Calendar.prototype.setEventResourceId = function (event, resourceId) {\n                this.setEventResourceIds(event, resourceId ? [resourceId] : []);\n            };\n            fullcalendar_1.Calendar.prototype.setEventResourceIds = function (event, resourceIds) {\n                var eventDef = this.eventManager.getEventDefByUid(event._id);\n                if (eventDef) {\n                    eventDef.resourceIds = resourceIds.map(function (rawResourceId) {\n                        return Resource_1.default.normalizeId(rawResourceId);\n                    });\n                }\n            };\n            // NOTE: views pair *segments* to resources. that's why there's no code reuse\n            fullcalendar_1.Calendar.prototype.getResourceEvents = function (idOrResource) {\n                var _this = this;\n                var resource = typeof idOrResource === 'object' ?\n                    idOrResource :\n                    this.getResourceById(idOrResource);\n                if (resource) {\n                    // return the event cache, filtered by events assigned to the resource\n                    // TODO: move away from using clientId\n                    return this.clientEvents(function (event) {\n                        return $.inArray(resource.id, _this.getEventResourceIds(event)) !== -1;\n                    });\n                }\n                else {\n                    return [];\n                }\n            };\n            // DEPRECATED. for external API backwards compatibility\n            fullcalendar_1.Calendar.prototype.getEventResource = function (idOrEvent) {\n                return this.getEventResources(idOrEvent)[0];\n            };\n            fullcalendar_1.Calendar.prototype.getEventResources = function (idOrEvent) {\n                var event = typeof idOrEvent === 'object' ?\n                    idOrEvent :\n                    this.clientEvents(idOrEvent)[0];\n                var resources = [];\n                if (event) {\n                    for (var _i = 0, _a = this.getEventResourceIds(event); _i < _a.length; _i++) {\n                        var resourceId = _a[_i];\n                        var resource = this.getResourceById(resourceId);\n                        if (resource) {\n                            resources.push(resource);\n                        }\n                    }\n                }\n                return resources;\n            };\n            /***/ \n        }),\n        /* 49 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(1);\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceManager = (function (_super) {\n                tslib_1.__extends(ResourceManager, _super);\n                function ResourceManager(calendar) {\n                    var _this = _super.call(this) || this;\n                    _this.fetchId = 0;\n                    _this.calendar = calendar;\n                    _this.initializeCache();\n                    return _this;\n                }\n                // Resource Data Getting\n                // ------------------------------------------------------------------------------------------------------------------\n                /*\n                Like fetchResources, but won't refetch if already fetched.\n                */\n                ResourceManager.prototype.getResources = function (start, end) {\n                    var isSameRange = (!start && !this.currentStart) || // both nonexistent ranges?\n                        (start && this.currentStart && start.isSame(this.currentStart) && end.isSame(this.currentEnd));\n                    if (!this.fetching || !isSameRange) {\n                        return this.fetchResources(start, end);\n                    }\n                    else {\n                        return this.fetching;\n                    }\n                };\n                /*\n                Will always fetch, even if done previously.\n                Accepts optional chrono-related params to pass on to the raw resource sources.\n                Returns a promise.\n                */\n                ResourceManager.prototype.fetchResources = function (start, end) {\n                    var _this = this;\n                    var currentFetchId = (this.fetchId += 1);\n                    return this.fetching =\n                        fullcalendar_1.Promise.construct(function (resolve, reject) {\n                            _this.fetchResourceInputs(function (resourceInputs) {\n                                if (currentFetchId === _this.fetchId) {\n                                    _this.setResources(resourceInputs);\n                                    return resolve(_this.topLevelResources);\n                                }\n                                else {\n                                    return reject();\n                                }\n                            }, start, end);\n                        });\n                };\n                /*\n                Accepts optional chrono-related params to pass on to the raw resource sources.\n                Calls callback when done.\n                */\n                ResourceManager.prototype.fetchResourceInputs = function (callback, start, end) {\n                    var _this = this;\n                    var calendar = this.calendar;\n                    var source = calendar.opt('resources');\n                    var timezone = calendar.opt('timezone');\n                    if ($.type(source) === 'string') {\n                        source = { url: source };\n                    }\n                    switch ($.type(source)) {\n                        case 'function':\n                            this.calendar.pushLoading();\n                            source(function (resourceInputs) {\n                                _this.calendar.popLoading();\n                                callback(resourceInputs);\n                            }, start, end, calendar.opt('timezone'));\n                            break;\n                        case 'object':\n                            calendar.pushLoading();\n                            var requestParams = {};\n                            if (start && end) {\n                                requestParams[calendar.opt('startParam')] = start.format();\n                                requestParams[calendar.opt('endParam')] = end.format();\n                                // mimick what EventManager does\n                                // TODO: more DRY\n                                if (timezone && (timezone !== 'local')) {\n                                    requestParams[calendar.opt('timezoneParam')] = timezone;\n                                }\n                            }\n                            $.ajax(// TODO: handle failure\n                            $.extend({ data: requestParams }, ResourceManager.ajaxDefaults, source)).then(function (resourceInputs) {\n                                calendar.popLoading();\n                                callback(resourceInputs);\n                            });\n                            break;\n                        case 'array':\n                            callback(source);\n                            break;\n                        default:\n                            callback([]);\n                            break;\n                    }\n                };\n                ResourceManager.prototype.getResourceById = function (id) {\n                    return this.resourcesById[id];\n                };\n                // assumes already completed fetch\n                // does not guarantee order\n                ResourceManager.prototype.getFlatResources = function () {\n                    var result = [];\n                    for (var id in this.resourcesById) {\n                        result.push(this.resourcesById[id]);\n                    }\n                    return result;\n                };\n                // Resource Adding\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceManager.prototype.initializeCache = function () {\n                    this.topLevelResources = [];\n                    this.resourcesById = {};\n                };\n                ResourceManager.prototype.setResources = function (resourceInputs) {\n                    var _this = this;\n                    var resource;\n                    var wasSet = Boolean(this.topLevelResources);\n                    this.initializeCache();\n                    var resources = resourceInputs.map(function (resourceInput) { return (_this.buildResource(resourceInput)); });\n                    var validResources = [];\n                    for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {\n                        resource = resources_1[_i];\n                        if (this.addResourceToIndex(resource)) {\n                            validResources.push(resource);\n                        }\n                    }\n                    for (var _a = 0, validResources_1 = validResources; _a < validResources_1.length; _a++) {\n                        resource = validResources_1[_a];\n                        this.addResourceToTree(resource);\n                    }\n                    if (wasSet) {\n                        this.trigger('reset', this.topLevelResources);\n                    }\n                    else {\n                        this.trigger('set', this.topLevelResources);\n                    }\n                    this.calendar.publiclyTrigger('resourcesSet', [this.topLevelResources]);\n                };\n                ResourceManager.prototype.resetCurrentResources = function () {\n                    if (this.topLevelResources) {\n                        this.trigger('reset', this.topLevelResources);\n                    }\n                };\n                ResourceManager.prototype.clear = function () {\n                    this.topLevelResources = null;\n                    this.fetching = null;\n                };\n                ResourceManager.prototype.addResource = function (resourceInput) {\n                    var _this = this;\n                    if (this.fetching) {\n                        return this.fetching.then(function () {\n                            var resource = _this.buildResource(resourceInput);\n                            if (_this.addResourceToIndex(resource)) {\n                                _this.addResourceToTree(resource);\n                                _this.trigger('add', resource, _this.topLevelResources);\n                                return resource;\n                            }\n                            else {\n                                return false;\n                            }\n                        });\n                    }\n                    else {\n                        return fullcalendar_1.Promise.reject();\n                    }\n                };\n                ResourceManager.prototype.addResourceToIndex = function (resource) {\n                    if (this.resourcesById[resource.id]) {\n                        return false;\n                    }\n                    else {\n                        this.resourcesById[resource.id] = resource;\n                        for (var _i = 0, _a = resource.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            this.addResourceToIndex(child);\n                        }\n                        return true;\n                    }\n                };\n                ResourceManager.prototype.addResourceToTree = function (resource) {\n                    if (!resource.parent) {\n                        var siblings = void 0;\n                        var parentId = String(resource['parentId'] != null ? resource['parentId'] : '');\n                        if (parentId) {\n                            var parent_1 = this.resourcesById[parentId];\n                            if (parent_1) {\n                                resource.parent = parent_1;\n                                siblings = parent_1.children;\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n                        else {\n                            siblings = this.topLevelResources;\n                        }\n                        siblings.push(resource);\n                    }\n                    return true;\n                };\n                // Resource Removing\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceManager.prototype.removeResource = function (idOrResource) {\n                    var _this = this;\n                    var id = typeof idOrResource === 'object' ?\n                        idOrResource.id :\n                        idOrResource;\n                    if (this.fetching) {\n                        return this.fetching.then(function () {\n                            var resource = _this.removeResourceFromIndex(id);\n                            if (resource) {\n                                _this.removeResourceFromTree(resource);\n                                _this.trigger('remove', resource, _this.topLevelResources);\n                            }\n                            return resource;\n                        });\n                    }\n                    else {\n                        return fullcalendar_1.Promise.reject();\n                    }\n                };\n                ResourceManager.prototype.removeResourceFromIndex = function (resourceId) {\n                    var resource = this.resourcesById[resourceId];\n                    if (resource) {\n                        delete this.resourcesById[resourceId];\n                        for (var _i = 0, _a = resource.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            this.removeResourceFromIndex(child.id);\n                        }\n                        return resource;\n                    }\n                    else {\n                        return false;\n                    }\n                };\n                ResourceManager.prototype.removeResourceFromTree = function (resource, siblings) {\n                    if (siblings === void 0) {\n                        siblings = this.topLevelResources;\n                    }\n                    for (var i = 0; i < siblings.length; i++) {\n                        var sibling = siblings[i];\n                        if (sibling === resource) {\n                            resource.parent = null;\n                            siblings.splice(i, 1);\n                            return true;\n                        }\n                        if (this.removeResourceFromTree(resource, sibling.children)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                // Resource Data Utils\n                // ------------------------------------------------------------------------------------------------------------------\n                ResourceManager.prototype.buildResource = function (resourceInput) {\n                    var _this = this;\n                    var resource = $.extend({}, resourceInput);\n                    var rawClassName = resourceInput.eventClassName;\n                    resource.id = String(resourceInput.id != null ?\n                        resourceInput.id :\n                        '_fc' + (ResourceManager.resourceGuid++));\n                    // TODO: consolidate repeat logic\n                    resource.eventClassName = (function () {\n                        switch ($.type(rawClassName)) {\n                            case 'string':\n                                return rawClassName.split(/\\s+/);\n                            case 'array':\n                                return rawClassName;\n                            default:\n                                return [];\n                        }\n                    })();\n                    if (resourceInput.businessHours) {\n                        resource.businessHourGenerator = new fullcalendar_1.BusinessHourGenerator(resourceInput.businessHours, this.calendar);\n                    }\n                    resource.children = (resourceInput.children || []).map(function (childInput) {\n                        var child = _this.buildResource(childInput);\n                        child.parent = resource;\n                        return child;\n                    });\n                    return resource;\n                };\n                ResourceManager.resourceGuid = 1;\n                ResourceManager.ajaxDefaults = {\n                    dataType: 'json',\n                    cache: false\n                };\n                return ResourceManager;\n            }(fullcalendar_1.Class));\n            exports.default = ResourceManager;\n            fullcalendar_1.EmitterMixin.mixInto(ResourceManager);\n            /***/ \n        }),\n        /* 50 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var Resource_1 = __webpack_require__(19);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            var origMethods = {\n                getPeerEventInstances: fullcalendar_1.Constraints.prototype.getPeerEventInstances,\n                isFootprintAllowed: fullcalendar_1.Constraints.prototype.isFootprintAllowed,\n                buildCurrentBusinessFootprints: fullcalendar_1.Constraints.prototype.buildCurrentBusinessFootprints,\n                footprintContainsFootprint: fullcalendar_1.Constraints.prototype.footprintContainsFootprint,\n                footprintsIntersect: fullcalendar_1.Constraints.prototype.footprintsIntersect,\n                eventRangeToEventFootprints: fullcalendar_1.Constraints.prototype.eventRangeToEventFootprints,\n                parseFootprints: fullcalendar_1.Constraints.prototype.parseFootprints\n            };\n            fullcalendar_1.Constraints.prototype.getPeerEventInstances = function (subjectEventDef) {\n                var subjectResourceIds = subjectEventDef.getResourceIds();\n                var peerInstances = origMethods.getPeerEventInstances.apply(this, arguments);\n                if (!subjectResourceIds.length) {\n                    return peerInstances;\n                }\n                else {\n                    return peerInstances.filter(function (peerInstance) {\n                        // always consider non-resource events to be peers\n                        if (!peerInstance.def.resourceIds.length) {\n                            return true;\n                        }\n                        // has same resource? consider it a peer\n                        for (var _i = 0, subjectResourceIds_1 = subjectResourceIds; _i < subjectResourceIds_1.length; _i++) {\n                            var resourceId = subjectResourceIds_1[_i];\n                            if (peerInstance.def.hasResourceId(resourceId)) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    });\n                }\n            };\n            // enforce resource ID constraint\n            fullcalendar_1.Constraints.prototype.isFootprintAllowed = function (footprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance) {\n                if (typeof constraintVal === 'object') {\n                    var constrainToResourceIds = Resource_1.default.extractIds(constraintVal, this);\n                    if (constrainToResourceIds.length && (!(footprint instanceof ResourceComponentFootprint_1.default) ||\n                        $.inArray(footprint.resourceId, constrainToResourceIds) === -1)) {\n                        return false;\n                    }\n                }\n                return origMethods.isFootprintAllowed.apply(this, arguments);\n            };\n            fullcalendar_1.Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {\n                var flatResources = this._calendar.resourceManager.getFlatResources();\n                var anyCustomBusinessHours = false;\n                // any per-resource business hours? or will one global businessHours suffice?\n                for (var _i = 0, flatResources_1 = flatResources; _i < flatResources_1.length; _i++) {\n                    var resource = flatResources_1[_i];\n                    if (resource.businessHourGenerator) {\n                        anyCustomBusinessHours = true;\n                    }\n                }\n                // if there are any custom business hours, all business hours must be sliced per-resources\n                if (anyCustomBusinessHours) {\n                    var view = this._calendar.view;\n                    var generalBusinessHourGenerator = view.get('businessHourGenerator');\n                    var unzonedRange = view.dateProfile.activeUnzonedRange;\n                    var componentFootprints = [];\n                    for (var _a = 0, flatResources_2 = flatResources; _a < flatResources_2.length; _a++) {\n                        var resource = flatResources_2[_a];\n                        var businessHourGenerator = resource.businessHourGenerator || generalBusinessHourGenerator;\n                        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);\n                        if (eventInstanceGroup) {\n                            for (var _b = 0, _c = eventInstanceGroup.getAllEventRanges(); _b < _c.length; _b++) {\n                                var eventRange = _c[_b];\n                                componentFootprints.push(new ResourceComponentFootprint_1.default(eventRange.unzonedRange, isAllDay, // isAllDay\n                                resource.id));\n                            }\n                        }\n                    }\n                    return componentFootprints;\n                }\n                else {\n                    return origMethods.buildCurrentBusinessFootprints.apply(this, arguments);\n                }\n            };\n            fullcalendar_1.Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {\n                if (outerFootprint instanceof ResourceComponentFootprint_1.default &&\n                    (!(innerFootprint instanceof ResourceComponentFootprint_1.default) ||\n                        (innerFootprint.resourceId !== outerFootprint.resourceId))) {\n                    return false;\n                }\n                return origMethods.footprintContainsFootprint.apply(this, arguments);\n            };\n            fullcalendar_1.Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {\n                if (footprint0 instanceof ResourceComponentFootprint_1.default &&\n                    footprint1 instanceof ResourceComponentFootprint_1.default &&\n                    (footprint0.resourceId !== footprint1.resourceId)) {\n                    return false;\n                }\n                return origMethods.footprintsIntersect.apply(this, arguments);\n            };\n            /*\n            TODO: somehow more DRY with DateComponent::eventRangeToEventFootprints monkeypatch\n            */\n            fullcalendar_1.Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {\n                var eventDef = eventRange.eventDef;\n                var resourceIds = eventDef.getResourceIds();\n                if (resourceIds.length) {\n                    return resourceIds.map(function (resourceId) {\n                        return (new fullcalendar_1.EventFootprint(new ResourceComponentFootprint_1.default(eventRange.unzonedRange, eventDef.isAllDay(), resourceId), eventDef, eventRange.eventInstance // might not exist\n                        ));\n                    });\n                }\n                else {\n                    return origMethods.eventRangeToEventFootprints.apply(this, arguments);\n                }\n            };\n            fullcalendar_1.Constraints.prototype.parseFootprints = function (input) {\n                var plainFootprints = origMethods.parseFootprints.apply(this, arguments);\n                var resourceIds = input.resourceIds || [];\n                if (input.resourceId) {\n                    resourceIds = [input.resourceId].concat(resourceIds);\n                }\n                if (resourceIds.length) {\n                    var footprints = [];\n                    for (var _i = 0, resourceIds_1 = resourceIds; _i < resourceIds_1.length; _i++) {\n                        var resourceId = resourceIds_1[_i];\n                        for (var _a = 0, plainFootprints_1 = plainFootprints; _a < plainFootprints_1.length; _a++) {\n                            var plainFootprint = plainFootprints_1[_a];\n                            footprints.push(new ResourceComponentFootprint_1.default(plainFootprint.unzonedRange, plainFootprint.isAllDay, resourceId));\n                        }\n                    }\n                    return footprints;\n                }\n                else {\n                    return plainFootprints;\n                }\n            };\n            /***/ \n        }),\n        /* 51 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var license_1 = __webpack_require__(52);\n            // pre-monkeypatch methods\n            var origMethods = {\n                setElement: fullcalendar_1.View.prototype.setElement,\n                removeElement: fullcalendar_1.View.prototype.removeElement,\n                triggerViewRender: fullcalendar_1.View.prototype.triggerViewRender\n            };\n            // new properties\n            fullcalendar_1.View.prototype.canHandleSpecificResources = false;\n            // View Rendering\n            // --------------------------------------------------------------------------------------------------\n            fullcalendar_1.View.prototype.setElement = function () {\n                origMethods.setElement.apply(this, arguments);\n                this.watchResources(); // do after have the el, because might render, which assumes a render skeleton\n            };\n            fullcalendar_1.View.prototype.removeElement = function () {\n                this.unwatchResources();\n                origMethods.removeElement.apply(this, arguments);\n            };\n            // Show the warning even for non-resource views\n            // inject license key before 'viewRender' which is called by super's afterBaseDisplay\n            fullcalendar_1.View.prototype.triggerViewRender = function () {\n                license_1.processLicenseKey(this.opt('schedulerLicenseKey'), this.el // container element\n                );\n                origMethods.triggerViewRender.apply(this, arguments);\n            };\n            // Resource Binding\n            // --------------------------------------------------------------------------------------------------\n            fullcalendar_1.View.prototype.watchResources = function () {\n                var _this = this;\n                var initialDepNames = [];\n                var bindingDepNames = ['initialResources'];\n                if (this.opt('refetchResourcesOnNavigate')) {\n                    initialDepNames.push('dateProfile');\n                }\n                if (this.opt('filterResourcesWithEvents')) {\n                    bindingDepNames.push('currentEvents');\n                }\n                this.watch('initialResources', initialDepNames, function (deps) {\n                    return _this.getInitialResources(deps.dateProfile); // promise\n                });\n                this.watch('bindingResources', bindingDepNames, function (deps) {\n                    _this.bindResourceChanges(deps.currentEvents);\n                    _this.setResources(deps.initialResources, deps.currentEvents);\n                }, function () {\n                    _this.unbindResourceChanges();\n                    _this.unsetResources();\n                });\n            };\n            fullcalendar_1.View.prototype.unwatchResources = function () {\n                this.unwatch('initialResources');\n                this.unwatch('bindingResources');\n            };\n            // dateProfile is optional\n            fullcalendar_1.View.prototype.getInitialResources = function (dateProfile) {\n                var calendar = this.calendar;\n                if (dateProfile) {\n                    return calendar.resourceManager.getResources(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay));\n                }\n                else {\n                    return calendar.resourceManager.getResources();\n                }\n            };\n            // eventsPayload is optional\n            fullcalendar_1.View.prototype.bindResourceChanges = function (eventsPayload) {\n                var _this = this;\n                this.listenTo(this.calendar.resourceManager, {\n                    set: function (resources) {\n                        _this.setResources(resources, eventsPayload);\n                    },\n                    unset: function () {\n                        _this.unsetResources();\n                    },\n                    reset: function (resources) {\n                        _this.resetResources(resources, eventsPayload);\n                    },\n                    add: function (resource, allResources) {\n                        _this.addResource(resource, allResources, eventsPayload);\n                    },\n                    remove: function (resource, allResources) {\n                        _this.removeResource(resource, allResources, eventsPayload);\n                    }\n                });\n            };\n            fullcalendar_1.View.prototype.unbindResourceChanges = function () {\n                this.stopListeningTo(this.calendar.resourceManager);\n            };\n            // Event Rendering\n            // --------------------------------------------------------------------------------------------------\n            fullcalendar_1.View.watch('displayingEvents', ['displayingDates', 'hasEvents', 'currentResources'], function (deps) {\n                this.requestEventsRender(this.get('currentEvents'));\n            }, function () {\n                this.requestEventsUnrender();\n            });\n            // Resource Data\n            // --------------------------------------------------------------------------------------------------\n            // currentEvents is optional\n            fullcalendar_1.View.prototype.setResources = function (resources, eventsPayload) {\n                if (eventsPayload) {\n                    resources = this.filterResourcesWithEvents(resources, eventsPayload);\n                }\n                this.set('currentResources', resources);\n                this.set('hasResources', true);\n            };\n            fullcalendar_1.View.prototype.unsetResources = function () {\n                this.unset('currentResources');\n                this.unset('hasResources');\n            };\n            // eventsPayload is optional\n            fullcalendar_1.View.prototype.resetResources = function (resources, eventsPayload) {\n                this.startBatchRender();\n                this.unsetResources();\n                this.setResources(resources, eventsPayload);\n                this.stopBatchRender();\n            };\n            // eventsPayload is optional\n            fullcalendar_1.View.prototype.addResource = function (resource, allResources, eventsPayload) {\n                if (!this.canHandleSpecificResources) {\n                    this.resetResources(allResources, eventsPayload);\n                    return;\n                }\n                if (eventsPayload) {\n                    var a = this.filterResourcesWithEvents([resource], eventsPayload);\n                    if (!a.length) {\n                        resource = null;\n                    }\n                }\n                if (resource) {\n                    this.set('currentResources', allResources); // TODO: filter against eventsPayload?\n                    this.handleResourceAdd(resource);\n                }\n            };\n            fullcalendar_1.View.prototype.removeResource = function (resource, allResources, eventsPayload) {\n                if (!this.canHandleSpecificResources) {\n                    this.resetResources(allResources, eventsPayload);\n                    return;\n                }\n                this.set('currentResources', allResources); // TODO: filter against eventsPayload?\n                this.handleResourceRemove(resource);\n            };\n            // Resource Change Handling\n            // --------------------------------------------------------------------------------------------------\n            fullcalendar_1.View.prototype.handleResourceAdd = function (resource) {\n                // subclasses should implement\n            };\n            fullcalendar_1.View.prototype.handleResourceRemove = function (resource) {\n                // subclasses should implement\n            };\n            // Resource Filtering\n            // ------------------------------------------------------------------------------------------------------------------\n            fullcalendar_1.View.prototype.filterResourcesWithEvents = function (resources, eventsPayload) {\n                var eventRanges = this.eventsPayloadToRanges(eventsPayload);\n                var resourceIdHits = {};\n                for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n                    var eventRange = eventRanges_1[_i];\n                    for (var _a = 0, _b = eventRange.eventDef.getResourceIds(); _a < _b.length; _a++) {\n                        var resourceId = _b[_a];\n                        resourceIdHits[resourceId] = true;\n                    }\n                }\n                return _filterResourcesWithEvents(resources, resourceIdHits);\n            };\n            fullcalendar_1.View.prototype.eventsPayloadToRanges = function (eventsPayload) {\n                var dateProfile = this._getDateProfile();\n                var allEventRanges = [];\n                for (var eventDefId in eventsPayload) {\n                    var instanceGroup = eventsPayload[eventDefId];\n                    var eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);\n                    allEventRanges.push.apply(allEventRanges, (eventRanges || []));\n                }\n                return allEventRanges;\n            };\n            // provides a new structure with masked objects\n            function _filterResourcesWithEvents(sourceResources, resourceIdHits) {\n                var filteredResources = [];\n                for (var _i = 0, sourceResources_1 = sourceResources; _i < sourceResources_1.length; _i++) {\n                    var sourceResource = sourceResources_1[_i];\n                    if (sourceResource.children.length) {\n                        var filteredChildren = _filterResourcesWithEvents(sourceResource.children, resourceIdHits);\n                        if (filteredChildren.length || resourceIdHits[sourceResource.id]) {\n                            var filteredResource = Object.create(sourceResource); // mask\n                            filteredResource.children = filteredChildren;\n                            filteredResources.push(filteredResource);\n                        }\n                    }\n                    else {\n                        if (resourceIdHits[sourceResource.id]) {\n                            filteredResources.push(sourceResource);\n                        }\n                    }\n                }\n                return filteredResources;\n            }\n            /***/ \n        }),\n        /* 52 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var moment = __webpack_require__(15);\n            var exportHooks = __webpack_require__(0);\n            var RELEASE_DATE = '2018-03-28'; // for Scheduler\n            var UPGRADE_WINDOW = { years: 1, weeks: 1 }; // 1 week leeway, for tz shift reasons too\n            var LICENSE_INFO_URL = 'http://fullcalendar.io/scheduler/license/';\n            var PRESET_LICENSE_KEYS = [\n                'GPL-My-Project-Is-Open-Source',\n                'CC-Attribution-NonCommercial-NoDerivatives'\n            ];\n            function processLicenseKey(key, containerEl) {\n                if (!isImmuneUrl(window.location.href) && !isValidKey(key)) {\n                    if (!detectWarningInContainer(containerEl)) {\n                        return renderingWarningInContainer('Please use a valid license key. <a href=\"' + LICENSE_INFO_URL + '\">More Info</a>', containerEl);\n                    }\n                }\n            }\n            exports.processLicenseKey = processLicenseKey;\n            /*\n            This decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\n            */\n            function isValidKey(key) {\n                if ($.inArray(key, PRESET_LICENSE_KEYS) !== -1) {\n                    return true;\n                }\n                var parts = (key || '').match(/^(\\d+)\\-fcs\\-(\\d+)$/);\n                if (parts && (parts[1].length === 10)) {\n                    var purchaseDate = moment.utc(parseInt(parts[2], 10) * 1000);\n                    var releaseDate = moment.utc(exportHooks.mockSchedulerReleaseDate || RELEASE_DATE);\n                    if (releaseDate.isValid()) {\n                        var minPurchaseDate = releaseDate.clone().subtract(UPGRADE_WINDOW);\n                        if (purchaseDate.isAfter(minPurchaseDate)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            exports.isValidKey = isValidKey;\n            function isImmuneUrl(url) {\n                return /\\w+\\:\\/\\/fullcalendar\\.io\\/|\\/demos\\/[\\w-]+\\.html$/.test(url);\n            }\n            exports.isImmuneUrl = isImmuneUrl;\n            function renderingWarningInContainer(messageHtml, containerEl) {\n                return containerEl.append($('<div class=\"fc-license-message\" />').html(messageHtml));\n            }\n            exports.renderingWarningInContainer = renderingWarningInContainer;\n            // returns boolean of whether a license message is already rendered\n            function detectWarningInContainer(containerEl) {\n                return containerEl.find('.fc-license-message').length >= 1;\n            }\n            exports.detectWarningInContainer = detectWarningInContainer;\n            /***/ \n        }),\n        /* 53 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                eventRangeToEventFootprints: fullcalendar_1.DateComponent.prototype.eventRangeToEventFootprints\n            };\n            // configuration for subclasses\n            fullcalendar_1.DateComponent.prototype.isResourceFootprintsEnabled = false;\n            fullcalendar_1.DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {\n                if (!this.isResourceFootprintsEnabled) {\n                    return origMethods.eventRangeToEventFootprints.apply(this, arguments);\n                }\n                else {\n                    var eventDef_1 = eventRange.eventDef;\n                    var resourceIds = eventDef_1.getResourceIds();\n                    if (resourceIds.length) {\n                        return resourceIds.map(function (resourceId) {\n                            return (new fullcalendar_1.EventFootprint(new ResourceComponentFootprint_1.default(eventRange.unzonedRange, eventDef_1.isAllDay(), resourceId), eventDef_1, eventRange.eventInstance // might not exist\n                            ));\n                        });\n                    }\n                    else if (eventDef_1.hasBgRendering()) {\n                        return origMethods.eventRangeToEventFootprints.apply(this, arguments);\n                    }\n                    else {\n                        return [];\n                    }\n                }\n            };\n            // Resource Low-level Rendering\n            // ----------------------------------------------------------------------------------------------\n            // ResourceViewMixin wires these up\n            fullcalendar_1.DateComponent.prototype.renderResources = function (resources) {\n                this.callChildren('renderResources', arguments);\n            };\n            fullcalendar_1.DateComponent.prototype.unrenderResources = function () {\n                this.callChildren('unrenderResources', arguments);\n            };\n            fullcalendar_1.DateComponent.prototype.renderResource = function (resource) {\n                this.callChildren('renderResource', arguments);\n            };\n            fullcalendar_1.DateComponent.prototype.unrenderResource = function (resource) {\n                this.callChildren('unrenderResource', arguments);\n            };\n            /***/ \n        }),\n        /* 54 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                isEventDefDraggable: fullcalendar_1.InteractiveDateComponent.prototype.isEventDefDraggable\n            };\n            // configuration for subclasses\n            // whether we should attempt to render selections or resizes that span across different resources\n            fullcalendar_1.InteractiveDateComponent.prototype.allowCrossResource = true;\n            // ^ is this worth the complexity?\n            // if an event's dates are not draggable, but it's resource IS, still allow dragging\n            fullcalendar_1.InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {\n                return this.isEventDefResourceEditable(eventDef) ||\n                    origMethods.isEventDefDraggable.call(this, eventDef);\n            };\n            fullcalendar_1.InteractiveDateComponent.prototype.isEventDefResourceEditable = function (eventDef) {\n                var bool = eventDef.resourceEditable;\n                if (bool == null) {\n                    bool = (eventDef.source || {}).resourceEditable;\n                    if (bool == null) {\n                        bool = this.opt('eventResourceEditable');\n                        if (bool == null) {\n                            bool = this.isEventDefGenerallyEditable(eventDef);\n                        }\n                    }\n                }\n                return bool;\n            };\n            /***/ \n        }),\n        /* 55 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                getFallbackStylingObjs: fullcalendar_1.EventRenderer.prototype.getFallbackStylingObjs\n            };\n            fullcalendar_1.EventRenderer.prototype.designatedResource = null; // optionally set by caller. forces @currentResource\n            fullcalendar_1.EventRenderer.prototype.currentResource = null; // when set, will affect future rendered segs\n            fullcalendar_1.EventRenderer.prototype.beforeFgSegHtml = function (seg) {\n                var segResourceId = seg.footprint.componentFootprint.resourceId;\n                if (this.designatedResource) {\n                    this.currentResource = this.designatedResource;\n                }\n                else if (segResourceId) {\n                    this.currentResource = queryResourceObject(this, segResourceId);\n                }\n                else {\n                    this.currentResource = null;\n                }\n            };\n            fullcalendar_1.EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {\n                var objs = origMethods.getFallbackStylingObjs.apply(this, arguments);\n                if (this.currentResource) {\n                    objs.unshift(this.currentResource);\n                }\n                else {\n                    var resources = [];\n                    for (var _i = 0, _a = eventDef.getResourceIds(); _i < _a.length; _i++) {\n                        var id = _a[_i];\n                        var resource = queryResourceObject(this, id);\n                        if (resource) {\n                            resources.push(resource);\n                        }\n                    }\n                    objs = resources.concat(objs);\n                }\n                return objs;\n            };\n            function queryResourceObject(eventRenderer, id) {\n                return eventRenderer.view.calendar.resourceManager.getResourceById(id);\n            }\n            /***/ \n        }),\n        /* 56 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceComponentFootprint_1 = __webpack_require__(6);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                computeSelectionFootprint: fullcalendar_1.DateSelecting.prototype.computeSelectionFootprint\n            };\n            fullcalendar_1.DateSelecting.prototype.computeSelectionFootprint = function (startFootprint, endFootprint) {\n                if (startFootprint.resourceId && endFootprint.resourceId &&\n                    (startFootprint.resourceId !== endFootprint.resourceId) &&\n                    !this.component.allowCrossResource) {\n                    return null; // explicity disallow selection across two different resources\n                }\n                else {\n                    var footprint = origMethods.computeSelectionFootprint.apply(this, arguments);\n                    if (startFootprint.resourceId) {\n                        // create a new footprint with resourceId data\n                        footprint = new ResourceComponentFootprint_1.default(footprint.unzonedRange, footprint.isAllDay, startFootprint.resourceId);\n                    }\n                    return footprint;\n                }\n            };\n            /***/ \n        }),\n        /* 57 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                computeEventDropMutation: fullcalendar_1.EventDragging.prototype.computeEventDropMutation\n            };\n            /*\n            monkeypatching can cause an event to seem draggable if the resource is editable but the\n            start/end dates are NOT. make sure to account for this.\n            */\n            fullcalendar_1.EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {\n                var isDatesDraggable = this.component.isEventDefStartEditable(eventDef);\n                if (startFootprint.resourceId && endFootprint.resourceId &&\n                    (startFootprint.resourceId !== endFootprint.resourceId) &&\n                    this.component.isEventDefResourceEditable(eventDef)) {\n                    var mutation = new fullcalendar_1.EventDefMutation();\n                    mutation.oldResourceId = startFootprint.resourceId;\n                    mutation.newResourceId = endFootprint.resourceId;\n                    if (isDatesDraggable) {\n                        mutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));\n                    }\n                    return mutation;\n                }\n                else if (isDatesDraggable) {\n                    return origMethods.computeEventDropMutation.apply(this, arguments);\n                }\n            };\n            /***/ \n        }),\n        /* 58 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                computeEventStartResizeMutation: fullcalendar_1.EventResizing.prototype.computeEventStartResizeMutation,\n                computeEventEndResizeMutation: fullcalendar_1.EventResizing.prototype.computeEventEndResizeMutation\n            };\n            fullcalendar_1.EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\n                if (startFootprint.resourceId && endFootprint.resourceId &&\n                    (startFootprint.resourceId !== endFootprint.resourceId) &&\n                    !this.component.allowCrossResource) {\n                    return null; // explicity disallow resizing across two different resources\n                }\n                else {\n                    return origMethods.computeEventStartResizeMutation.apply(this, arguments);\n                }\n            };\n            fullcalendar_1.EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\n                if (startFootprint.resourceId && endFootprint.resourceId &&\n                    (startFootprint.resourceId !== endFootprint.resourceId) &&\n                    !this.component.allowCrossResource) {\n                    return null; // explicity disallow resizing across two different resources\n                }\n                else {\n                    return origMethods.computeEventEndResizeMutation.apply(this, arguments);\n                }\n            };\n            /***/ \n        }),\n        /* 59 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // references to pre-monkeypatched methods\n            var origMethods = {\n                computeExternalDrop: fullcalendar_1.ExternalDropping.prototype.computeExternalDrop\n            };\n            fullcalendar_1.ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {\n                var eventDef = origMethods.computeExternalDrop.apply(this, arguments);\n                if (componentFootprint.resourceId) {\n                    eventDef.addResourceId(componentFootprint.resourceId);\n                }\n                return eventDef;\n            };\n            /***/ \n        }),\n        /* 60 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            // defineStandardProps won't work :(\n            // TODO: find a better way\n            fullcalendar_1.EventSource.prototype.standardPropMap.resourceEditable = true; // automatically transfer\n            /***/ \n        }),\n        /* 61 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(2);\n            var fullcalendar_1 = __webpack_require__(0);\n            var Resource_1 = __webpack_require__(19);\n            var origMethods = {\n                applyMiscProps: fullcalendar_1.EventDef.prototype.applyMiscProps,\n                clone: fullcalendar_1.EventDef.prototype.clone,\n                toLegacy: fullcalendar_1.EventDef.prototype.toLegacy\n            };\n            fullcalendar_1.EventDef.defineStandardProps({\n                resourceEditable: true // automatically transfer\n            });\n            /*\n            new class members\n            */\n            fullcalendar_1.EventDef.prototype.resourceIds = null;\n            fullcalendar_1.EventDef.prototype.resourceEditable = null; // `null` is unspecified state\n            /*\n            NOTE: we can use defineStandardProps/applyManualStandardProps (example below)\n            once we do away with the deprecated eventResourceField.\n            */\n            fullcalendar_1.EventDef.prototype.applyMiscProps = function (rawProps) {\n                rawProps = $.extend({}, rawProps); // clone, because of delete\n                this.resourceIds = Resource_1.default.extractIds(rawProps, this.source.calendar);\n                delete rawProps.resourceId;\n                delete rawProps.resourceIds;\n                origMethods.applyMiscProps.apply(this, arguments);\n            };\n            /*\n            EventDef.defineStandardProps({\n              resourceId: false # manually handle\n              resourceIds: false # manually handle\n            });\n            EventDef.prototype.applyManualStandardProps = function(rawProps) {\n              origApplyManualStandardProps.apply(this, arguments);\n              this.resourceIds = Resource.extractIds(rawProps, this.source.calendar);\n            };\n            */\n            /*\n            resourceId should already be normalized\n            */\n            fullcalendar_1.EventDef.prototype.hasResourceId = function (resourceId) {\n                return $.inArray(resourceId, this.resourceIds) !== -1;\n            };\n            /*\n            resourceId should already be normalized\n            */\n            fullcalendar_1.EventDef.prototype.removeResourceId = function (resourceId) {\n                fullcalendar_1.removeExact(this.resourceIds, resourceId);\n            };\n            /*\n            resourceId should already be normalized\n            */\n            fullcalendar_1.EventDef.prototype.addResourceId = function (resourceId) {\n                if (!this.hasResourceId(resourceId)) {\n                    this.resourceIds.push(resourceId);\n                }\n            };\n            fullcalendar_1.EventDef.prototype.getResourceIds = function () {\n                if (this.resourceIds) {\n                    return this.resourceIds.slice(); // clone\n                }\n                else {\n                    return [];\n                }\n            };\n            fullcalendar_1.EventDef.prototype.clone = function () {\n                var def = origMethods.clone.apply(this, arguments);\n                def.resourceIds = this.getResourceIds();\n                return def;\n            };\n            fullcalendar_1.EventDef.prototype.toLegacy = function () {\n                var obj = origMethods.toLegacy.apply(this, arguments);\n                var resourceIds = this.getResourceIds();\n                obj.resourceId =\n                    resourceIds.length === 1 ?\n                        resourceIds[0] :\n                        null;\n                obj.resourceIds =\n                    resourceIds.length > 1 ?\n                        resourceIds :\n                        null;\n                if (this.resourceEditable != null) {\n                    obj.resourceEditable = this.resourceEditable;\n                }\n                return obj;\n            };\n            /***/ \n        }),\n        /* 62 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var oldMutateSingle = fullcalendar_1.EventDefMutation.prototype.mutateSingle;\n            // either both will be set, or neither will be set\n            fullcalendar_1.EventDefMutation.prototype.oldResourceId = null;\n            fullcalendar_1.EventDefMutation.prototype.newResourceId = null;\n            fullcalendar_1.EventDefMutation.prototype.mutateSingle = function (eventDef) {\n                var undo = oldMutateSingle.apply(this, arguments);\n                var savedResourceIds = null;\n                if (this.oldResourceId && eventDef.hasResourceId(this.oldResourceId)) {\n                    savedResourceIds = eventDef.getResourceIds();\n                    eventDef.removeResourceId(this.oldResourceId);\n                    eventDef.addResourceId(this.newResourceId);\n                }\n                return function () {\n                    undo();\n                    if (savedResourceIds) {\n                        eventDef.resourceIds = savedResourceIds;\n                    }\n                };\n            };\n            /***/ \n        }),\n        /* 63 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var TimelineView_1 = __webpack_require__(14);\n            fullcalendar_1.defineView('timeline', {\n                class: TimelineView_1.default,\n                defaults: {\n                    eventResizableFromStart: true\n                }\n            });\n            fullcalendar_1.defineView('timelineDay', {\n                type: 'timeline',\n                duration: { days: 1 }\n            });\n            fullcalendar_1.defineView('timelineWeek', {\n                type: 'timeline',\n                duration: { weeks: 1 }\n            });\n            fullcalendar_1.defineView('timelineMonth', {\n                type: 'timeline',\n                duration: { months: 1 }\n            });\n            fullcalendar_1.defineView('timelineYear', {\n                type: 'timeline',\n                duration: { years: 1 }\n            });\n            /***/ \n        }),\n        /* 64 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceTimelineView_1 = __webpack_require__(30);\n            fullcalendar_1.getViewConfig('timeline').resourceClass = ResourceTimelineView_1.default;\n            fullcalendar_1.Calendar.defaults.resourcesInitiallyExpanded = true;\n            /***/ \n        }),\n        /* 65 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceBasicView_1 = __webpack_require__(22);\n            var ResourceMonthView_1 = __webpack_require__(23);\n            // TODO: make more DRY (with agenda's config too)\n            fullcalendar_1.getViewConfig('basic').queryResourceClass = function (viewSpec) {\n                var explicitGrouping = viewSpec.options.groupByResource ||\n                    viewSpec.options.groupByDateAndResource;\n                var showsResources = false;\n                if (explicitGrouping != null) {\n                    showsResources = explicitGrouping;\n                }\n                else if (viewSpec.duration) {\n                    showsResources = viewSpec.duration.as('days') === 1;\n                }\n                if (showsResources) {\n                    return ResourceBasicView_1.default;\n                }\n            };\n            fullcalendar_1.getViewConfig('month').queryResourceClass = function (viewSpec) {\n                if (viewSpec.options.groupByResource ||\n                    viewSpec.options.groupByDateAndResource) {\n                    return ResourceMonthView_1.default;\n                }\n            };\n            /***/ \n        }),\n        /* 66 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var fullcalendar_1 = __webpack_require__(0);\n            var ResourceAgendaView_1 = __webpack_require__(20);\n            /*\n            TODO: make more DRY, with basic's config\n            */\n            fullcalendar_1.getViewConfig('agenda').queryResourceClass = function (viewSpec) {\n                var explicitGrouping = viewSpec.options.groupByResource ||\n                    viewSpec.options.groupByDateAndResource;\n                var showsResources = false;\n                if (explicitGrouping != null) {\n                    showsResources = explicitGrouping;\n                }\n                else if (viewSpec.duration) {\n                    showsResources = viewSpec.duration.as('days') === 1;\n                }\n                if (showsResources) {\n                    return ResourceAgendaView_1.default;\n                }\n            };\n            /***/ \n        }),\n        /* 67 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /***/ \n        }),\n        /* 68 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /***/ \n        })\n        /******/ \n    ]);\n});\n",null]}