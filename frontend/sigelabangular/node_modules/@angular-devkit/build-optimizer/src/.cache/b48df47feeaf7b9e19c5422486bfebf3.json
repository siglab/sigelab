{"remainingRequest":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/fullcalendar/dist/fullcalendar.js","dependencies":[{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/fullcalendar/dist/fullcalendar.js","mtime":1520220619000},{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/cache-loader/dist/cjs.js","mtime":1553019068977},{"path":"/home/jeff/Projects/sigelab/frontend/sigelabangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/*!\n * FullCalendar v3.9.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (typeof exports === 'object' && typeof module === 'object')\n        module.exports = factory(require(\"moment\"), require(\"jquery\"));\n    else if (typeof define === 'function' && define.amd)\n        define([\"moment\", \"jquery\"], factory);\n    else if (typeof exports === 'object')\n        exports[\"FullCalendar\"] = factory(require(\"moment\"), require(\"jquery\"));\n    else\n        root[\"FullCalendar\"] = factory(root[\"moment\"], root[\"jQuery\"]);\n})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {\n    return /******/ (function (modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/\n        /******/ // The require function\n        /******/ function __webpack_require__(moduleId) {\n            /******/\n            /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n                /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n                /******/ \n            };\n            /******/\n            /******/ // Execute the module function\n            /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n            /******/\n            /******/ // Flag the module as loaded\n            /******/ module.l = true;\n            /******/\n            /******/ // Return the exports of the module\n            /******/ return module.exports;\n            /******/ \n        }\n        /******/\n        /******/\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/ __webpack_require__.m = modules;\n        /******/\n        /******/ // expose the module cache\n        /******/ __webpack_require__.c = installedModules;\n        /******/\n        /******/ // define getter function for harmony exports\n        /******/ __webpack_require__.d = function (exports, name, getter) {\n            /******/ if (!__webpack_require__.o(exports, name)) {\n                /******/ Object.defineProperty(exports, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                    /******/ \n                });\n                /******/ }\n            /******/ \n        };\n        /******/\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __webpack_require__.n = function (module) {\n            /******/ var getter = module && module.__esModule ?\n                /******/ function getDefault() { return module['default']; } :\n                /******/ function getModuleExports() { return module; };\n            /******/ __webpack_require__.d(getter, 'a', getter);\n            /******/ return getter;\n            /******/ \n        };\n        /******/\n        /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n        /******/\n        /******/ // __webpack_public_path__\n        /******/ __webpack_require__.p = \"\";\n        /******/\n        /******/ // Load entry module and return exports\n        /******/ return __webpack_require__(__webpack_require__.s = 236);\n        /******/ \n    })([\n        /* 0 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n            /***/ \n        }),\n        /* 1 */ ,\n        /* 2 */\n        /***/ (function (module, exports) {\n            /*\n            derived from:\n            https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js\n            \n            only include the helpers we need, to keep down filesize\n            */\n            var extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) {\n                    for (var p in b)\n                        if (b.hasOwnProperty(p))\n                            d[p] = b[p];\n                };\n            exports.__extends = function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n            /***/ \n        }),\n        /* 3 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n            /***/ \n        }),\n        /* 4 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var $ = __webpack_require__(3);\n            /* FullCalendar-specific DOM Utilities\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\n            // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\n            function compensateScroll(rowEls, scrollbarWidths) {\n                if (scrollbarWidths.left) {\n                    rowEls.css({\n                        'border-left-width': 1,\n                        'margin-left': scrollbarWidths.left - 1\n                    });\n                }\n                if (scrollbarWidths.right) {\n                    rowEls.css({\n                        'border-right-width': 1,\n                        'margin-right': scrollbarWidths.right - 1\n                    });\n                }\n            }\n            exports.compensateScroll = compensateScroll;\n            // Undoes compensateScroll and restores all borders/margins\n            function uncompensateScroll(rowEls) {\n                rowEls.css({\n                    'margin-left': '',\n                    'margin-right': '',\n                    'border-left-width': '',\n                    'border-right-width': ''\n                });\n            }\n            exports.uncompensateScroll = uncompensateScroll;\n            // Make the mouse cursor express that an event is not allowed in the current area\n            function disableCursor() {\n                $('body').addClass('fc-not-allowed');\n            }\n            exports.disableCursor = disableCursor;\n            // Returns the mouse cursor to its original look\n            function enableCursor() {\n                $('body').removeClass('fc-not-allowed');\n            }\n            exports.enableCursor = enableCursor;\n            // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\n            // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\n            // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and\n            // reduces the available height.\n            function distributeHeight(els, availableHeight, shouldRedistribute) {\n                // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\n                // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\n                var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\n                var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\n                var flexEls = []; // elements that are allowed to expand. array of DOM nodes\n                var flexOffsets = []; // amount of vertical space it takes up\n                var flexHeights = []; // actual css height\n                var usedHeight = 0;\n                undistributeHeight(els); // give all elements their natural height\n                // find elements that are below the recommended height (expandable).\n                // important to query for heights in a single first pass (to avoid reflow oscillation).\n                els.each(function (i, el) {\n                    var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\n                    var naturalOffset = $(el).outerHeight(true);\n                    if (naturalOffset < minOffset) {\n                        flexEls.push(el);\n                        flexOffsets.push(naturalOffset);\n                        flexHeights.push($(el).height());\n                    }\n                    else {\n                        // this element stretches past recommended height (non-expandable). mark the space as occupied.\n                        usedHeight += naturalOffset;\n                    }\n                });\n                // readjust the recommended height to only consider the height available to non-maxed-out rows.\n                if (shouldRedistribute) {\n                    availableHeight -= usedHeight;\n                    minOffset1 = Math.floor(availableHeight / flexEls.length);\n                    minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\n                }\n                // assign heights to all expandable elements\n                $(flexEls).each(function (i, el) {\n                    var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\n                    var naturalOffset = flexOffsets[i];\n                    var naturalHeight = flexHeights[i];\n                    var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\n                    if (naturalOffset < minOffset) {\n                        $(el).height(newHeight);\n                    }\n                });\n            }\n            exports.distributeHeight = distributeHeight;\n            // Undoes distrubuteHeight, restoring all els to their natural height\n            function undistributeHeight(els) {\n                els.height('');\n            }\n            exports.undistributeHeight = undistributeHeight;\n            // Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\n            // cells to be that width.\n            // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\n            function matchCellWidths(els) {\n                var maxInnerWidth = 0;\n                els.find('> *').each(function (i, innerEl) {\n                    var innerWidth = $(innerEl).outerWidth();\n                    if (innerWidth > maxInnerWidth) {\n                        maxInnerWidth = innerWidth;\n                    }\n                });\n                maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\n                els.width(maxInnerWidth);\n                return maxInnerWidth;\n            }\n            exports.matchCellWidths = matchCellWidths;\n            // Given one element that resides inside another,\n            // Subtracts the height of the inner element from the outer element.\n            function subtractInnerElHeight(outerEl, innerEl) {\n                var both = outerEl.add(innerEl);\n                var diff;\n                // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\n                both.css({\n                    position: 'relative',\n                    left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\n                });\n                diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\n                both.css({ position: '', left: '' }); // undo hack\n                return diff;\n            }\n            exports.subtractInnerElHeight = subtractInnerElHeight;\n            /* Element Geom Utilities\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\n            function getScrollParent(el) {\n                var position = el.css('position');\n                var scrollParent = el.parents().filter(function () {\n                    var parent = $(this);\n                    return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));\n                }).eq(0);\n                return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\n            }\n            exports.getScrollParent = getScrollParent;\n            // Queries the outer bounding area of a jQuery element.\n            // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n            // Origin is optional.\n            function getOuterRect(el, origin) {\n                var offset = el.offset();\n                var left = offset.left - (origin ? origin.left : 0);\n                var top = offset.top - (origin ? origin.top : 0);\n                return {\n                    left: left,\n                    right: left + el.outerWidth(),\n                    top: top,\n                    bottom: top + el.outerHeight()\n                };\n            }\n            exports.getOuterRect = getOuterRect;\n            // Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\n            // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n            // Origin is optional.\n            // WARNING: given element can't have borders\n            // NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n            function getClientRect(el, origin) {\n                var offset = el.offset();\n                var scrollbarWidths = getScrollbarWidths(el);\n                var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\n                var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\n                return {\n                    left: left,\n                    right: left + el[0].clientWidth,\n                    top: top,\n                    bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\n                };\n            }\n            exports.getClientRect = getClientRect;\n            // Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\n            // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n            // Origin is optional.\n            function getContentRect(el, origin) {\n                var offset = el.offset(); // just outside of border, margin not included\n                var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\n                    (origin ? origin.left : 0);\n                var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\n                    (origin ? origin.top : 0);\n                return {\n                    left: left,\n                    right: left + el.width(),\n                    top: top,\n                    bottom: top + el.height()\n                };\n            }\n            exports.getContentRect = getContentRect;\n            // Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\n            // WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\n            // NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n            function getScrollbarWidths(el) {\n                var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\n                var bottomWidth = el[0].offsetHeight - el[0].clientHeight;\n                var widths;\n                leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\n                bottomWidth = sanitizeScrollbarWidth(bottomWidth);\n                widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\n                if (getIsLeftRtlScrollbars() && el.css('direction') === 'rtl') {\n                    widths.left = leftRightWidth;\n                }\n                else {\n                    widths.right = leftRightWidth;\n                }\n                return widths;\n            }\n            exports.getScrollbarWidths = getScrollbarWidths;\n            // The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\n            // retina displays, rounding, and IE11. Massage them into a usable value.\n            function sanitizeScrollbarWidth(width) {\n                width = Math.max(0, width); // no negatives\n                width = Math.round(width);\n                return width;\n            }\n            // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\n            var _isLeftRtlScrollbars = null;\n            function getIsLeftRtlScrollbars() {\n                if (_isLeftRtlScrollbars === null) {\n                    _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\n                }\n                return _isLeftRtlScrollbars;\n            }\n            function computeIsLeftRtlScrollbars() {\n                var el = $('<div><div/></div>')\n                    .css({\n                    position: 'absolute',\n                    top: -1000,\n                    left: 0,\n                    border: 0,\n                    padding: 0,\n                    overflow: 'scroll',\n                    direction: 'rtl'\n                })\n                    .appendTo('body');\n                var innerEl = el.children();\n                var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\n                el.remove();\n                return res;\n            }\n            // Retrieves a jQuery element's computed CSS value as a floating-point number.\n            // If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\n            function getCssFloat(el, prop) {\n                return parseFloat(el.css(prop)) || 0;\n            }\n            /* Mouse / Touch Utilities\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n            function isPrimaryMouseButton(ev) {\n                return ev.which === 1 && !ev.ctrlKey;\n            }\n            exports.isPrimaryMouseButton = isPrimaryMouseButton;\n            function getEvX(ev) {\n                var touches = ev.originalEvent.touches;\n                // on mobile FF, pageX for touch events is present, but incorrect,\n                // so, look at touch coordinates first.\n                if (touches && touches.length) {\n                    return touches[0].pageX;\n                }\n                return ev.pageX;\n            }\n            exports.getEvX = getEvX;\n            function getEvY(ev) {\n                var touches = ev.originalEvent.touches;\n                // on mobile FF, pageX for touch events is present, but incorrect,\n                // so, look at touch coordinates first.\n                if (touches && touches.length) {\n                    return touches[0].pageY;\n                }\n                return ev.pageY;\n            }\n            exports.getEvY = getEvY;\n            function getEvIsTouch(ev) {\n                return /^touch/.test(ev.type);\n            }\n            exports.getEvIsTouch = getEvIsTouch;\n            function preventSelection(el) {\n                el.addClass('fc-unselectable')\n                    .on('selectstart', preventDefault);\n            }\n            exports.preventSelection = preventSelection;\n            function allowSelection(el) {\n                el.removeClass('fc-unselectable')\n                    .off('selectstart', preventDefault);\n            }\n            exports.allowSelection = allowSelection;\n            // Stops a mouse/touch event from doing it's native browser action\n            function preventDefault(ev) {\n                ev.preventDefault();\n            }\n            exports.preventDefault = preventDefault;\n            /* General Geometry Utils\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n            function intersectRects(rect1, rect2) {\n                var res = {\n                    left: Math.max(rect1.left, rect2.left),\n                    right: Math.min(rect1.right, rect2.right),\n                    top: Math.max(rect1.top, rect2.top),\n                    bottom: Math.min(rect1.bottom, rect2.bottom)\n                };\n                if (res.left < res.right && res.top < res.bottom) {\n                    return res;\n                }\n                return false;\n            }\n            exports.intersectRects = intersectRects;\n            // Returns a new point that will have been moved to reside within the given rectangle\n            function constrainPoint(point, rect) {\n                return {\n                    left: Math.min(Math.max(point.left, rect.left), rect.right),\n                    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n                };\n            }\n            exports.constrainPoint = constrainPoint;\n            // Returns a point that is the center of the given rectangle\n            function getRectCenter(rect) {\n                return {\n                    left: (rect.left + rect.right) / 2,\n                    top: (rect.top + rect.bottom) / 2\n                };\n            }\n            exports.getRectCenter = getRectCenter;\n            // Subtracts point2's coordinates from point1's coordinates, returning a delta\n            function diffPoints(point1, point2) {\n                return {\n                    left: point1.left - point2.left,\n                    top: point1.top - point2.top\n                };\n            }\n            exports.diffPoints = diffPoints;\n            /* Object Ordering by Field\n            ----------------------------------------------------------------------------------------------------------------------*/\n            function parseFieldSpecs(input) {\n                var specs = [];\n                var tokens = [];\n                var i;\n                var token;\n                if (typeof input === 'string') {\n                    tokens = input.split(/\\s*,\\s*/);\n                }\n                else if (typeof input === 'function') {\n                    tokens = [input];\n                }\n                else if ($.isArray(input)) {\n                    tokens = input;\n                }\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n                    if (typeof token === 'string') {\n                        specs.push(token.charAt(0) === '-' ?\n                            { field: token.substring(1), order: -1 } :\n                            { field: token, order: 1 });\n                    }\n                    else if (typeof token === 'function') {\n                        specs.push({ func: token });\n                    }\n                }\n                return specs;\n            }\n            exports.parseFieldSpecs = parseFieldSpecs;\n            function compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {\n                var i;\n                var cmp;\n                for (i = 0; i < fieldSpecs.length; i++) {\n                    cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);\n                    if (cmp) {\n                        return cmp;\n                    }\n                }\n                return 0;\n            }\n            exports.compareByFieldSpecs = compareByFieldSpecs;\n            function compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {\n                if (fieldSpec.func) {\n                    return fieldSpec.func(obj1, obj2);\n                }\n                var val1 = obj1[fieldSpec.field];\n                var val2 = obj2[fieldSpec.field];\n                if (val1 == null && obj1fallback) {\n                    val1 = obj1fallback[fieldSpec.field];\n                }\n                if (val2 == null && obj2fallback) {\n                    val2 = obj2fallback[fieldSpec.field];\n                }\n                return flexibleCompare(val1, val2) * (fieldSpec.order || 1);\n            }\n            exports.compareByFieldSpec = compareByFieldSpec;\n            function flexibleCompare(a, b) {\n                if (!a && !b) {\n                    return 0;\n                }\n                if (b == null) {\n                    return -1;\n                }\n                if (a == null) {\n                    return 1;\n                }\n                if ($.type(a) === 'string' || $.type(b) === 'string') {\n                    return String(a).localeCompare(String(b));\n                }\n                return a - b;\n            }\n            exports.flexibleCompare = flexibleCompare;\n            /* Date Utilities\n            ----------------------------------------------------------------------------------------------------------------------*/\n            exports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n            exports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending\n            // Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\n            // Moments will have their timezones normalized.\n            function diffDayTime(a, b) {\n                return moment.duration({\n                    days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\n                    ms: a.time() - b.time() // time-of-day from day start. disregards timezone\n                });\n            }\n            exports.diffDayTime = diffDayTime;\n            // Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\n            function diffDay(a, b) {\n                return moment.duration({\n                    days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\n                });\n            }\n            exports.diffDay = diffDay;\n            // Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\n            function diffByUnit(a, b, unit) {\n                return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true\n                unit);\n            }\n            exports.diffByUnit = diffByUnit;\n            // Computes the unit name of the largest whole-unit period of time.\n            // For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\n            // Accepts start/end, a range object, or an original duration object.\n            function computeGreatestUnit(start, end) {\n                var i;\n                var unit;\n                var val;\n                for (i = 0; i < exports.unitsDesc.length; i++) {\n                    unit = exports.unitsDesc[i];\n                    val = computeRangeAs(unit, start, end);\n                    if (val >= 1 && isInt(val)) {\n                        break;\n                    }\n                }\n                return unit; // will be \"milliseconds\" if nothing else matches\n            }\n            exports.computeGreatestUnit = computeGreatestUnit;\n            // like computeGreatestUnit, but has special abilities to interpret the source input for clues\n            function computeDurationGreatestUnit(duration, durationInput) {\n                var unit = computeGreatestUnit(duration);\n                // prevent days:7 from being interpreted as a week\n                if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\n                    unit = 'day';\n                }\n                return unit;\n            }\n            exports.computeDurationGreatestUnit = computeDurationGreatestUnit;\n            // Computes the number of units (like \"hours\") in the given range.\n            // Range can be a {start,end} object, separate start/end args, or a Duration.\n            // Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\n            // of month-diffing logic (which tends to vary from version to version).\n            function computeRangeAs(unit, start, end) {\n                if (end != null) {\n                    return end.diff(start, unit, true);\n                }\n                else if (moment.isDuration(start)) {\n                    return start.as(unit);\n                }\n                else {\n                    return start.end.diff(start.start, unit, true);\n                }\n            }\n            // Intelligently divides a range (specified by a start/end params) by a duration\n            function divideRangeByDuration(start, end, dur) {\n                var months;\n                if (durationHasTime(dur)) {\n                    return (end - start) / dur;\n                }\n                months = dur.asMonths();\n                if (Math.abs(months) >= 1 && isInt(months)) {\n                    return end.diff(start, 'months', true) / months;\n                }\n                return end.diff(start, 'days', true) / dur.asDays();\n            }\n            exports.divideRangeByDuration = divideRangeByDuration;\n            // Intelligently divides one duration by another\n            function divideDurationByDuration(dur1, dur2) {\n                var months1;\n                var months2;\n                if (durationHasTime(dur1) || durationHasTime(dur2)) {\n                    return dur1 / dur2;\n                }\n                months1 = dur1.asMonths();\n                months2 = dur2.asMonths();\n                if (Math.abs(months1) >= 1 && isInt(months1) &&\n                    Math.abs(months2) >= 1 && isInt(months2)) {\n                    return months1 / months2;\n                }\n                return dur1.asDays() / dur2.asDays();\n            }\n            exports.divideDurationByDuration = divideDurationByDuration;\n            // Intelligently multiplies a duration by a number\n            function multiplyDuration(dur, n) {\n                var months;\n                if (durationHasTime(dur)) {\n                    return moment.duration(dur * n);\n                }\n                months = dur.asMonths();\n                if (Math.abs(months) >= 1 && isInt(months)) {\n                    return moment.duration({ months: months * n });\n                }\n                return moment.duration({ days: dur.asDays() * n });\n            }\n            exports.multiplyDuration = multiplyDuration;\n            // Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\n            function durationHasTime(dur) {\n                return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\n            }\n            exports.durationHasTime = durationHasTime;\n            function isNativeDate(input) {\n                return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\n            }\n            exports.isNativeDate = isNativeDate;\n            // Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\n            function isTimeString(str) {\n                return typeof str === 'string' &&\n                    /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\n            }\n            exports.isTimeString = isTimeString;\n            /* Logging and Debug\n            ----------------------------------------------------------------------------------------------------------------------*/\n            function log() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var console = window.console;\n                if (console && console.log) {\n                    return console.log.apply(console, args);\n                }\n            }\n            exports.log = log;\n            function warn() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var console = window.console;\n                if (console && console.warn) {\n                    return console.warn.apply(console, args);\n                }\n                else {\n                    return log.apply(null, args);\n                }\n            }\n            exports.warn = warn;\n            /* General Utilities\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var hasOwnPropMethod = {}.hasOwnProperty;\n            // Merges an array of objects into a single object.\n            // The second argument allows for an array of property names who's object values will be merged together.\n            function mergeProps(propObjs, complexProps) {\n                var dest = {};\n                var i;\n                var name;\n                var complexObjs;\n                var j;\n                var val;\n                var props;\n                if (complexProps) {\n                    for (i = 0; i < complexProps.length; i++) {\n                        name = complexProps[i];\n                        complexObjs = [];\n                        // collect the trailing object values, stopping when a non-object is discovered\n                        for (j = propObjs.length - 1; j >= 0; j--) {\n                            val = propObjs[j][name];\n                            if (typeof val === 'object') {\n                                complexObjs.unshift(val);\n                            }\n                            else if (val !== undefined) {\n                                dest[name] = val; // if there were no objects, this value will be used\n                                break;\n                            }\n                        }\n                        // if the trailing values were objects, use the merged value\n                        if (complexObjs.length) {\n                            dest[name] = mergeProps(complexObjs);\n                        }\n                    }\n                }\n                // copy values into the destination, going from last to first\n                for (i = propObjs.length - 1; i >= 0; i--) {\n                    props = propObjs[i];\n                    for (name in props) {\n                        if (!(name in dest)) {\n                            dest[name] = props[name];\n                        }\n                    }\n                }\n                return dest;\n            }\n            exports.mergeProps = mergeProps;\n            function copyOwnProps(src, dest) {\n                for (var name_1 in src) {\n                    if (hasOwnProp(src, name_1)) {\n                        dest[name_1] = src[name_1];\n                    }\n                }\n            }\n            exports.copyOwnProps = copyOwnProps;\n            function hasOwnProp(obj, name) {\n                return hasOwnPropMethod.call(obj, name);\n            }\n            exports.hasOwnProp = hasOwnProp;\n            function applyAll(functions, thisObj, args) {\n                if ($.isFunction(functions)) {\n                    functions = [functions];\n                }\n                if (functions) {\n                    var i = void 0;\n                    var ret = void 0;\n                    for (i = 0; i < functions.length; i++) {\n                        ret = functions[i].apply(thisObj, args) || ret;\n                    }\n                    return ret;\n                }\n            }\n            exports.applyAll = applyAll;\n            function removeMatching(array, testFunc) {\n                var removeCnt = 0;\n                var i = 0;\n                while (i < array.length) {\n                    if (testFunc(array[i])) {\n                        array.splice(i, 1);\n                        removeCnt++;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n                return removeCnt;\n            }\n            exports.removeMatching = removeMatching;\n            function removeExact(array, exactVal) {\n                var removeCnt = 0;\n                var i = 0;\n                while (i < array.length) {\n                    if (array[i] === exactVal) {\n                        array.splice(i, 1);\n                        removeCnt++;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n                return removeCnt;\n            }\n            exports.removeExact = removeExact;\n            function isArraysEqual(a0, a1) {\n                var len = a0.length;\n                var i;\n                if (len == null || len !== a1.length) {\n                    return false;\n                }\n                for (i = 0; i < len; i++) {\n                    if (a0[i] !== a1[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            exports.isArraysEqual = isArraysEqual;\n            function firstDefined() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                for (var i = 0; i < args.length; i++) {\n                    if (args[i] !== undefined) {\n                        return args[i];\n                    }\n                }\n            }\n            exports.firstDefined = firstDefined;\n            function htmlEscape(s) {\n                return (s + '').replace(/&/g, '&amp;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;')\n                    .replace(/'/g, '&#039;')\n                    .replace(/\"/g, '&quot;')\n                    .replace(/\\n/g, '<br />');\n            }\n            exports.htmlEscape = htmlEscape;\n            function stripHtmlEntities(text) {\n                return text.replace(/&.*?;/g, '');\n            }\n            exports.stripHtmlEntities = stripHtmlEntities;\n            // Given a hash of CSS properties, returns a string of CSS.\n            // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\n            function cssToStr(cssProps) {\n                var statements = [];\n                $.each(cssProps, function (name, val) {\n                    if (val != null) {\n                        statements.push(name + ':' + val);\n                    }\n                });\n                return statements.join(';');\n            }\n            exports.cssToStr = cssToStr;\n            // Given an object hash of HTML attribute names to values,\n            // generates a string that can be injected between < > in HTML\n            function attrsToStr(attrs) {\n                var parts = [];\n                $.each(attrs, function (name, val) {\n                    if (val != null) {\n                        parts.push(name + '=\"' + htmlEscape(val) + '\"');\n                    }\n                });\n                return parts.join(' ');\n            }\n            exports.attrsToStr = attrsToStr;\n            function capitaliseFirstLetter(str) {\n                return str.charAt(0).toUpperCase() + str.slice(1);\n            }\n            exports.capitaliseFirstLetter = capitaliseFirstLetter;\n            function compareNumbers(a, b) {\n                return a - b;\n            }\n            exports.compareNumbers = compareNumbers;\n            function isInt(n) {\n                return n % 1 === 0;\n            }\n            exports.isInt = isInt;\n            // Returns a method bound to the given object context.\n            // Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\n            // different contexts as identical when binding/unbinding events.\n            function proxy(obj, methodName) {\n                var method = obj[methodName];\n                return function () {\n                    return method.apply(obj, arguments);\n                };\n            }\n            exports.proxy = proxy;\n            // Returns a function, that, as long as it continues to be invoked, will not\n            // be triggered. The function will be called after it stops being called for\n            // N milliseconds. If `immediate` is passed, trigger the function on the\n            // leading edge, instead of the trailing.\n            // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\n            function debounce(func, wait, immediate) {\n                if (immediate === void 0) {\n                    immediate = false;\n                }\n                var timeout;\n                var args;\n                var context;\n                var timestamp;\n                var result;\n                var later = function () {\n                    var last = +new Date() - timestamp;\n                    if (last < wait) {\n                        timeout = setTimeout(later, wait - last);\n                    }\n                    else {\n                        timeout = null;\n                        if (!immediate) {\n                            result = func.apply(context, args);\n                            context = args = null;\n                        }\n                    }\n                };\n                return function () {\n                    context = this;\n                    args = arguments;\n                    timestamp = +new Date();\n                    var callNow = immediate && !timeout;\n                    if (!timeout) {\n                        timeout = setTimeout(later, wait);\n                    }\n                    if (callNow) {\n                        result = func.apply(context, args);\n                        context = args = null;\n                    }\n                    return result;\n                };\n            }\n            exports.debounce = debounce;\n            /***/ \n        }),\n        /* 5 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var moment_ext_1 = __webpack_require__(10);\n            var UnzonedRange = /*@__PURE__*/ (function () {\n                function UnzonedRange(startInput, endInput) {\n                    // TODO: move these into footprint.\n                    // Especially, doesn't make sense for null startMs/endMs.\n                    this.isStart = true;\n                    this.isEnd = true;\n                    if (moment.isMoment(startInput)) {\n                        startInput = startInput.clone().stripZone();\n                    }\n                    if (moment.isMoment(endInput)) {\n                        endInput = endInput.clone().stripZone();\n                    }\n                    if (startInput) {\n                        this.startMs = startInput.valueOf();\n                    }\n                    if (endInput) {\n                        this.endMs = endInput.valueOf();\n                    }\n                }\n                /*\n                SIDEEFFECT: will mutate eventRanges.\n                Will return a new array result.\n                Only works for non-open-ended ranges.\n                */\n                UnzonedRange.invertRanges = function (ranges, constraintRange) {\n                    var invertedRanges = [];\n                    var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range\n                    var i;\n                    var dateRange;\n                    // ranges need to be in order. required for our date-walking algorithm\n                    ranges.sort(compareUnzonedRanges);\n                    for (i = 0; i < ranges.length; i++) {\n                        dateRange = ranges[i];\n                        // add the span of time before the event (if there is any)\n                        if (dateRange.startMs > startMs) {\n                            invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));\n                        }\n                        if (dateRange.endMs > startMs) {\n                            startMs = dateRange.endMs;\n                        }\n                    }\n                    // add the span of time after the last event (if there is any)\n                    if (startMs < constraintRange.endMs) {\n                        invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));\n                    }\n                    return invertedRanges;\n                };\n                UnzonedRange.prototype.intersect = function (otherRange) {\n                    var startMs = this.startMs;\n                    var endMs = this.endMs;\n                    var newRange = null;\n                    if (otherRange.startMs != null) {\n                        if (startMs == null) {\n                            startMs = otherRange.startMs;\n                        }\n                        else {\n                            startMs = Math.max(startMs, otherRange.startMs);\n                        }\n                    }\n                    if (otherRange.endMs != null) {\n                        if (endMs == null) {\n                            endMs = otherRange.endMs;\n                        }\n                        else {\n                            endMs = Math.min(endMs, otherRange.endMs);\n                        }\n                    }\n                    if (startMs == null || endMs == null || startMs < endMs) {\n                        newRange = new UnzonedRange(startMs, endMs);\n                        newRange.isStart = this.isStart && startMs === this.startMs;\n                        newRange.isEnd = this.isEnd && endMs === this.endMs;\n                    }\n                    return newRange;\n                };\n                UnzonedRange.prototype.intersectsWith = function (otherRange) {\n                    return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&\n                        (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);\n                };\n                UnzonedRange.prototype.containsRange = function (innerRange) {\n                    return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&\n                        (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));\n                };\n                // `date` can be a moment, a Date, or a millisecond time.\n                UnzonedRange.prototype.containsDate = function (date) {\n                    var ms = date.valueOf();\n                    return (this.startMs == null || ms >= this.startMs) &&\n                        (this.endMs == null || ms < this.endMs);\n                };\n                // If the given date is not within the given range, move it inside.\n                // (If it's past the end, make it one millisecond before the end).\n                // `date` can be a moment, a Date, or a millisecond time.\n                // Returns a MS-time.\n                UnzonedRange.prototype.constrainDate = function (date) {\n                    var ms = date.valueOf();\n                    if (this.startMs != null && ms < this.startMs) {\n                        ms = this.startMs;\n                    }\n                    if (this.endMs != null && ms >= this.endMs) {\n                        ms = this.endMs - 1;\n                    }\n                    return ms;\n                };\n                UnzonedRange.prototype.equals = function (otherRange) {\n                    return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;\n                };\n                UnzonedRange.prototype.clone = function () {\n                    var range = new UnzonedRange(this.startMs, this.endMs);\n                    range.isStart = this.isStart;\n                    range.isEnd = this.isEnd;\n                    return range;\n                };\n                // Returns an ambig-zoned moment from startMs.\n                // BEWARE: returned moment is not localized.\n                // Formatting and start-of-week will be default.\n                UnzonedRange.prototype.getStart = function () {\n                    if (this.startMs != null) {\n                        return moment_ext_1.default.utc(this.startMs).stripZone();\n                    }\n                    return null;\n                };\n                // Returns an ambig-zoned moment from startMs.\n                // BEWARE: returned moment is not localized.\n                // Formatting and start-of-week will be default.\n                UnzonedRange.prototype.getEnd = function () {\n                    if (this.endMs != null) {\n                        return moment_ext_1.default.utc(this.endMs).stripZone();\n                    }\n                    return null;\n                };\n                UnzonedRange.prototype.as = function (unit) {\n                    return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);\n                };\n                return UnzonedRange;\n            }());\n            exports.default = UnzonedRange;\n            /*\n            Only works for non-open-ended ranges.\n            */\n            function compareUnzonedRanges(range1, range2) {\n                return range1.startMs - range2.startMs; // earlier ranges go first\n            }\n            /***/ \n        }),\n        /* 6 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var ParsableModelMixin_1 = __webpack_require__(208);\n            var Class_1 = __webpack_require__(33);\n            var EventDefParser_1 = __webpack_require__(49);\n            var EventSource = (function (_super) {\n                tslib_1.__extends(EventSource, _super);\n                // can we do away with calendar? at least for the abstract?\n                // useful for buildEventDef\n                function EventSource(calendar) {\n                    var _this = _super.call(this) || this;\n                    _this.calendar = calendar;\n                    _this.className = [];\n                    _this.uid = String(EventSource.uuid++);\n                    return _this;\n                }\n                /*\n                rawInput can be any data type!\n                */\n                EventSource.parse = function (rawInput, calendar) {\n                    var source = new this(calendar);\n                    if (typeof rawInput === 'object') {\n                        if (source.applyProps(rawInput)) {\n                            return source;\n                        }\n                    }\n                    return false;\n                };\n                EventSource.normalizeId = function (id) {\n                    if (id) {\n                        return String(id);\n                    }\n                    return null;\n                };\n                EventSource.prototype.fetch = function (start, end, timezone) {\n                    // subclasses must implement. must return a promise.\n                };\n                EventSource.prototype.removeEventDefsById = function (eventDefId) {\n                    // optional for subclasses to implement\n                };\n                EventSource.prototype.removeAllEventDefs = function () {\n                    // optional for subclasses to implement\n                };\n                /*\n                For compairing/matching\n                */\n                EventSource.prototype.getPrimitive = function (otherSource) {\n                    // subclasses must implement\n                };\n                EventSource.prototype.parseEventDefs = function (rawEventDefs) {\n                    var i;\n                    var eventDef;\n                    var eventDefs = [];\n                    for (i = 0; i < rawEventDefs.length; i++) {\n                        eventDef = this.parseEventDef(rawEventDefs[i]);\n                        if (eventDef) {\n                            eventDefs.push(eventDef);\n                        }\n                    }\n                    return eventDefs;\n                };\n                EventSource.prototype.parseEventDef = function (rawInput) {\n                    var calendarTransform = this.calendar.opt('eventDataTransform');\n                    var sourceTransform = this.eventDataTransform;\n                    if (calendarTransform) {\n                        rawInput = calendarTransform(rawInput, this.calendar);\n                    }\n                    if (sourceTransform) {\n                        rawInput = sourceTransform(rawInput, this.calendar);\n                    }\n                    return EventDefParser_1.default.parse(rawInput, this);\n                };\n                EventSource.prototype.applyManualStandardProps = function (rawProps) {\n                    if (rawProps.id != null) {\n                        this.id = EventSource.normalizeId(rawProps.id);\n                    }\n                    // TODO: converge with EventDef\n                    if ($.isArray(rawProps.className)) {\n                        this.className = rawProps.className;\n                    }\n                    else if (typeof rawProps.className === 'string') {\n                        this.className = rawProps.className.split(/\\s+/);\n                    }\n                    return true;\n                };\n                EventSource.uuid = 0;\n                EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\n                EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\n                return EventSource;\n            }(Class_1.default));\n            exports.default = EventSource;\n            ParsableModelMixin_1.default.mixInto(EventSource);\n            // Parsing\n            // ---------------------------------------------------------------------------------------------------------------------\n            EventSource.defineStandardProps({\n                // manually process...\n                id: false,\n                className: false,\n                // automatically transfer...\n                color: true,\n                backgroundColor: true,\n                borderColor: true,\n                textColor: true,\n                editable: true,\n                startEditable: true,\n                durationEditable: true,\n                rendering: true,\n                overlap: true,\n                constraint: true,\n                allDayDefault: true,\n                eventDataTransform: true\n            });\n            /***/ \n        }),\n        /* 7 */\n        /***/ (function (module, exports, __webpack_require__) {\n            /*\n            Utility methods for easily listening to events on another object,\n            and more importantly, easily unlistening from them.\n            \n            USAGE:\n              import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'\n            in class:\n              listenTo: ListenerInterface['listenTo']\n              stopListeningTo: ListenerInterface['stopListeningTo']\n            after class:\n              ListenerMixin.mixInto(TheClass)\n            */\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var Mixin_1 = __webpack_require__(14);\n            var guid = 0;\n            var ListenerMixin = (function (_super) {\n                tslib_1.__extends(ListenerMixin, _super);\n                function ListenerMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\n                The `callback` will be called with the `this` context of the object that .listenTo is being called on.\n                Can be called:\n                  .listenTo(other, eventName, callback)\n                OR\n                  .listenTo(other, {\n                    eventName1: callback1,\n                    eventName2: callback2\n                  })\n                */\n                ListenerMixin.prototype.listenTo = function (other, arg, callback) {\n                    if (typeof arg === 'object') {\n                        for (var eventName in arg) {\n                            if (arg.hasOwnProperty(eventName)) {\n                                this.listenTo(other, eventName, arg[eventName]);\n                            }\n                        }\n                    }\n                    else if (typeof arg === 'string') {\n                        other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\n                        $.proxy(callback, this) // always use `this` context\n                        // the usually-undesired jQuery guid behavior doesn't matter,\n                        // because we always unbind via namespace\n                        );\n                    }\n                };\n                /*\n                Causes the current object to stop listening to events on the `other` object.\n                `eventName` is optional. If omitted, will stop listening to ALL events on `other`.\n                */\n                ListenerMixin.prototype.stopListeningTo = function (other, eventName) {\n                    other.off((eventName || '') + '.' + this.getListenerNamespace());\n                };\n                /*\n                Returns a string, unique to this object, to be used for event namespacing\n                */\n                ListenerMixin.prototype.getListenerNamespace = function () {\n                    if (this.listenerId == null) {\n                        this.listenerId = guid++;\n                    }\n                    return '_listener' + this.listenerId;\n                };\n                return ListenerMixin;\n            }(Mixin_1.default));\n            exports.default = ListenerMixin;\n            /***/ \n        }),\n        /* 8 */ ,\n        /* 9 */ ,\n        /* 10 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\n            var ambigTimeOrZoneRegex = /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\n            var newMomentProto = moment.fn; // where we will attach our new methods\n            exports.newMomentProto = newMomentProto;\n            var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\n            exports.oldMomentProto = oldMomentProto;\n            // tell momentjs to transfer these properties upon clone\n            var momentProperties = moment.momentProperties;\n            momentProperties.push('_fullCalendar');\n            momentProperties.push('_ambigTime');\n            momentProperties.push('_ambigZone');\n            /*\n            Call this if you want Moment's original format method to be used\n            */\n            function oldMomentFormat(mom, formatStr) {\n                return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\n            }\n            exports.oldMomentFormat = oldMomentFormat;\n            // Creating\n            // -------------------------------------------------------------------------------------------------\n            // Creates a new moment, similar to the vanilla moment(...) constructor, but with\n            // extra features (ambiguous time, enhanced formatting). When given an existing moment,\n            // it will function as a clone (and retain the zone of the moment). Anything else will\n            // result in a moment in the local zone.\n            var momentExt = function () {\n                return makeMoment(arguments);\n            };\n            exports.default = momentExt;\n            // Sames as momentExt, but forces the resulting moment to be in the UTC timezone.\n            momentExt.utc = function () {\n                var mom = makeMoment(arguments, true);\n                // Force it into UTC because makeMoment doesn't guarantee it\n                // (if given a pre-existing moment for example)\n                if (mom.hasTime()) {\n                    mom.utc();\n                }\n                return mom;\n            };\n            // Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.\n            // ISO8601 strings with no timezone offset will become ambiguously zoned.\n            momentExt.parseZone = function () {\n                return makeMoment(arguments, true, true);\n            };\n            // Builds an enhanced moment from args. When given an existing moment, it clones. When given a\n            // native Date, or called with no arguments (the current time), the resulting moment will be local.\n            // Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\n            //    parseAsUTC - if there is no zone information, should we parse the input in UTC?\n            //    parseZone - if there is zone information, should we force the zone of the moment?\n            function makeMoment(args, parseAsUTC, parseZone) {\n                if (parseAsUTC === void 0) {\n                    parseAsUTC = false;\n                }\n                if (parseZone === void 0) {\n                    parseZone = false;\n                }\n                var input = args[0];\n                var isSingleString = args.length === 1 && typeof input === 'string';\n                var isAmbigTime;\n                var isAmbigZone;\n                var ambigMatch;\n                var mom;\n                if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {\n                    mom = moment.apply(null, args);\n                }\n                else {\n                    isAmbigTime = false;\n                    isAmbigZone = false;\n                    if (isSingleString) {\n                        if (ambigDateOfMonthRegex.test(input)) {\n                            // accept strings like '2014-05', but convert to the first of the month\n                            input += '-01';\n                            args = [input]; // for when we pass it on to moment's constructor\n                            isAmbigTime = true;\n                            isAmbigZone = true;\n                        }\n                        else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\n                            isAmbigTime = !ambigMatch[5]; // no time part?\n                            isAmbigZone = true;\n                        }\n                    }\n                    else if ($.isArray(input)) {\n                        // arrays have no timezone information, so assume ambiguous zone\n                        isAmbigZone = true;\n                    }\n                    // otherwise, probably a string with a format\n                    if (parseAsUTC || isAmbigTime) {\n                        mom = moment.utc.apply(moment, args);\n                    }\n                    else {\n                        mom = moment.apply(null, args);\n                    }\n                    if (isAmbigTime) {\n                        mom._ambigTime = true;\n                        mom._ambigZone = true; // ambiguous time always means ambiguous zone\n                    }\n                    else if (parseZone) {\n                        if (isAmbigZone) {\n                            mom._ambigZone = true;\n                        }\n                        else if (isSingleString) {\n                            mom.utcOffset(input); // if not a valid zone, will assign UTC\n                        }\n                    }\n                }\n                mom._fullCalendar = true; // flag for extended functionality\n                return mom;\n            }\n            // Week Number\n            // -------------------------------------------------------------------------------------------------\n            // Returns the week number, considering the locale's custom week number calcuation\n            // `weeks` is an alias for `week`\n            newMomentProto.week = newMomentProto.weeks = function (input) {\n                var weekCalc = this._locale._fullCalendar_weekCalc;\n                if (input == null && typeof weekCalc === 'function') {\n                    return weekCalc(this);\n                }\n                else if (weekCalc === 'ISO') {\n                    return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\n                }\n                return oldMomentProto.week.apply(this, arguments); // local getter/setter\n            };\n            // Time-of-day\n            // -------------------------------------------------------------------------------------------------\n            // GETTER\n            // Returns a Duration with the hours/minutes/seconds/ms values of the moment.\n            // If the moment has an ambiguous time, a duration of 00:00 will be returned.\n            //\n            // SETTER\n            // You can supply a Duration, a Moment, or a Duration-like argument.\n            // When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\n            newMomentProto.time = function (time) {\n                // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\n                // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\n                if (!this._fullCalendar) {\n                    return oldMomentProto.time.apply(this, arguments);\n                }\n                if (time == null) {\n                    return moment.duration({\n                        hours: this.hours(),\n                        minutes: this.minutes(),\n                        seconds: this.seconds(),\n                        milliseconds: this.milliseconds()\n                    });\n                }\n                else {\n                    this._ambigTime = false; // mark that the moment now has a time\n                    if (!moment.isDuration(time) && !moment.isMoment(time)) {\n                        time = moment.duration(time);\n                    }\n                    // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\n                    // Only for Duration times, not Moment times.\n                    var dayHours = 0;\n                    if (moment.isDuration(time)) {\n                        dayHours = Math.floor(time.asDays()) * 24;\n                    }\n                    // We need to set the individual fields.\n                    // Can't use startOf('day') then add duration. In case of DST at start of day.\n                    return this.hours(dayHours + time.hours())\n                        .minutes(time.minutes())\n                        .seconds(time.seconds())\n                        .milliseconds(time.milliseconds());\n                }\n            };\n            // Converts the moment to UTC, stripping out its time-of-day and timezone offset,\n            // but preserving its YMD. A moment with a stripped time will display no time\n            // nor timezone offset when .format() is called.\n            newMomentProto.stripTime = function () {\n                if (!this._ambigTime) {\n                    this.utc(true); // keepLocalTime=true (for keeping *date* value)\n                    // set time to zero\n                    this.set({\n                        hours: 0,\n                        minutes: 0,\n                        seconds: 0,\n                        ms: 0\n                    });\n                    // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n                    // which clears all ambig flags.\n                    this._ambigTime = true;\n                    this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\n                }\n                return this; // for chaining\n            };\n            // Returns if the moment has a non-ambiguous time (boolean)\n            newMomentProto.hasTime = function () {\n                return !this._ambigTime;\n            };\n            // Timezone\n            // -------------------------------------------------------------------------------------------------\n            // Converts the moment to UTC, stripping out its timezone offset, but preserving its\n            // YMD and time-of-day. A moment with a stripped timezone offset will display no\n            // timezone offset when .format() is called.\n            newMomentProto.stripZone = function () {\n                var wasAmbigTime;\n                if (!this._ambigZone) {\n                    wasAmbigTime = this._ambigTime;\n                    this.utc(true); // keepLocalTime=true (for keeping date and time values)\n                    // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\n                    this._ambigTime = wasAmbigTime || false;\n                    // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n                    // which clears the ambig flags.\n                    this._ambigZone = true;\n                }\n                return this; // for chaining\n            };\n            // Returns of the moment has a non-ambiguous timezone offset (boolean)\n            newMomentProto.hasZone = function () {\n                return !this._ambigZone;\n            };\n            // implicitly marks a zone\n            newMomentProto.local = function (keepLocalTime) {\n                // for when converting from ambiguously-zoned to local,\n                // keep the time values when converting from UTC -> local\n                oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\n                // ensure non-ambiguous\n                // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\n                this._ambigTime = false;\n                this._ambigZone = false;\n                return this; // for chaining\n            };\n            // implicitly marks a zone\n            newMomentProto.utc = function (keepLocalTime) {\n                oldMomentProto.utc.call(this, keepLocalTime);\n                // ensure non-ambiguous\n                // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\n                this._ambigTime = false;\n                this._ambigZone = false;\n                return this;\n            };\n            // implicitly marks a zone (will probably get called upon .utc() and .local())\n            newMomentProto.utcOffset = function (tzo) {\n                if (tzo != null) {\n                    // these assignments needs to happen before the original zone method is called.\n                    // I forget why, something to do with a browser crash.\n                    this._ambigTime = false;\n                    this._ambigZone = false;\n                }\n                return oldMomentProto.utcOffset.apply(this, arguments);\n            };\n            /***/ \n        }),\n        /* 11 */\n        /***/ (function (module, exports, __webpack_require__) {\n            /*\n            USAGE:\n              import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'\n            in class:\n              on: EmitterInterface['on']\n              one: EmitterInterface['one']\n              off: EmitterInterface['off']\n              trigger: EmitterInterface['trigger']\n              triggerWith: EmitterInterface['triggerWith']\n              hasHandlers: EmitterInterface['hasHandlers']\n            after class:\n              EmitterMixin.mixInto(TheClass)\n            */\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var Mixin_1 = __webpack_require__(14);\n            var EmitterMixin = (function (_super) {\n                tslib_1.__extends(EmitterMixin, _super);\n                function EmitterMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // jQuery-ification via $(this) allows a non-DOM object to have\n                // the same event handling capabilities (including namespaces).\n                EmitterMixin.prototype.on = function (types, handler) {\n                    $(this).on(types, this._prepareIntercept(handler));\n                    return this; // for chaining\n                };\n                EmitterMixin.prototype.one = function (types, handler) {\n                    $(this).one(types, this._prepareIntercept(handler));\n                    return this; // for chaining\n                };\n                EmitterMixin.prototype._prepareIntercept = function (handler) {\n                    // handlers are always called with an \"event\" object as their first param.\n                    // sneak the `this` context and arguments into the extra parameter object\n                    // and forward them on to the original handler.\n                    var intercept = function (ev, extra) {\n                        return handler.apply(extra.context || this, extra.args || []);\n                    };\n                    // mimick jQuery's internal \"proxy\" system (risky, I know)\n                    // causing all functions with the same .guid to appear to be the same.\n                    // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\n                    // this is needed for calling .off with the original non-intercept handler.\n                    if (!handler.guid) {\n                        handler.guid = $.guid++;\n                    }\n                    intercept.guid = handler.guid;\n                    return intercept;\n                };\n                EmitterMixin.prototype.off = function (types, handler) {\n                    $(this).off(types, handler);\n                    return this; // for chaining\n                };\n                EmitterMixin.prototype.trigger = function (types) {\n                    var args = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        args[_i - 1] = arguments[_i];\n                    }\n                    // pass in \"extra\" info to the intercept\n                    $(this).triggerHandler(types, { args: args });\n                    return this; // for chaining\n                };\n                EmitterMixin.prototype.triggerWith = function (types, context, args) {\n                    // `triggerHandler` is less reliant on the DOM compared to `trigger`.\n                    // pass in \"extra\" info to the intercept.\n                    $(this).triggerHandler(types, { context: context, args: args });\n                    return this; // for chaining\n                };\n                EmitterMixin.prototype.hasHandlers = function (type) {\n                    var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/\n                    return hash && hash[type] && hash[type].length > 0;\n                };\n                return EmitterMixin;\n            }(Mixin_1.default));\n            exports.default = EmitterMixin;\n            /***/ \n        }),\n        /* 12 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /*\n            Meant to be immutable\n            */\n            var ComponentFootprint = /*@__PURE__*/ (function () {\n                function ComponentFootprint(unzonedRange, isAllDay) {\n                    this.isAllDay = false; // component can choose to ignore this\n                    this.unzonedRange = unzonedRange;\n                    this.isAllDay = isAllDay;\n                }\n                /*\n                Only works for non-open-ended ranges.\n                */\n                ComponentFootprint.prototype.toLegacy = function (calendar) {\n                    return {\n                        start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),\n                        end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)\n                    };\n                };\n                return ComponentFootprint;\n            }());\n            exports.default = ComponentFootprint;\n            /***/ \n        }),\n        /* 13 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var EventDef_1 = __webpack_require__(34);\n            var EventInstance_1 = __webpack_require__(209);\n            var EventDateProfile_1 = __webpack_require__(17);\n            var SingleEventDef = (function (_super) {\n                tslib_1.__extends(SingleEventDef, _super);\n                function SingleEventDef() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                Will receive start/end params, but will be ignored.\n                */\n                SingleEventDef.prototype.buildInstances = function () {\n                    return [this.buildInstance()];\n                };\n                SingleEventDef.prototype.buildInstance = function () {\n                    return new EventInstance_1.default(this, // definition\n                    this.dateProfile);\n                };\n                SingleEventDef.prototype.isAllDay = function () {\n                    return this.dateProfile.isAllDay();\n                };\n                SingleEventDef.prototype.clone = function () {\n                    var def = _super.prototype.clone.call(this);\n                    def.dateProfile = this.dateProfile;\n                    return def;\n                };\n                SingleEventDef.prototype.rezone = function () {\n                    var calendar = this.source.calendar;\n                    var dateProfile = this.dateProfile;\n                    this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);\n                };\n                /*\n                NOTE: if super-method fails, should still attempt to apply\n                */\n                SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {\n                    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\n                    var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure\n                    if (dateProfile) {\n                        this.dateProfile = dateProfile;\n                        // make sure `date` shows up in the legacy event objects as-is\n                        if (rawProps.date != null) {\n                            this.miscProps.date = rawProps.date;\n                        }\n                        return superSuccess;\n                    }\n                    else {\n                        return false;\n                    }\n                };\n                return SingleEventDef;\n            }(EventDef_1.default));\n            exports.default = SingleEventDef;\n            // Parsing\n            // ---------------------------------------------------------------------------------------------------------------------\n            SingleEventDef.defineStandardProps({\n                start: false,\n                date: false,\n                end: false,\n                allDay: false\n            });\n            /***/ \n        }),\n        /* 14 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var Mixin = /*@__PURE__*/ (function () {\n                function Mixin() {\n                }\n                Mixin.mixInto = function (destClass) {\n                    var _this = this;\n                    Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\n                        if (!destClass.prototype[name]) {\n                            destClass.prototype[name] = _this.prototype[name];\n                        }\n                    });\n                };\n                /*\n                will override existing methods\n                TODO: remove! not used anymore\n                */\n                Mixin.mixOver = function (destClass) {\n                    var _this = this;\n                    Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\n                        destClass.prototype[name] = _this.prototype[name];\n                    });\n                };\n                return Mixin;\n            }());\n            exports.default = Mixin;\n            /***/ \n        }),\n        /* 15 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var Interaction = /*@__PURE__*/ (function () {\n                function Interaction(component) {\n                    this.view = component._getView();\n                    this.component = component;\n                }\n                Interaction.prototype.opt = function (name) {\n                    return this.view.opt(name);\n                };\n                Interaction.prototype.end = function () {\n                    // subclasses can implement\n                };\n                return Interaction;\n            }());\n            exports.default = Interaction;\n            /***/ \n        }),\n        /* 16 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            exports.version = '3.9.0';\n            // When introducing internal API incompatibilities (where fullcalendar plugins would break),\n            // the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\n            // and the below integer should be incremented.\n            exports.internalApiVersion = 12;\n            var util_1 = __webpack_require__(4);\n            exports.applyAll = util_1.applyAll;\n            exports.debounce = util_1.debounce;\n            exports.isInt = util_1.isInt;\n            exports.htmlEscape = util_1.htmlEscape;\n            exports.cssToStr = util_1.cssToStr;\n            exports.proxy = util_1.proxy;\n            exports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;\n            exports.getOuterRect = util_1.getOuterRect;\n            exports.getClientRect = util_1.getClientRect;\n            exports.getContentRect = util_1.getContentRect;\n            exports.getScrollbarWidths = util_1.getScrollbarWidths;\n            exports.preventDefault = util_1.preventDefault;\n            exports.parseFieldSpecs = util_1.parseFieldSpecs;\n            exports.compareByFieldSpecs = util_1.compareByFieldSpecs;\n            exports.compareByFieldSpec = util_1.compareByFieldSpec;\n            exports.flexibleCompare = util_1.flexibleCompare;\n            exports.computeGreatestUnit = util_1.computeGreatestUnit;\n            exports.divideRangeByDuration = util_1.divideRangeByDuration;\n            exports.divideDurationByDuration = util_1.divideDurationByDuration;\n            exports.multiplyDuration = util_1.multiplyDuration;\n            exports.durationHasTime = util_1.durationHasTime;\n            exports.log = util_1.log;\n            exports.warn = util_1.warn;\n            exports.removeExact = util_1.removeExact;\n            exports.intersectRects = util_1.intersectRects;\n            var date_formatting_1 = __webpack_require__(47);\n            exports.formatDate = date_formatting_1.formatDate;\n            exports.formatRange = date_formatting_1.formatRange;\n            exports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;\n            var locale_1 = __webpack_require__(31);\n            exports.datepickerLocale = locale_1.datepickerLocale;\n            exports.locale = locale_1.locale;\n            var moment_ext_1 = __webpack_require__(10);\n            exports.moment = moment_ext_1.default;\n            var EmitterMixin_1 = __webpack_require__(11);\n            exports.EmitterMixin = EmitterMixin_1.default;\n            var ListenerMixin_1 = __webpack_require__(7);\n            exports.ListenerMixin = ListenerMixin_1.default;\n            var Model_1 = __webpack_require__(48);\n            exports.Model = Model_1.default;\n            var Constraints_1 = __webpack_require__(207);\n            exports.Constraints = Constraints_1.default;\n            var UnzonedRange_1 = __webpack_require__(5);\n            exports.UnzonedRange = UnzonedRange_1.default;\n            var ComponentFootprint_1 = __webpack_require__(12);\n            exports.ComponentFootprint = ComponentFootprint_1.default;\n            var BusinessHourGenerator_1 = __webpack_require__(212);\n            exports.BusinessHourGenerator = BusinessHourGenerator_1.default;\n            var EventDef_1 = __webpack_require__(34);\n            exports.EventDef = EventDef_1.default;\n            var EventDefMutation_1 = __webpack_require__(37);\n            exports.EventDefMutation = EventDefMutation_1.default;\n            var EventSourceParser_1 = __webpack_require__(38);\n            exports.EventSourceParser = EventSourceParser_1.default;\n            var EventSource_1 = __webpack_require__(6);\n            exports.EventSource = EventSource_1.default;\n            var ThemeRegistry_1 = __webpack_require__(51);\n            exports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem;\n            var EventInstanceGroup_1 = __webpack_require__(18);\n            exports.EventInstanceGroup = EventInstanceGroup_1.default;\n            var ArrayEventSource_1 = __webpack_require__(52);\n            exports.ArrayEventSource = ArrayEventSource_1.default;\n            var FuncEventSource_1 = __webpack_require__(215);\n            exports.FuncEventSource = FuncEventSource_1.default;\n            var JsonFeedEventSource_1 = __webpack_require__(216);\n            exports.JsonFeedEventSource = JsonFeedEventSource_1.default;\n            var EventFootprint_1 = __webpack_require__(36);\n            exports.EventFootprint = EventFootprint_1.default;\n            var Class_1 = __webpack_require__(33);\n            exports.Class = Class_1.default;\n            var Mixin_1 = __webpack_require__(14);\n            exports.Mixin = Mixin_1.default;\n            var CoordCache_1 = __webpack_require__(53);\n            exports.CoordCache = CoordCache_1.default;\n            var DragListener_1 = __webpack_require__(54);\n            exports.DragListener = DragListener_1.default;\n            var Promise_1 = __webpack_require__(20);\n            exports.Promise = Promise_1.default;\n            var TaskQueue_1 = __webpack_require__(217);\n            exports.TaskQueue = TaskQueue_1.default;\n            var RenderQueue_1 = __webpack_require__(218);\n            exports.RenderQueue = RenderQueue_1.default;\n            var Scroller_1 = __webpack_require__(39);\n            exports.Scroller = Scroller_1.default;\n            var Theme_1 = __webpack_require__(19);\n            exports.Theme = Theme_1.default;\n            var DateComponent_1 = __webpack_require__(219);\n            exports.DateComponent = DateComponent_1.default;\n            var InteractiveDateComponent_1 = __webpack_require__(40);\n            exports.InteractiveDateComponent = InteractiveDateComponent_1.default;\n            var Calendar_1 = __webpack_require__(220);\n            exports.Calendar = Calendar_1.default;\n            var View_1 = __webpack_require__(41);\n            exports.View = View_1.default;\n            var ViewRegistry_1 = __webpack_require__(22);\n            exports.defineView = ViewRegistry_1.defineView;\n            exports.getViewConfig = ViewRegistry_1.getViewConfig;\n            var DayTableMixin_1 = __webpack_require__(55);\n            exports.DayTableMixin = DayTableMixin_1.default;\n            var BusinessHourRenderer_1 = __webpack_require__(56);\n            exports.BusinessHourRenderer = BusinessHourRenderer_1.default;\n            var EventRenderer_1 = __webpack_require__(42);\n            exports.EventRenderer = EventRenderer_1.default;\n            var FillRenderer_1 = __webpack_require__(57);\n            exports.FillRenderer = FillRenderer_1.default;\n            var HelperRenderer_1 = __webpack_require__(58);\n            exports.HelperRenderer = HelperRenderer_1.default;\n            var ExternalDropping_1 = __webpack_require__(222);\n            exports.ExternalDropping = ExternalDropping_1.default;\n            var EventResizing_1 = __webpack_require__(223);\n            exports.EventResizing = EventResizing_1.default;\n            var EventPointing_1 = __webpack_require__(59);\n            exports.EventPointing = EventPointing_1.default;\n            var EventDragging_1 = __webpack_require__(224);\n            exports.EventDragging = EventDragging_1.default;\n            var DateSelecting_1 = __webpack_require__(225);\n            exports.DateSelecting = DateSelecting_1.default;\n            var StandardInteractionsMixin_1 = __webpack_require__(60);\n            exports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;\n            var AgendaView_1 = __webpack_require__(226);\n            exports.AgendaView = AgendaView_1.default;\n            var TimeGrid_1 = __webpack_require__(227);\n            exports.TimeGrid = TimeGrid_1.default;\n            var DayGrid_1 = __webpack_require__(61);\n            exports.DayGrid = DayGrid_1.default;\n            var BasicView_1 = __webpack_require__(62);\n            exports.BasicView = BasicView_1.default;\n            var MonthView_1 = __webpack_require__(229);\n            exports.MonthView = MonthView_1.default;\n            var ListView_1 = __webpack_require__(230);\n            exports.ListView = ListView_1.default;\n            /***/ \n        }),\n        /* 17 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var UnzonedRange_1 = __webpack_require__(5);\n            /*\n            Meant to be immutable\n            */\n            var EventDateProfile = /*@__PURE__*/ (function () {\n                function EventDateProfile(start, end, calendar) {\n                    this.start = start;\n                    this.end = end || null;\n                    this.unzonedRange = this.buildUnzonedRange(calendar);\n                }\n                /*\n                Needs an EventSource object\n                */\n                EventDateProfile.parse = function (rawProps, source) {\n                    var startInput = rawProps.start || rawProps.date;\n                    var endInput = rawProps.end;\n                    if (!startInput) {\n                        return false;\n                    }\n                    var calendar = source.calendar;\n                    var start = calendar.moment(startInput);\n                    var end = endInput ? calendar.moment(endInput) : null;\n                    var forcedAllDay = rawProps.allDay;\n                    var forceEventDuration = calendar.opt('forceEventDuration');\n                    if (!start.isValid()) {\n                        return false;\n                    }\n                    if (end && (!end.isValid() || !end.isAfter(start))) {\n                        end = null;\n                    }\n                    if (forcedAllDay == null) {\n                        forcedAllDay = source.allDayDefault;\n                        if (forcedAllDay == null) {\n                            forcedAllDay = calendar.opt('allDayDefault');\n                        }\n                    }\n                    if (forcedAllDay === true) {\n                        start.stripTime();\n                        if (end) {\n                            end.stripTime();\n                        }\n                    }\n                    else if (forcedAllDay === false) {\n                        if (!start.hasTime()) {\n                            start.time(0);\n                        }\n                        if (end && !end.hasTime()) {\n                            end.time(0);\n                        }\n                    }\n                    if (!end && forceEventDuration) {\n                        end = calendar.getDefaultEventEnd(!start.hasTime(), start);\n                    }\n                    return new EventDateProfile(start, end, calendar);\n                };\n                EventDateProfile.isStandardProp = function (propName) {\n                    return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';\n                };\n                EventDateProfile.prototype.isAllDay = function () {\n                    return !(this.start.hasTime() || (this.end && this.end.hasTime()));\n                };\n                /*\n                Needs a Calendar object\n                */\n                EventDateProfile.prototype.buildUnzonedRange = function (calendar) {\n                    var startMs = this.start.clone().stripZone().valueOf();\n                    var endMs = this.getEnd(calendar).stripZone().valueOf();\n                    return new UnzonedRange_1.default(startMs, endMs);\n                };\n                /*\n                Needs a Calendar object\n                */\n                EventDateProfile.prototype.getEnd = function (calendar) {\n                    return this.end ?\n                        this.end.clone() :\n                        // derive the end from the start and allDay. compute allDay if necessary\n                        calendar.getDefaultEventEnd(this.isAllDay(), this.start);\n                };\n                return EventDateProfile;\n            }());\n            exports.default = EventDateProfile;\n            /***/ \n        }),\n        /* 18 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var UnzonedRange_1 = __webpack_require__(5);\n            var util_1 = __webpack_require__(35);\n            var EventRange_1 = __webpack_require__(211);\n            /*\n            It's expected that there will be at least one EventInstance,\n            OR that an explicitEventDef is assigned.\n            */\n            var EventInstanceGroup = /*@__PURE__*/ (function () {\n                function EventInstanceGroup(eventInstances) {\n                    this.eventInstances = eventInstances || [];\n                }\n                EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {\n                    if (constraintRange) {\n                        return this.sliceNormalRenderRanges(constraintRange);\n                    }\n                    else {\n                        return this.eventInstances.map(util_1.eventInstanceToEventRange);\n                    }\n                };\n                EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {\n                    if (this.isInverse()) {\n                        return this.sliceInverseRenderRanges(constraintRange);\n                    }\n                    else {\n                        return this.sliceNormalRenderRanges(constraintRange);\n                    }\n                };\n                EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {\n                    var eventInstances = this.eventInstances;\n                    var i;\n                    var eventInstance;\n                    var slicedRange;\n                    var slicedEventRanges = [];\n                    for (i = 0; i < eventInstances.length; i++) {\n                        eventInstance = eventInstances[i];\n                        slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);\n                        if (slicedRange) {\n                            slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));\n                        }\n                    }\n                    return slicedEventRanges;\n                };\n                EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {\n                    var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);\n                    var ownerDef = this.getEventDef();\n                    unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);\n                    return unzonedRanges.map(function (unzonedRange) {\n                        return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance\n                    });\n                };\n                EventInstanceGroup.prototype.isInverse = function () {\n                    return this.getEventDef().hasInverseRendering();\n                };\n                EventInstanceGroup.prototype.getEventDef = function () {\n                    return this.explicitEventDef || this.eventInstances[0].def;\n                };\n                return EventInstanceGroup;\n            }());\n            exports.default = EventInstanceGroup;\n            /***/ \n        }),\n        /* 19 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var Theme = /*@__PURE__*/ (function () {\n                function Theme(optionsManager) {\n                    this.optionsManager = optionsManager;\n                    this.processIconOverride();\n                }\n                Theme.prototype.processIconOverride = function () {\n                    if (this.iconOverrideOption) {\n                        this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));\n                    }\n                };\n                Theme.prototype.setIconOverride = function (iconOverrideHash) {\n                    var iconClassesCopy;\n                    var buttonName;\n                    if ($.isPlainObject(iconOverrideHash)) {\n                        iconClassesCopy = $.extend({}, this.iconClasses);\n                        for (buttonName in iconOverrideHash) {\n                            iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n                        }\n                        this.iconClasses = iconClassesCopy;\n                    }\n                    else if (iconOverrideHash === false) {\n                        this.iconClasses = {};\n                    }\n                };\n                Theme.prototype.applyIconOverridePrefix = function (className) {\n                    var prefix = this.iconOverridePrefix;\n                    if (prefix && className.indexOf(prefix) !== 0) {\n                        className = prefix + className;\n                    }\n                    return className;\n                };\n                Theme.prototype.getClass = function (key) {\n                    return this.classes[key] || '';\n                };\n                Theme.prototype.getIconClass = function (buttonName) {\n                    var className = this.iconClasses[buttonName];\n                    if (className) {\n                        return this.baseIconClass + ' ' + className;\n                    }\n                    return '';\n                };\n                Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n                    var className;\n                    if (this.iconOverrideCustomButtonOption) {\n                        className = customButtonProps[this.iconOverrideCustomButtonOption];\n                        if (className) {\n                            return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\n                        }\n                    }\n                    return '';\n                };\n                return Theme;\n            }());\n            exports.default = Theme;\n            Theme.prototype.classes = {};\n            Theme.prototype.iconClasses = {};\n            Theme.prototype.baseIconClass = '';\n            Theme.prototype.iconOverridePrefix = '';\n            /***/ \n        }),\n        /* 20 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var PromiseStub = {\n                construct: function (executor) {\n                    var deferred = $.Deferred();\n                    var promise = deferred.promise();\n                    if (typeof executor === 'function') {\n                        executor(function (val) {\n                            deferred.resolve(val);\n                            attachImmediatelyResolvingThen(promise, val);\n                        }, function () {\n                            deferred.reject();\n                            attachImmediatelyRejectingThen(promise);\n                        });\n                    }\n                    return promise;\n                },\n                resolve: function (val) {\n                    var deferred = $.Deferred().resolve(val);\n                    var promise = deferred.promise();\n                    attachImmediatelyResolvingThen(promise, val);\n                    return promise;\n                },\n                reject: function () {\n                    var deferred = $.Deferred().reject();\n                    var promise = deferred.promise();\n                    attachImmediatelyRejectingThen(promise);\n                    return promise;\n                }\n            };\n            exports.default = PromiseStub;\n            function attachImmediatelyResolvingThen(promise, val) {\n                promise.then = function (onResolve) {\n                    if (typeof onResolve === 'function') {\n                        return PromiseStub.resolve(onResolve(val));\n                    }\n                    return promise;\n                };\n            }\n            function attachImmediatelyRejectingThen(promise) {\n                promise.then = function (onResolve, onReject) {\n                    if (typeof onReject === 'function') {\n                        onReject();\n                    }\n                    return promise;\n                };\n            }\n            /***/ \n        }),\n        /* 21 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var exportHooks = __webpack_require__(16);\n            var EmitterMixin_1 = __webpack_require__(11);\n            var ListenerMixin_1 = __webpack_require__(7);\n            exportHooks.touchMouseIgnoreWait = 500;\n            var globalEmitter = null;\n            var neededCount = 0;\n            /*\n            Listens to document and window-level user-interaction events, like touch events and mouse events,\n            and fires these events as-is to whoever is observing a GlobalEmitter.\n            Best when used as a singleton via GlobalEmitter.get()\n            \n            Normalizes mouse/touch events. For examples:\n            - ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\n            - compensates for various buggy scenarios where a touchend does not fire\n            */\n            var GlobalEmitter = /*@__PURE__*/ (function () {\n                function GlobalEmitter() {\n                    this.isTouching = false;\n                    this.mouseIgnoreDepth = 0;\n                }\n                // gets the singleton\n                GlobalEmitter.get = function () {\n                    if (!globalEmitter) {\n                        globalEmitter = new GlobalEmitter();\n                        globalEmitter.bind();\n                    }\n                    return globalEmitter;\n                };\n                // called when an object knows it will need a GlobalEmitter in the near future.\n                GlobalEmitter.needed = function () {\n                    GlobalEmitter.get(); // ensures globalEmitter\n                    neededCount++;\n                };\n                // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\n                GlobalEmitter.unneeded = function () {\n                    neededCount--;\n                    if (!neededCount) {\n                        globalEmitter.unbind();\n                        globalEmitter = null;\n                    }\n                };\n                GlobalEmitter.prototype.bind = function () {\n                    var _this = this;\n                    this.listenTo($(document), {\n                        touchstart: this.handleTouchStart,\n                        touchcancel: this.handleTouchCancel,\n                        touchend: this.handleTouchEnd,\n                        mousedown: this.handleMouseDown,\n                        mousemove: this.handleMouseMove,\n                        mouseup: this.handleMouseUp,\n                        click: this.handleClick,\n                        selectstart: this.handleSelectStart,\n                        contextmenu: this.handleContextMenu\n                    });\n                    // because we need to call preventDefault\n                    // because https://www.chromestatus.com/features/5093566007214080\n                    // TODO: investigate performance because this is a global handler\n                    window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {\n                        _this.handleTouchMove($.Event(ev));\n                    }, { passive: false } // allows preventDefault()\n                    );\n                    // attach a handler to get called when ANY scroll action happens on the page.\n                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                    // http://stackoverflow.com/a/32954565/96342\n                    window.addEventListener('scroll', this.handleScrollProxy = function (ev) {\n                        _this.handleScroll($.Event(ev));\n                    }, true // useCapture\n                    );\n                };\n                GlobalEmitter.prototype.unbind = function () {\n                    this.stopListeningTo($(document));\n                    window.removeEventListener('touchmove', this.handleTouchMoveProxy);\n                    window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture\n                    );\n                };\n                // Touch Handlers\n                // -----------------------------------------------------------------------------------------------------------------\n                GlobalEmitter.prototype.handleTouchStart = function (ev) {\n                    // if a previous touch interaction never ended with a touchend, then implicitly end it,\n                    // but since a new touch interaction is about to begin, don't start the mouse ignore period.\n                    this.stopTouch(ev, true); // skipMouseIgnore=true\n                    this.isTouching = true;\n                    this.trigger('touchstart', ev);\n                };\n                GlobalEmitter.prototype.handleTouchMove = function (ev) {\n                    if (this.isTouching) {\n                        this.trigger('touchmove', ev);\n                    }\n                };\n                GlobalEmitter.prototype.handleTouchCancel = function (ev) {\n                    if (this.isTouching) {\n                        this.trigger('touchcancel', ev);\n                        // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\n                        // If touchend fires later, it won't have any effect b/c isTouching will be false.\n                        this.stopTouch(ev);\n                    }\n                };\n                GlobalEmitter.prototype.handleTouchEnd = function (ev) {\n                    this.stopTouch(ev);\n                };\n                // Mouse Handlers\n                // -----------------------------------------------------------------------------------------------------------------\n                GlobalEmitter.prototype.handleMouseDown = function (ev) {\n                    if (!this.shouldIgnoreMouse()) {\n                        this.trigger('mousedown', ev);\n                    }\n                };\n                GlobalEmitter.prototype.handleMouseMove = function (ev) {\n                    if (!this.shouldIgnoreMouse()) {\n                        this.trigger('mousemove', ev);\n                    }\n                };\n                GlobalEmitter.prototype.handleMouseUp = function (ev) {\n                    if (!this.shouldIgnoreMouse()) {\n                        this.trigger('mouseup', ev);\n                    }\n                };\n                GlobalEmitter.prototype.handleClick = function (ev) {\n                    if (!this.shouldIgnoreMouse()) {\n                        this.trigger('click', ev);\n                    }\n                };\n                // Misc Handlers\n                // -----------------------------------------------------------------------------------------------------------------\n                GlobalEmitter.prototype.handleSelectStart = function (ev) {\n                    this.trigger('selectstart', ev);\n                };\n                GlobalEmitter.prototype.handleContextMenu = function (ev) {\n                    this.trigger('contextmenu', ev);\n                };\n                GlobalEmitter.prototype.handleScroll = function (ev) {\n                    this.trigger('scroll', ev);\n                };\n                // Utils\n                // -----------------------------------------------------------------------------------------------------------------\n                GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {\n                    if (skipMouseIgnore === void 0) {\n                        skipMouseIgnore = false;\n                    }\n                    if (this.isTouching) {\n                        this.isTouching = false;\n                        this.trigger('touchend', ev);\n                        if (!skipMouseIgnore) {\n                            this.startTouchMouseIgnore();\n                        }\n                    }\n                };\n                GlobalEmitter.prototype.startTouchMouseIgnore = function () {\n                    var _this = this;\n                    var wait = exportHooks.touchMouseIgnoreWait;\n                    if (wait) {\n                        this.mouseIgnoreDepth++;\n                        setTimeout(function () {\n                            _this.mouseIgnoreDepth--;\n                        }, wait);\n                    }\n                };\n                GlobalEmitter.prototype.shouldIgnoreMouse = function () {\n                    return this.isTouching || Boolean(this.mouseIgnoreDepth);\n                };\n                return GlobalEmitter;\n            }());\n            exports.default = GlobalEmitter;\n            ListenerMixin_1.default.mixInto(GlobalEmitter);\n            EmitterMixin_1.default.mixInto(GlobalEmitter);\n            /***/ \n        }),\n        /* 22 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var exportHooks = __webpack_require__(16);\n            exports.viewHash = {};\n            exportHooks.views = exports.viewHash;\n            function defineView(viewName, viewConfig) {\n                exports.viewHash[viewName] = viewConfig;\n            }\n            exports.defineView = defineView;\n            function getViewConfig(viewName) {\n                return exports.viewHash[viewName];\n            }\n            exports.getViewConfig = getViewConfig;\n            /***/ \n        }),\n        /* 23 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var DragListener_1 = __webpack_require__(54);\n            /* Tracks mouse movements over a component and raises events about which hit the mouse is over.\n            ------------------------------------------------------------------------------------------------------------------------\n            options:\n            - subjectEl\n            - subjectCenter\n            */\n            var HitDragListener = (function (_super) {\n                tslib_1.__extends(HitDragListener, _super);\n                function HitDragListener(component, options) {\n                    var _this = _super.call(this, options) || this;\n                    _this.component = component;\n                    return _this;\n                }\n                // Called when drag listening starts (but a real drag has not necessarily began).\n                // ev might be undefined if dragging was started manually.\n                HitDragListener.prototype.handleInteractionStart = function (ev) {\n                    var subjectEl = this.subjectEl;\n                    var subjectRect;\n                    var origPoint;\n                    var point;\n                    this.component.hitsNeeded();\n                    this.computeScrollBounds(); // for autoscroll\n                    if (ev) {\n                        origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };\n                        point = origPoint;\n                        // constrain the point to bounds of the element being dragged\n                        if (subjectEl) {\n                            subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well\n                            point = util_1.constrainPoint(point, subjectRect);\n                        }\n                        this.origHit = this.queryHit(point.left, point.top);\n                        // treat the center of the subject as the collision point?\n                        if (subjectEl && this.options.subjectCenter) {\n                            // only consider the area the subject overlaps the hit. best for large subjects.\n                            // TODO: skip this if hit didn't supply left/right/top/bottom\n                            if (this.origHit) {\n                                subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||\n                                    subjectRect; // in case there is no intersection\n                            }\n                            point = util_1.getRectCenter(subjectRect);\n                        }\n                        this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint\n                    }\n                    else {\n                        this.origHit = null;\n                        this.coordAdjust = null;\n                    }\n                    // call the super-method. do it after origHit has been computed\n                    _super.prototype.handleInteractionStart.call(this, ev);\n                };\n                // Called when the actual drag has started\n                HitDragListener.prototype.handleDragStart = function (ev) {\n                    var hit;\n                    _super.prototype.handleDragStart.call(this, ev);\n                    // might be different from this.origHit if the min-distance is large\n                    hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\n                    // report the initial hit the mouse is over\n                    // especially important if no min-distance and drag starts immediately\n                    if (hit) {\n                        this.handleHitOver(hit);\n                    }\n                };\n                // Called when the drag moves\n                HitDragListener.prototype.handleDrag = function (dx, dy, ev) {\n                    var hit;\n                    _super.prototype.handleDrag.call(this, dx, dy, ev);\n                    hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\n                    if (!isHitsEqual(hit, this.hit)) {\n                        if (this.hit) {\n                            this.handleHitOut();\n                        }\n                        if (hit) {\n                            this.handleHitOver(hit);\n                        }\n                    }\n                };\n                // Called when dragging has been stopped\n                HitDragListener.prototype.handleDragEnd = function (ev) {\n                    this.handleHitDone();\n                    _super.prototype.handleDragEnd.call(this, ev);\n                };\n                // Called when a the mouse has just moved over a new hit\n                HitDragListener.prototype.handleHitOver = function (hit) {\n                    var isOrig = isHitsEqual(hit, this.origHit);\n                    this.hit = hit;\n                    this.trigger('hitOver', this.hit, isOrig, this.origHit);\n                };\n                // Called when the mouse has just moved out of a hit\n                HitDragListener.prototype.handleHitOut = function () {\n                    if (this.hit) {\n                        this.trigger('hitOut', this.hit);\n                        this.handleHitDone();\n                        this.hit = null;\n                    }\n                };\n                // Called after a hitOut. Also called before a dragStop\n                HitDragListener.prototype.handleHitDone = function () {\n                    if (this.hit) {\n                        this.trigger('hitDone', this.hit);\n                    }\n                };\n                // Called when the interaction ends, whether there was a real drag or not\n                HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\n                    _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);\n                    this.origHit = null;\n                    this.hit = null;\n                    this.component.hitsNotNeeded();\n                };\n                // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n                HitDragListener.prototype.handleScrollEnd = function () {\n                    _super.prototype.handleScrollEnd.call(this);\n                    // hits' absolute positions will be in new places after a user's scroll.\n                    // HACK for recomputing.\n                    if (this.isDragging) {\n                        this.component.releaseHits();\n                        this.component.prepareHits();\n                    }\n                };\n                // Gets the hit underneath the coordinates for the given mouse event\n                HitDragListener.prototype.queryHit = function (left, top) {\n                    if (this.coordAdjust) {\n                        left += this.coordAdjust.left;\n                        top += this.coordAdjust.top;\n                    }\n                    return this.component.queryHit(left, top);\n                };\n                return HitDragListener;\n            }(DragListener_1.default));\n            exports.default = HitDragListener;\n            // Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\n            // Two null values will be considered equal, as two \"out of the component\" states are the same.\n            function isHitsEqual(hit0, hit1) {\n                if (!hit0 && !hit1) {\n                    return true;\n                }\n                if (hit0 && hit1) {\n                    return hit0.component === hit1.component &&\n                        isHitPropsWithin(hit0, hit1) &&\n                        isHitPropsWithin(hit1, hit0); // ensures all props are identical\n                }\n                return false;\n            }\n            // Returns true if all of subHit's non-standard properties are within superHit\n            function isHitPropsWithin(subHit, superHit) {\n                for (var propName in subHit) {\n                    if (!/^(component|left|right|top|bottom)$/.test(propName)) {\n                        if (subHit[propName] !== superHit[propName]) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            /***/ \n        }),\n        /* 24 */ ,\n        /* 25 */ ,\n        /* 26 */ ,\n        /* 27 */ ,\n        /* 28 */ ,\n        /* 29 */ ,\n        /* 30 */ ,\n        /* 31 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var exportHooks = __webpack_require__(16);\n            var options_1 = __webpack_require__(32);\n            var util_1 = __webpack_require__(4);\n            exports.localeOptionHash = {};\n            exportHooks.locales = exports.localeOptionHash;\n            // NOTE: can't guarantee any of these computations will run because not every locale has datepicker\n            // configs, so make sure there are English fallbacks for these in the defaults file.\n            var dpComputableOptions = {\n                buttonText: function (dpOptions) {\n                    return {\n                        // the translations sometimes wrongly contain HTML entities\n                        prev: util_1.stripHtmlEntities(dpOptions.prevText),\n                        next: util_1.stripHtmlEntities(dpOptions.nextText),\n                        today: util_1.stripHtmlEntities(dpOptions.currentText)\n                    };\n                },\n                // Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\n                monthYearFormat: function (dpOptions) {\n                    return dpOptions.showMonthAfterYear ?\n                        'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\n                        'MMMM YYYY[' + dpOptions.yearSuffix + ']';\n                }\n            };\n            var momComputableOptions = {\n                // Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\n                dayOfMonthFormat: function (momOptions, fcOptions) {\n                    var format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\n                    // strip the year off the edge, as well as other misc non-whitespace chars\n                    format = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\n                    if (fcOptions.isRTL) {\n                        format += ' ddd'; // for RTL, add day-of-week to end\n                    }\n                    else {\n                        format = 'ddd ' + format; // for LTR, add day-of-week to beginning\n                    }\n                    return format;\n                },\n                // Produces format strings like \"h:mma\" -> \"6:00pm\"\n                mediumTimeFormat: function (momOptions) {\n                    return momOptions.longDateFormat('LT')\n                        .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n                },\n                // Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\n                smallTimeFormat: function (momOptions) {\n                    return momOptions.longDateFormat('LT')\n                        .replace(':mm', '(:mm)')\n                        .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n                        .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n                },\n                // Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\n                extraSmallTimeFormat: function (momOptions) {\n                    return momOptions.longDateFormat('LT')\n                        .replace(':mm', '(:mm)')\n                        .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n                        .replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\n                },\n                // Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\n                hourFormat: function (momOptions) {\n                    return momOptions.longDateFormat('LT')\n                        .replace(':mm', '')\n                        .replace(/(\\Wmm)$/, '') // like above, but for foreign locales\n                        .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n                },\n                // Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\n                noMeridiemTimeFormat: function (momOptions) {\n                    return momOptions.longDateFormat('LT')\n                        .replace(/\\s*a$/i, ''); // remove trailing AM/PM\n                }\n            };\n            // options that should be computed off live calendar options (considers override options)\n            // TODO: best place for this? related to locale?\n            // TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\n            var instanceComputableOptions = {\n                // Produces format strings for results like \"Mo 16\"\n                smallDayDateFormat: function (options) {\n                    return options.isRTL ?\n                        'D dd' :\n                        'dd D';\n                },\n                // Produces format strings for results like \"Wk 5\"\n                weekFormat: function (options) {\n                    return options.isRTL ?\n                        'w[ ' + options.weekNumberTitle + ']' :\n                        '[' + options.weekNumberTitle + ' ]w';\n                },\n                // Produces format strings for results like \"Wk5\"\n                smallWeekFormat: function (options) {\n                    return options.isRTL ?\n                        'w[' + options.weekNumberTitle + ']' :\n                        '[' + options.weekNumberTitle + ']w';\n                }\n            };\n            // TODO: make these computable properties in optionsManager\n            function populateInstanceComputableOptions(options) {\n                $.each(instanceComputableOptions, function (name, func) {\n                    if (options[name] == null) {\n                        options[name] = func(options);\n                    }\n                });\n            }\n            exports.populateInstanceComputableOptions = populateInstanceComputableOptions;\n            // Initialize jQuery UI datepicker translations while using some of the translations\n            // Will set this as the default locales for datepicker.\n            function datepickerLocale(localeCode, dpLocaleCode, dpOptions) {\n                // get the FullCalendar internal option hash for this locale. create if necessary\n                var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\n                // transfer some simple options from datepicker to fc\n                fcOptions.isRTL = dpOptions.isRTL;\n                fcOptions.weekNumberTitle = dpOptions.weekHeader;\n                // compute some more complex options from datepicker\n                $.each(dpComputableOptions, function (name, func) {\n                    fcOptions[name] = func(dpOptions);\n                });\n                var jqDatePicker = $.datepicker;\n                // is jQuery UI Datepicker is on the page?\n                if (jqDatePicker) {\n                    // Register the locale data.\n                    // FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\n                    // does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\n                    // Make an alias so the locale can be referenced either way.\n                    jqDatePicker.regional[dpLocaleCode] =\n                        jqDatePicker.regional[localeCode] = // alias\n                            dpOptions;\n                    // Alias 'en' to the default locale data. Do this every time.\n                    jqDatePicker.regional.en = jqDatePicker.regional[''];\n                    // Set as Datepicker's global defaults.\n                    jqDatePicker.setDefaults(dpOptions);\n                }\n            }\n            exports.datepickerLocale = datepickerLocale;\n            // Sets FullCalendar-specific translations. Will set the locales as the global default.\n            function locale(localeCode, newFcOptions) {\n                var fcOptions;\n                var momOptions;\n                // get the FullCalendar internal option hash for this locale. create if necessary\n                fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\n                // provided new options for this locales? merge them in\n                if (newFcOptions) {\n                    fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);\n                }\n                // compute locale options that weren't defined.\n                // always do this. newFcOptions can be undefined when initializing from i18n file,\n                // so no way to tell if this is an initialization or a default-setting.\n                momOptions = getMomentLocaleData(localeCode); // will fall back to en\n                $.each(momComputableOptions, function (name, func) {\n                    if (fcOptions[name] == null) {\n                        fcOptions[name] = (func)(momOptions, fcOptions);\n                    }\n                });\n                // set it as the default locale for FullCalendar\n                options_1.globalDefaults.locale = localeCode;\n            }\n            exports.locale = locale;\n            // Returns moment's internal locale data. If doesn't exist, returns English.\n            function getMomentLocaleData(localeCode) {\n                return moment.localeData(localeCode) || moment.localeData('en');\n            }\n            exports.getMomentLocaleData = getMomentLocaleData;\n            // Initialize English by forcing computation of moment-derived options.\n            // Also, sets it as the default.\n            locale('en', options_1.englishDefaults);\n            /***/ \n        }),\n        /* 32 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var util_1 = __webpack_require__(4);\n            exports.globalDefaults = {\n                titleRangeSeparator: ' \\u2013 ',\n                monthYearFormat: 'MMMM YYYY',\n                defaultTimedEventDuration: '02:00:00',\n                defaultAllDayEventDuration: { days: 1 },\n                forceEventDuration: false,\n                nextDayThreshold: '09:00:00',\n                // display\n                columnHeader: true,\n                defaultView: 'month',\n                aspectRatio: 1.35,\n                header: {\n                    left: 'title',\n                    center: '',\n                    right: 'today prev,next'\n                },\n                weekends: true,\n                weekNumbers: false,\n                weekNumberTitle: 'W',\n                weekNumberCalculation: 'local',\n                // editable: false,\n                // nowIndicator: false,\n                scrollTime: '06:00:00',\n                minTime: '00:00:00',\n                maxTime: '24:00:00',\n                showNonCurrentDates: true,\n                // event ajax\n                lazyFetching: true,\n                startParam: 'start',\n                endParam: 'end',\n                timezoneParam: 'timezone',\n                timezone: false,\n                // allDayDefault: undefined,\n                // locale\n                locale: null,\n                isRTL: false,\n                buttonText: {\n                    prev: 'prev',\n                    next: 'next',\n                    prevYear: 'prev year',\n                    nextYear: 'next year',\n                    year: 'year',\n                    today: 'today',\n                    month: 'month',\n                    week: 'week',\n                    day: 'day'\n                },\n                // buttonIcons: null,\n                allDayText: 'all-day',\n                // allows setting a min-height to the event segment to prevent short events overlapping each other\n                agendaEventMinHeight: 0,\n                // jquery-ui theming\n                theme: false,\n                // themeButtonIcons: null,\n                // eventResizableFromStart: false,\n                dragOpacity: .75,\n                dragRevertDuration: 500,\n                dragScroll: true,\n                // selectable: false,\n                unselectAuto: true,\n                // selectMinDistance: 0,\n                dropAccept: '*',\n                eventOrder: 'title',\n                // eventRenderWait: null,\n                eventLimit: false,\n                eventLimitText: 'more',\n                eventLimitClick: 'popover',\n                dayPopoverFormat: 'LL',\n                handleWindowResize: true,\n                windowResizeDelay: 100,\n                longPressDelay: 1000\n            };\n            exports.englishDefaults = {\n                dayPopoverFormat: 'dddd, MMMM D'\n            };\n            exports.rtlDefaults = {\n                header: {\n                    left: 'next,prev today',\n                    center: '',\n                    right: 'title'\n                },\n                buttonIcons: {\n                    prev: 'right-single-arrow',\n                    next: 'left-single-arrow',\n                    prevYear: 'right-double-arrow',\n                    nextYear: 'left-double-arrow'\n                },\n                themeButtonIcons: {\n                    prev: 'circle-triangle-e',\n                    next: 'circle-triangle-w',\n                    nextYear: 'seek-prev',\n                    prevYear: 'seek-next'\n                }\n            };\n            var complexOptions = [\n                'header',\n                'footer',\n                'buttonText',\n                'buttonIcons',\n                'themeButtonIcons'\n            ];\n            // Merges an array of option objects into a single object\n            function mergeOptions(optionObjs) {\n                return util_1.mergeProps(optionObjs, complexOptions);\n            }\n            exports.mergeOptions = mergeOptions;\n            /***/ \n        }),\n        /* 33 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            // Class that all other classes will inherit from\n            var Class = /*@__PURE__*/ (function () {\n                function Class() {\n                }\n                // Called on a class to create a subclass.\n                // LIMITATION: cannot provide a constructor!\n                Class.extend = function (members) {\n                    var SubClass = (function (_super) {\n                        tslib_1.__extends(SubClass, _super);\n                        function SubClass() {\n                            return _super !== null && _super.apply(this, arguments) || this;\n                        }\n                        return SubClass;\n                    }(this));\n                    util_1.copyOwnProps(members, SubClass.prototype);\n                    return SubClass;\n                };\n                // Adds new member variables/methods to the class's prototype.\n                // Can be called with another class, or a plain object hash containing new members.\n                Class.mixin = function (members) {\n                    util_1.copyOwnProps(members, this.prototype);\n                };\n                return Class;\n            }());\n            exports.default = Class;\n            /***/ \n        }),\n        /* 34 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var ParsableModelMixin_1 = __webpack_require__(208);\n            var EventDef = /*@__PURE__*/ (function () {\n                function EventDef(source) {\n                    this.source = source;\n                    this.className = [];\n                    this.miscProps = {};\n                }\n                EventDef.parse = function (rawInput, source) {\n                    var def = new this(source);\n                    if (def.applyProps(rawInput)) {\n                        return def;\n                    }\n                    return false;\n                };\n                EventDef.normalizeId = function (id) {\n                    return String(id);\n                };\n                EventDef.generateId = function () {\n                    return '_fc' + (EventDef.uuid++);\n                };\n                EventDef.prototype.clone = function () {\n                    var copy = new this.constructor(this.source);\n                    copy.id = this.id;\n                    copy.rawId = this.rawId;\n                    copy.uid = this.uid; // not really unique anymore :(\n                    EventDef.copyVerbatimStandardProps(this, copy);\n                    copy.className = this.className.slice(); // copy\n                    copy.miscProps = $.extend({}, this.miscProps);\n                    return copy;\n                };\n                EventDef.prototype.hasInverseRendering = function () {\n                    return this.getRendering() === 'inverse-background';\n                };\n                EventDef.prototype.hasBgRendering = function () {\n                    var rendering = this.getRendering();\n                    return rendering === 'inverse-background' || rendering === 'background';\n                };\n                EventDef.prototype.getRendering = function () {\n                    if (this.rendering != null) {\n                        return this.rendering;\n                    }\n                    return this.source.rendering;\n                };\n                EventDef.prototype.getConstraint = function () {\n                    if (this.constraint != null) {\n                        return this.constraint;\n                    }\n                    if (this.source.constraint != null) {\n                        return this.source.constraint;\n                    }\n                    return this.source.calendar.opt('eventConstraint'); // what about View option?\n                };\n                EventDef.prototype.getOverlap = function () {\n                    if (this.overlap != null) {\n                        return this.overlap;\n                    }\n                    if (this.source.overlap != null) {\n                        return this.source.overlap;\n                    }\n                    return this.source.calendar.opt('eventOverlap'); // what about View option?\n                };\n                EventDef.prototype.isStartExplicitlyEditable = function () {\n                    if (this.startEditable != null) {\n                        return this.startEditable;\n                    }\n                    return this.source.startEditable;\n                };\n                EventDef.prototype.isDurationExplicitlyEditable = function () {\n                    if (this.durationEditable != null) {\n                        return this.durationEditable;\n                    }\n                    return this.source.durationEditable;\n                };\n                EventDef.prototype.isExplicitlyEditable = function () {\n                    if (this.editable != null) {\n                        return this.editable;\n                    }\n                    return this.source.editable;\n                };\n                EventDef.prototype.toLegacy = function () {\n                    var obj = $.extend({}, this.miscProps);\n                    obj._id = this.uid;\n                    obj.source = this.source;\n                    obj.className = this.className.slice(); // copy\n                    obj.allDay = this.isAllDay();\n                    if (this.rawId != null) {\n                        obj.id = this.rawId;\n                    }\n                    EventDef.copyVerbatimStandardProps(this, obj);\n                    return obj;\n                };\n                EventDef.prototype.applyManualStandardProps = function (rawProps) {\n                    if (rawProps.id != null) {\n                        this.id = EventDef.normalizeId((this.rawId = rawProps.id));\n                    }\n                    else {\n                        this.id = EventDef.generateId();\n                    }\n                    if (rawProps._id != null) {\n                        this.uid = String(rawProps._id);\n                    }\n                    else {\n                        this.uid = EventDef.generateId();\n                    }\n                    // TODO: converge with EventSource\n                    if ($.isArray(rawProps.className)) {\n                        this.className = rawProps.className;\n                    }\n                    if (typeof rawProps.className === 'string') {\n                        this.className = rawProps.className.split(/\\s+/);\n                    }\n                    return true;\n                };\n                EventDef.prototype.applyMiscProps = function (rawProps) {\n                    $.extend(this.miscProps, rawProps);\n                };\n                EventDef.uuid = 0;\n                EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\n                EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\n                return EventDef;\n            }());\n            exports.default = EventDef;\n            ParsableModelMixin_1.default.mixInto(EventDef);\n            EventDef.defineStandardProps({\n                // not automatically assigned (`false`)\n                _id: false,\n                id: false,\n                className: false,\n                source: false,\n                // automatically assigned (`true`)\n                title: true,\n                url: true,\n                rendering: true,\n                constraint: true,\n                overlap: true,\n                editable: true,\n                startEditable: true,\n                durationEditable: true,\n                color: true,\n                backgroundColor: true,\n                borderColor: true,\n                textColor: true\n            });\n            /***/ \n        }),\n        /* 35 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EventRange_1 = __webpack_require__(211);\n            var EventFootprint_1 = __webpack_require__(36);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            function eventDefsToEventInstances(eventDefs, unzonedRange) {\n                var eventInstances = [];\n                var i;\n                for (i = 0; i < eventDefs.length; i++) {\n                    eventInstances.push.apply(eventInstances, // append\n                    eventDefs[i].buildInstances(unzonedRange));\n                }\n                return eventInstances;\n            }\n            exports.eventDefsToEventInstances = eventDefsToEventInstances;\n            function eventInstanceToEventRange(eventInstance) {\n                return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);\n            }\n            exports.eventInstanceToEventRange = eventInstanceToEventRange;\n            function eventRangeToEventFootprint(eventRange) {\n                return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist\n                );\n            }\n            exports.eventRangeToEventFootprint = eventRangeToEventFootprint;\n            function eventInstanceToUnzonedRange(eventInstance) {\n                return eventInstance.dateProfile.unzonedRange;\n            }\n            exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;\n            function eventFootprintToComponentFootprint(eventFootprint) {\n                return eventFootprint.componentFootprint;\n            }\n            exports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;\n            /***/ \n        }),\n        /* 36 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EventFootprint = /*@__PURE__*/ (function () {\n                function EventFootprint(componentFootprint, eventDef, eventInstance) {\n                    this.componentFootprint = componentFootprint;\n                    this.eventDef = eventDef;\n                    if (eventInstance) {\n                        this.eventInstance = eventInstance;\n                    }\n                }\n                EventFootprint.prototype.getEventLegacy = function () {\n                    return (this.eventInstance || this.eventDef).toLegacy();\n                };\n                return EventFootprint;\n            }());\n            exports.default = EventFootprint;\n            /***/ \n        }),\n        /* 37 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var util_1 = __webpack_require__(4);\n            var EventDateProfile_1 = __webpack_require__(17);\n            var EventDef_1 = __webpack_require__(34);\n            var EventDefDateMutation_1 = __webpack_require__(50);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var EventDefMutation = /*@__PURE__*/ (function () {\n                function EventDefMutation() {\n                }\n                EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {\n                    var eventDef = eventInstance.def;\n                    var dateProps = {};\n                    var standardProps = {};\n                    var miscProps = {};\n                    var verbatimStandardProps = {};\n                    var eventDefId = null;\n                    var className = null;\n                    var propName;\n                    var dateProfile;\n                    var dateMutation;\n                    var defMutation;\n                    for (propName in rawProps) {\n                        if (EventDateProfile_1.default.isStandardProp(propName)) {\n                            dateProps[propName] = rawProps[propName];\n                        }\n                        else if (eventDef.isStandardProp(propName)) {\n                            standardProps[propName] = rawProps[propName];\n                        }\n                        else if (eventDef.miscProps[propName] !== rawProps[propName]) {\n                            miscProps[propName] = rawProps[propName];\n                        }\n                    }\n                    dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);\n                    if (dateProfile) {\n                        dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);\n                    }\n                    if (standardProps.id !== eventDef.id) {\n                        eventDefId = standardProps.id; // only apply if there's a change\n                    }\n                    if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {\n                        className = standardProps.className; // only apply if there's a change\n                    }\n                    EventDef_1.default.copyVerbatimStandardProps(standardProps, // src\n                    verbatimStandardProps // dest\n                    );\n                    defMutation = new EventDefMutation();\n                    defMutation.eventDefId = eventDefId;\n                    defMutation.className = className;\n                    defMutation.verbatimStandardProps = verbatimStandardProps;\n                    defMutation.miscProps = miscProps;\n                    if (dateMutation) {\n                        defMutation.dateMutation = dateMutation;\n                    }\n                    return defMutation;\n                };\n                /*\n                eventDef assumed to be a SingleEventDef.\n                returns an undo function.\n                */\n                EventDefMutation.prototype.mutateSingle = function (eventDef) {\n                    var origDateProfile;\n                    if (this.dateMutation) {\n                        origDateProfile = eventDef.dateProfile;\n                        eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);\n                    }\n                    // can't undo\n                    // TODO: more DRY with EventDef::applyManualStandardProps\n                    if (this.eventDefId != null) {\n                        eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));\n                    }\n                    // can't undo\n                    // TODO: more DRY with EventDef::applyManualStandardProps\n                    if (this.className) {\n                        eventDef.className = this.className;\n                    }\n                    // can't undo\n                    if (this.verbatimStandardProps) {\n                        SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src\n                        eventDef // dest\n                        );\n                    }\n                    // can't undo\n                    if (this.miscProps) {\n                        eventDef.applyMiscProps(this.miscProps);\n                    }\n                    if (origDateProfile) {\n                        return function () {\n                            eventDef.dateProfile = origDateProfile;\n                        };\n                    }\n                    else {\n                        return function () { };\n                    }\n                };\n                EventDefMutation.prototype.setDateMutation = function (dateMutation) {\n                    if (dateMutation && !dateMutation.isEmpty()) {\n                        this.dateMutation = dateMutation;\n                    }\n                    else {\n                        this.dateMutation = null;\n                    }\n                };\n                EventDefMutation.prototype.isEmpty = function () {\n                    return !this.dateMutation;\n                };\n                return EventDefMutation;\n            }());\n            exports.default = EventDefMutation;\n            /***/ \n        }),\n        /* 38 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            exports.default = {\n                sourceClasses: [],\n                registerClass: function (EventSourceClass) {\n                    this.sourceClasses.unshift(EventSourceClass); // give highest priority\n                },\n                parse: function (rawInput, calendar) {\n                    var sourceClasses = this.sourceClasses;\n                    var i;\n                    var eventSource;\n                    for (i = 0; i < sourceClasses.length; i++) {\n                        eventSource = sourceClasses[i].parse(rawInput, calendar);\n                        if (eventSource) {\n                            return eventSource;\n                        }\n                    }\n                }\n            };\n            /***/ \n        }),\n        /* 39 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Class_1 = __webpack_require__(33);\n            /*\n            Embodies a div that has potential scrollbars\n            */\n            var Scroller = (function (_super) {\n                tslib_1.__extends(Scroller, _super);\n                function Scroller(options) {\n                    var _this = _super.call(this) || this;\n                    options = options || {};\n                    _this.overflowX = options.overflowX || options.overflow || 'auto';\n                    _this.overflowY = options.overflowY || options.overflow || 'auto';\n                    return _this;\n                }\n                Scroller.prototype.render = function () {\n                    this.el = this.renderEl();\n                    this.applyOverflow();\n                };\n                Scroller.prototype.renderEl = function () {\n                    return (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\n                };\n                // sets to natural height, unlocks overflow\n                Scroller.prototype.clear = function () {\n                    this.setHeight('auto');\n                    this.applyOverflow();\n                };\n                Scroller.prototype.destroy = function () {\n                    this.el.remove();\n                };\n                // Overflow\n                // -----------------------------------------------------------------------------------------------------------------\n                Scroller.prototype.applyOverflow = function () {\n                    this.scrollEl.css({\n                        'overflow-x': this.overflowX,\n                        'overflow-y': this.overflowY\n                    });\n                };\n                // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\n                // Useful for preserving scrollbar widths regardless of future resizes.\n                // Can pass in scrollbarWidths for optimization.\n                Scroller.prototype.lockOverflow = function (scrollbarWidths) {\n                    var overflowX = this.overflowX;\n                    var overflowY = this.overflowY;\n                    scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\n                    if (overflowX === 'auto') {\n                        overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\n                            // OR scrolling pane with massless scrollbars?\n                            this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';\n                    }\n                    if (overflowY === 'auto') {\n                        overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\n                            // OR scrolling pane with massless scrollbars?\n                            this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';\n                    }\n                    this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\n                };\n                // Getters / Setters\n                // -----------------------------------------------------------------------------------------------------------------\n                Scroller.prototype.setHeight = function (height) {\n                    this.scrollEl.height(height);\n                };\n                Scroller.prototype.getScrollTop = function () {\n                    return this.scrollEl.scrollTop();\n                };\n                Scroller.prototype.setScrollTop = function (top) {\n                    this.scrollEl.scrollTop(top);\n                };\n                Scroller.prototype.getClientWidth = function () {\n                    return this.scrollEl[0].clientWidth;\n                };\n                Scroller.prototype.getClientHeight = function () {\n                    return this.scrollEl[0].clientHeight;\n                };\n                Scroller.prototype.getScrollbarWidths = function () {\n                    return util_1.getScrollbarWidths(this.scrollEl);\n                };\n                return Scroller;\n            }(Class_1.default));\n            exports.default = Scroller;\n            /***/ \n        }),\n        /* 40 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var DateComponent_1 = __webpack_require__(219);\n            var GlobalEmitter_1 = __webpack_require__(21);\n            var InteractiveDateComponent = (function (_super) {\n                tslib_1.__extends(InteractiveDateComponent, _super);\n                function InteractiveDateComponent(_view, _options) {\n                    var _this = _super.call(this, _view, _options) || this;\n                    // self-config, overridable by subclasses\n                    _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?\n                    if (_this.dateSelectingClass) {\n                        _this.dateClicking = new _this.dateClickingClass(_this);\n                    }\n                    if (_this.dateSelectingClass) {\n                        _this.dateSelecting = new _this.dateSelectingClass(_this);\n                    }\n                    if (_this.eventPointingClass) {\n                        _this.eventPointing = new _this.eventPointingClass(_this);\n                    }\n                    if (_this.eventDraggingClass && _this.eventPointing) {\n                        _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);\n                    }\n                    if (_this.eventResizingClass && _this.eventPointing) {\n                        _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);\n                    }\n                    if (_this.externalDroppingClass) {\n                        _this.externalDropping = new _this.externalDroppingClass(_this);\n                    }\n                    return _this;\n                }\n                // Sets the container element that the view should render inside of, does global DOM-related initializations,\n                // and renders all the non-date-related content inside.\n                InteractiveDateComponent.prototype.setElement = function (el) {\n                    _super.prototype.setElement.call(this, el);\n                    if (this.dateClicking) {\n                        this.dateClicking.bindToEl(el);\n                    }\n                    if (this.dateSelecting) {\n                        this.dateSelecting.bindToEl(el);\n                    }\n                    this.bindAllSegHandlersToEl(el);\n                };\n                InteractiveDateComponent.prototype.removeElement = function () {\n                    this.endInteractions();\n                    _super.prototype.removeElement.call(this);\n                };\n                InteractiveDateComponent.prototype.executeEventUnrender = function () {\n                    this.endInteractions();\n                    _super.prototype.executeEventUnrender.call(this);\n                };\n                InteractiveDateComponent.prototype.bindGlobalHandlers = function () {\n                    _super.prototype.bindGlobalHandlers.call(this);\n                    if (this.externalDropping) {\n                        this.externalDropping.bindToDocument();\n                    }\n                };\n                InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {\n                    _super.prototype.unbindGlobalHandlers.call(this);\n                    if (this.externalDropping) {\n                        this.externalDropping.unbindFromDocument();\n                    }\n                };\n                InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {\n                    var _this = this;\n                    // attach a handler to the grid's root element.\n                    // jQuery will take care of unregistering them when removeElement gets called.\n                    this.el.on(name, function (ev) {\n                        if (!$(ev.target).is(_this.segSelector + ':not(.fc-helper),' + // directly on an event element\n                            _this.segSelector + ':not(.fc-helper) *,' + // within an event element\n                            '.fc-more,' + // a \"more..\" link\n                            'a[data-goto]' // a clickable nav link\n                        )) {\n                            return handler.call(_this, ev);\n                        }\n                    });\n                };\n                InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {\n                    [\n                        this.eventPointing,\n                        this.eventDragging,\n                        this.eventResizing\n                    ].forEach(function (eventInteraction) {\n                        if (eventInteraction) {\n                            eventInteraction.bindToEl(el);\n                        }\n                    });\n                };\n                InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {\n                    var _this = this;\n                    el.on(name, this.segSelector, function (ev) {\n                        var segEl = $(ev.currentTarget);\n                        if (!segEl.is('.fc-helper')) {\n                            var seg = segEl.data('fc-seg'); // grab segment data. put there by View::renderEventsPayload\n                            if (seg && !_this.shouldIgnoreEventPointing()) {\n                                return handler.call(_this, seg, ev); // context will be the Grid\n                            }\n                        }\n                    });\n                };\n                InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {\n                    // HACK\n                    // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.\n                    return GlobalEmitter_1.default.get().shouldIgnoreMouse();\n                };\n                InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {\n                    var view = this._getView();\n                    // On iOS (and Android?) when a new selection is initiated overtop another selection,\n                    // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\n                    // HACK: simply don't allow this to happen.\n                    // ALSO: prevent selection when an *event* is already raised.\n                    return view.isSelected || view.selectedEvent;\n                };\n                InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {\n                    // only call the handlers if there is not a drag/resize in progress\n                    return (this.eventDragging && this.eventDragging.isDragging) ||\n                        (this.eventResizing && this.eventResizing.isResizing);\n                };\n                InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {\n                    return util_1.getEvIsTouch(ev) &&\n                        !this.canStartResize(seg, ev) &&\n                        (this.isEventDefDraggable(seg.footprint.eventDef) ||\n                            this.isEventDefResizable(seg.footprint.eventDef));\n                };\n                InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {\n                    return !this.canStartResize(seg, ev) &&\n                        this.isEventDefDraggable(seg.footprint.eventDef);\n                };\n                InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {\n                    var view = this._getView();\n                    var eventDef = seg.footprint.eventDef;\n                    return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&\n                        this.isEventDefResizable(eventDef) &&\n                        $(ev.target).is('.fc-resizer');\n                };\n                // Kills all in-progress dragging.\n                // Useful for when public API methods that result in re-rendering are invoked during a drag.\n                // Also useful for when touch devices misbehave and don't fire their touchend.\n                InteractiveDateComponent.prototype.endInteractions = function () {\n                    [\n                        this.dateClicking,\n                        this.dateSelecting,\n                        this.eventPointing,\n                        this.eventDragging,\n                        this.eventResizing\n                    ].forEach(function (interaction) {\n                        if (interaction) {\n                            interaction.end();\n                        }\n                    });\n                };\n                // Event Drag-n-Drop\n                // ---------------------------------------------------------------------------------------------------------------\n                // Computes if the given event is allowed to be dragged by the user\n                InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {\n                    return this.isEventDefStartEditable(eventDef);\n                };\n                InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {\n                    var isEditable = eventDef.isStartExplicitlyEditable();\n                    if (isEditable == null) {\n                        isEditable = this.opt('eventStartEditable');\n                        if (isEditable == null) {\n                            isEditable = this.isEventDefGenerallyEditable(eventDef);\n                        }\n                    }\n                    return isEditable;\n                };\n                InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {\n                    var isEditable = eventDef.isExplicitlyEditable();\n                    if (isEditable == null) {\n                        isEditable = this.opt('editable');\n                    }\n                    return isEditable;\n                };\n                // Event Resizing\n                // ---------------------------------------------------------------------------------------------------------------\n                // Computes if the given event is allowed to be resized from its starting edge\n                InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {\n                    return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);\n                };\n                // Computes if the given event is allowed to be resized from its ending edge\n                InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {\n                    return this.isEventDefResizable(eventDef);\n                };\n                // Computes if the given event is allowed to be resized by the user at all\n                InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {\n                    var isResizable = eventDef.isDurationExplicitlyEditable();\n                    if (isResizable == null) {\n                        isResizable = this.opt('eventDurationEditable');\n                        if (isResizable == null) {\n                            isResizable = this.isEventDefGenerallyEditable(eventDef);\n                        }\n                    }\n                    return isResizable;\n                };\n                // Event Mutation / Constraints\n                // ---------------------------------------------------------------------------------------------------------------\n                // Diffs the two dates, returning a duration, based on granularity of the grid\n                // TODO: port isTimeScale into this system?\n                InteractiveDateComponent.prototype.diffDates = function (a, b) {\n                    if (this.largeUnit) {\n                        return util_1.diffByUnit(a, b, this.largeUnit);\n                    }\n                    else {\n                        return util_1.diffDayTime(a, b);\n                    }\n                };\n                // is it allowed, in relation to the view's validRange?\n                // NOTE: very similar to isExternalInstanceGroupAllowed\n                InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\n                    var view = this._getView();\n                    var dateProfile = this.dateProfile;\n                    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\n                    var i;\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        // TODO: just use getAllEventRanges directly\n                        if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\n                            return false;\n                        }\n                    }\n                    return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);\n                };\n                // NOTE: very similar to isEventInstanceGroupAllowed\n                // when it's a completely anonymous external drag, no event.\n                InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {\n                    var view = this._getView();\n                    var dateProfile = this.dateProfile;\n                    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\n                    var i;\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\n                            return false;\n                        }\n                    }\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        // treat it as a selection\n                        // TODO: pass in eventInstanceGroup instead\n                        //  because we don't want calendar's constraint system to depend on a component's\n                        //  determination of footprints.\n                        if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n                return InteractiveDateComponent;\n            }(DateComponent_1.default));\n            exports.default = InteractiveDateComponent;\n            /***/ \n        }),\n        /* 41 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var RenderQueue_1 = __webpack_require__(218);\n            var DateProfileGenerator_1 = __webpack_require__(221);\n            var InteractiveDateComponent_1 = __webpack_require__(40);\n            var GlobalEmitter_1 = __webpack_require__(21);\n            var UnzonedRange_1 = __webpack_require__(5);\n            /* An abstract class from which other views inherit from\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var View = (function (_super) {\n                tslib_1.__extends(View, _super);\n                function View(calendar, viewSpec) {\n                    var _this = _super.call(this, null, viewSpec.options) || this;\n                    _this.batchRenderDepth = 0;\n                    _this.isSelected = false; // boolean whether a range of time is user-selected or not\n                    _this.calendar = calendar;\n                    _this.viewSpec = viewSpec;\n                    // shortcuts\n                    _this.type = viewSpec.type;\n                    // .name is deprecated\n                    _this.name = _this.type;\n                    _this.initRenderQueue();\n                    _this.initHiddenDays();\n                    _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);\n                    _this.bindBaseRenderHandlers();\n                    _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));\n                    // legacy\n                    if (_this['initialize']) {\n                        _this['initialize']();\n                    }\n                    return _this;\n                }\n                View.prototype._getView = function () {\n                    return this;\n                };\n                // Retrieves an option with the given name\n                View.prototype.opt = function (name) {\n                    return this.options[name];\n                };\n                /* Render Queue\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.initRenderQueue = function () {\n                    this.renderQueue = new RenderQueue_1.default({\n                        event: this.opt('eventRenderWait')\n                    });\n                    this.renderQueue.on('start', this.onRenderQueueStart.bind(this));\n                    this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));\n                    this.on('before:change', this.startBatchRender);\n                    this.on('change', this.stopBatchRender);\n                };\n                View.prototype.onRenderQueueStart = function () {\n                    this.calendar.freezeContentHeight();\n                    this.addScroll(this.queryScroll());\n                };\n                View.prototype.onRenderQueueStop = function () {\n                    if (this.calendar.updateViewSize()) {\n                        this.popScroll();\n                    }\n                    this.calendar.thawContentHeight();\n                };\n                View.prototype.startBatchRender = function () {\n                    if (!(this.batchRenderDepth++)) {\n                        this.renderQueue.pause();\n                    }\n                };\n                View.prototype.stopBatchRender = function () {\n                    if (!(--this.batchRenderDepth)) {\n                        this.renderQueue.resume();\n                    }\n                };\n                View.prototype.requestRender = function (func, namespace, actionType) {\n                    this.renderQueue.queue(func, namespace, actionType);\n                };\n                // given func will auto-bind to `this`\n                View.prototype.whenSizeUpdated = function (func) {\n                    if (this.renderQueue.isRunning) {\n                        this.renderQueue.one('stop', func.bind(this));\n                    }\n                    else {\n                        func.call(this);\n                    }\n                };\n                /* Title and Date Formatting\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Computes what the title at the top of the calendar should be for this view\n                View.prototype.computeTitle = function (dateProfile) {\n                    var unzonedRange;\n                    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n                    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n                        unzonedRange = dateProfile.currentUnzonedRange;\n                    }\n                    else {\n                        unzonedRange = dateProfile.activeUnzonedRange;\n                    }\n                    return this.formatRange({\n                        start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),\n                        end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)\n                    }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));\n                };\n                // Generates the format string that should be used to generate the title for the current date range.\n                // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n                View.prototype.computeTitleFormat = function (dateProfile) {\n                    var currentRangeUnit = dateProfile.currentRangeUnit;\n                    if (currentRangeUnit === 'year') {\n                        return 'YYYY';\n                    }\n                    else if (currentRangeUnit === 'month') {\n                        return this.opt('monthYearFormat'); // like \"September 2014\"\n                    }\n                    else if (dateProfile.currentUnzonedRange.as('days') > 1) {\n                        return 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n                    }\n                    else {\n                        return 'LL'; // one day. longer, like \"September 9 2014\"\n                    }\n                };\n                // Date Setting/Unsetting\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.setDate = function (date) {\n                    var currentDateProfile = this.get('dateProfile');\n                    var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true\n                    if (!currentDateProfile ||\n                        !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {\n                        this.set('dateProfile', newDateProfile);\n                    }\n                };\n                View.prototype.unsetDate = function () {\n                    this.unset('dateProfile');\n                };\n                // Event Data\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.fetchInitialEvents = function (dateProfile) {\n                    var calendar = this.calendar;\n                    var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;\n                    return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));\n                };\n                View.prototype.bindEventChanges = function () {\n                    this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event\n                };\n                View.prototype.unbindEventChanges = function () {\n                    this.stopListeningTo(this.calendar, 'eventsReset');\n                };\n                View.prototype.setEvents = function (eventsPayload) {\n                    this.set('currentEvents', eventsPayload);\n                    this.set('hasEvents', true);\n                };\n                View.prototype.unsetEvents = function () {\n                    this.unset('currentEvents');\n                    this.unset('hasEvents');\n                };\n                View.prototype.resetEvents = function (eventsPayload) {\n                    this.startBatchRender();\n                    this.unsetEvents();\n                    this.setEvents(eventsPayload);\n                    this.stopBatchRender();\n                };\n                // Date High-level Rendering\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.requestDateRender = function (dateProfile) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeDateRender(dateProfile);\n                    }, 'date', 'init');\n                };\n                View.prototype.requestDateUnrender = function () {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeDateUnrender();\n                    }, 'date', 'destroy');\n                };\n                // if dateProfile not specified, uses current\n                View.prototype.executeDateRender = function (dateProfile) {\n                    _super.prototype.executeDateRender.call(this, dateProfile);\n                    if (this['render']) {\n                        this['render'](); // TODO: deprecate\n                    }\n                    this.trigger('datesRendered');\n                    this.addScroll({ isDateInit: true });\n                    this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon\n                };\n                View.prototype.executeDateUnrender = function () {\n                    this.unselect();\n                    this.stopNowIndicator();\n                    this.trigger('before:datesUnrendered');\n                    if (this['destroy']) {\n                        this['destroy'](); // TODO: deprecate\n                    }\n                    _super.prototype.executeDateUnrender.call(this);\n                };\n                // \"Base\" rendering\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.bindBaseRenderHandlers = function () {\n                    var _this = this;\n                    this.on('datesRendered', function () {\n                        _this.whenSizeUpdated(_this.triggerViewRender);\n                    });\n                    this.on('before:datesUnrendered', function () {\n                        _this.triggerViewDestroy();\n                    });\n                };\n                View.prototype.triggerViewRender = function () {\n                    this.publiclyTrigger('viewRender', {\n                        context: this,\n                        args: [this, this.el]\n                    });\n                };\n                View.prototype.triggerViewDestroy = function () {\n                    this.publiclyTrigger('viewDestroy', {\n                        context: this,\n                        args: [this, this.el]\n                    });\n                };\n                // Event High-level Rendering\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.requestEventsRender = function (eventsPayload) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.executeEventRender(eventsPayload);\n                        _this.whenSizeUpdated(_this.triggerAfterEventsRendered);\n                    }, 'event', 'init');\n                };\n                View.prototype.requestEventsUnrender = function () {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.triggerBeforeEventsDestroyed();\n                        _this.executeEventUnrender();\n                    }, 'event', 'destroy');\n                };\n                // Business Hour High-level Rendering\n                // -----------------------------------------------------------------------------------------------------------------\n                View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.renderBusinessHours(businessHourGenerator);\n                    }, 'businessHours', 'init');\n                };\n                View.prototype.requestBusinessHoursUnrender = function () {\n                    var _this = this;\n                    this.requestRender(function () {\n                        _this.unrenderBusinessHours();\n                    }, 'businessHours', 'destroy');\n                };\n                // Misc view rendering utils\n                // -----------------------------------------------------------------------------------------------------------------\n                // Binds DOM handlers to elements that reside outside the view container, such as the document\n                View.prototype.bindGlobalHandlers = function () {\n                    _super.prototype.bindGlobalHandlers.call(this);\n                    this.listenTo(GlobalEmitter_1.default.get(), {\n                        touchstart: this.processUnselect,\n                        mousedown: this.handleDocumentMousedown\n                    });\n                };\n                // Unbinds DOM handlers from elements that reside outside the view container\n                View.prototype.unbindGlobalHandlers = function () {\n                    _super.prototype.unbindGlobalHandlers.call(this);\n                    this.stopListeningTo(GlobalEmitter_1.default.get());\n                };\n                /* Now Indicator\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Immediately render the current time indicator and begins re-rendering it at an interval,\n                // which is defined by this.getNowIndicatorUnit().\n                // TODO: somehow do this for the current whole day's background too\n                View.prototype.startNowIndicator = function () {\n                    var _this = this;\n                    var unit;\n                    var update;\n                    var delay; // ms wait value\n                    if (this.opt('nowIndicator')) {\n                        unit = this.getNowIndicatorUnit();\n                        if (unit) {\n                            update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`\n                            this.initialNowDate = this.calendar.getNow();\n                            this.initialNowQueriedMs = new Date().valueOf();\n                            // wait until the beginning of the next interval\n                            delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();\n                            this.nowIndicatorTimeoutID = setTimeout(function () {\n                                _this.nowIndicatorTimeoutID = null;\n                                update();\n                                delay = +moment.duration(1, unit);\n                                delay = Math.max(100, delay); // prevent too frequent\n                                _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\n                            }, delay);\n                        }\n                        // rendering will be initiated in updateSize\n                    }\n                };\n                // rerenders the now indicator, computing the new current time from the amount of time that has passed\n                // since the initial getNow call.\n                View.prototype.updateNowIndicator = function () {\n                    if (this.isDatesRendered &&\n                        this.initialNowDate // activated before?\n                    ) {\n                        this.unrenderNowIndicator(); // won't unrender if unnecessary\n                        this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms\n                        );\n                        this.isNowIndicatorRendered = true;\n                    }\n                };\n                // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\n                // Won't cause side effects if indicator isn't rendered.\n                View.prototype.stopNowIndicator = function () {\n                    if (this.isNowIndicatorRendered) {\n                        if (this.nowIndicatorTimeoutID) {\n                            clearTimeout(this.nowIndicatorTimeoutID);\n                            this.nowIndicatorTimeoutID = null;\n                        }\n                        if (this.nowIndicatorIntervalID) {\n                            clearInterval(this.nowIndicatorIntervalID);\n                            this.nowIndicatorIntervalID = null;\n                        }\n                        this.unrenderNowIndicator();\n                        this.isNowIndicatorRendered = false;\n                    }\n                };\n                /* Dimensions\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    if (this['setHeight']) {\n                        this['setHeight'](totalHeight, isAuto);\n                    }\n                    else {\n                        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    }\n                    this.updateNowIndicator();\n                };\n                /* Scroller\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.addScroll = function (scroll) {\n                    var queuedScroll = this.queuedScroll || (this.queuedScroll = {});\n                    $.extend(queuedScroll, scroll);\n                };\n                View.prototype.popScroll = function () {\n                    this.applyQueuedScroll();\n                    this.queuedScroll = null;\n                };\n                View.prototype.applyQueuedScroll = function () {\n                    if (this.queuedScroll) {\n                        this.applyScroll(this.queuedScroll);\n                    }\n                };\n                View.prototype.queryScroll = function () {\n                    var scroll = {};\n                    if (this.isDatesRendered) {\n                        $.extend(scroll, this.queryDateScroll());\n                    }\n                    return scroll;\n                };\n                View.prototype.applyScroll = function (scroll) {\n                    if (scroll.isDateInit && this.isDatesRendered) {\n                        $.extend(scroll, this.computeInitialDateScroll());\n                    }\n                    if (this.isDatesRendered) {\n                        this.applyDateScroll(scroll);\n                    }\n                };\n                View.prototype.computeInitialDateScroll = function () {\n                    return {}; // subclasses must implement\n                };\n                View.prototype.queryDateScroll = function () {\n                    return {}; // subclasses must implement\n                };\n                View.prototype.applyDateScroll = function (scroll) {\n                    // subclasses must implement\n                };\n                /* Event Drag-n-Drop\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {\n                    var eventManager = this.calendar.eventManager;\n                    var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\n                    var dateMutation = eventMutation.dateMutation;\n                    // update the EventInstance, for handlers\n                    if (dateMutation) {\n                        eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\n                    }\n                    this.triggerEventDrop(eventInstance, \n                    // a drop doesn't necessarily mean a date mutation (ex: resource change)\n                    (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);\n                };\n                // Triggers event-drop handlers that have subscribed via the API\n                View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {\n                    this.publiclyTrigger('eventDrop', {\n                        context: el[0],\n                        args: [\n                            eventInstance.toLegacy(),\n                            dateDelta,\n                            undoFunc,\n                            ev,\n                            {},\n                            this\n                        ]\n                    });\n                };\n                /* External Element Drag-n-Drop\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\n                // `meta` is the parsed data that has been embedded into the dragging event.\n                // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n                View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {\n                    if (isEvent) {\n                        this.calendar.eventManager.addEventDef(singleEventDef, isSticky);\n                    }\n                    this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);\n                };\n                // Triggers external-drop handlers that have subscribed via the API\n                View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {\n                    // trigger 'drop' regardless of whether element represents an event\n                    this.publiclyTrigger('drop', {\n                        context: el[0],\n                        args: [\n                            singleEventDef.dateProfile.start.clone(),\n                            ev,\n                            ui,\n                            this\n                        ]\n                    });\n                    if (isEvent) {\n                        // signal an external event landed\n                        this.publiclyTrigger('eventReceive', {\n                            context: this,\n                            args: [\n                                singleEventDef.buildInstance().toLegacy(),\n                                this\n                            ]\n                        });\n                    }\n                };\n                /* Event Resizing\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Must be called when an event in the view has been resized to a new length\n                View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {\n                    var eventManager = this.calendar.eventManager;\n                    var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\n                    // update the EventInstance, for handlers\n                    eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\n                    this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);\n                };\n                // Triggers event-resize handlers that have subscribed via the API\n                View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {\n                    this.publiclyTrigger('eventResize', {\n                        context: el[0],\n                        args: [\n                            eventInstance.toLegacy(),\n                            durationDelta,\n                            undoFunc,\n                            ev,\n                            {},\n                            this\n                        ]\n                    });\n                };\n                /* Selection (time range)\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Selects a date span on the view. `start` and `end` are both Moments.\n                // `ev` is the native mouse event that begin the interaction.\n                View.prototype.select = function (footprint, ev) {\n                    this.unselect(ev);\n                    this.renderSelectionFootprint(footprint);\n                    this.reportSelection(footprint, ev);\n                };\n                View.prototype.renderSelectionFootprint = function (footprint) {\n                    if (this['renderSelection']) {\n                        this['renderSelection'](footprint.toLegacy(this.calendar));\n                    }\n                    else {\n                        _super.prototype.renderSelectionFootprint.call(this, footprint);\n                    }\n                };\n                // Called when a new selection is made. Updates internal state and triggers handlers.\n                View.prototype.reportSelection = function (footprint, ev) {\n                    this.isSelected = true;\n                    this.triggerSelect(footprint, ev);\n                };\n                // Triggers handlers to 'select'\n                View.prototype.triggerSelect = function (footprint, ev) {\n                    var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\n                    this.publiclyTrigger('select', {\n                        context: this,\n                        args: [\n                            dateProfile.start,\n                            dateProfile.end,\n                            ev,\n                            this\n                        ]\n                    });\n                };\n                // Undoes a selection. updates in the internal state and triggers handlers.\n                // `ev` is the native mouse event that began the interaction.\n                View.prototype.unselect = function (ev) {\n                    if (this.isSelected) {\n                        this.isSelected = false;\n                        if (this['destroySelection']) {\n                            this['destroySelection'](); // TODO: deprecate\n                        }\n                        this.unrenderSelection();\n                        this.publiclyTrigger('unselect', {\n                            context: this,\n                            args: [ev, this]\n                        });\n                    }\n                };\n                /* Event Selection\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.selectEventInstance = function (eventInstance) {\n                    if (!this.selectedEventInstance ||\n                        this.selectedEventInstance !== eventInstance) {\n                        this.unselectEventInstance();\n                        this.getEventSegs().forEach(function (seg) {\n                            if (seg.footprint.eventInstance === eventInstance &&\n                                seg.el // necessary?\n                            ) {\n                                seg.el.addClass('fc-selected');\n                            }\n                        });\n                        this.selectedEventInstance = eventInstance;\n                    }\n                };\n                View.prototype.unselectEventInstance = function () {\n                    if (this.selectedEventInstance) {\n                        this.getEventSegs().forEach(function (seg) {\n                            if (seg.el) {\n                                seg.el.removeClass('fc-selected');\n                            }\n                        });\n                        this.selectedEventInstance = null;\n                    }\n                };\n                View.prototype.isEventDefSelected = function (eventDef) {\n                    // event references might change on refetchEvents(), while selectedEventInstance doesn't,\n                    // so compare IDs\n                    return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;\n                };\n                /* Mouse / Touch Unselecting (time range & event unselection)\n                ------------------------------------------------------------------------------------------------------------------*/\n                // TODO: move consistently to down/start or up/end?\n                // TODO: don't kill previous selection if touch scrolling\n                View.prototype.handleDocumentMousedown = function (ev) {\n                    if (util_1.isPrimaryMouseButton(ev)) {\n                        this.processUnselect(ev);\n                    }\n                };\n                View.prototype.processUnselect = function (ev) {\n                    this.processRangeUnselect(ev);\n                    this.processEventUnselect(ev);\n                };\n                View.prototype.processRangeUnselect = function (ev) {\n                    var ignore;\n                    // is there a time-range selection?\n                    if (this.isSelected && this.opt('unselectAuto')) {\n                        // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\n                        ignore = this.opt('unselectCancel');\n                        if (!ignore || !$(ev.target).closest(ignore).length) {\n                            this.unselect(ev);\n                        }\n                    }\n                };\n                View.prototype.processEventUnselect = function (ev) {\n                    if (this.selectedEventInstance) {\n                        if (!$(ev.target).closest('.fc-selected').length) {\n                            this.unselectEventInstance();\n                        }\n                    }\n                };\n                /* Triggers\n                ------------------------------------------------------------------------------------------------------------------*/\n                View.prototype.triggerBaseRendered = function () {\n                    this.publiclyTrigger('viewRender', {\n                        context: this,\n                        args: [this, this.el]\n                    });\n                };\n                View.prototype.triggerBaseUnrendered = function () {\n                    this.publiclyTrigger('viewDestroy', {\n                        context: this,\n                        args: [this, this.el]\n                    });\n                };\n                // Triggers handlers to 'dayClick'\n                // Span has start/end of the clicked area. Only the start is useful.\n                View.prototype.triggerDayClick = function (footprint, dayEl, ev) {\n                    var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\n                    this.publiclyTrigger('dayClick', {\n                        context: dayEl,\n                        args: [dateProfile.start, ev, this]\n                    });\n                };\n                /* Date Utils\n                ------------------------------------------------------------------------------------------------------------------*/\n                // For DateComponent::getDayClasses\n                View.prototype.isDateInOtherMonth = function (date, dateProfile) {\n                    return false;\n                };\n                // Arguments after name will be forwarded to a hypothetical function value\n                // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\n                // Always clone your objects if you fear mutation.\n                View.prototype.getUnzonedRangeOption = function (name) {\n                    var val = this.opt(name);\n                    if (typeof val === 'function') {\n                        val = val.apply(null, Array.prototype.slice.call(arguments, 1));\n                    }\n                    if (val) {\n                        return this.calendar.parseUnzonedRange(val);\n                    }\n                };\n                /* Hidden Days\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Initializes internal variables related to calculating hidden days-of-week\n                View.prototype.initHiddenDays = function () {\n                    var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\n                    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n                    var dayCnt = 0;\n                    var i;\n                    if (this.opt('weekends') === false) {\n                        hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n                    }\n                    for (i = 0; i < 7; i++) {\n                        if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {\n                            dayCnt++;\n                        }\n                    }\n                    if (!dayCnt) {\n                        throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n                    }\n                    this.isHiddenDayHash = isHiddenDayHash;\n                };\n                // Remove days from the beginning and end of the range that are computed as hidden.\n                // If the whole range is trimmed off, returns null\n                View.prototype.trimHiddenDays = function (inputUnzonedRange) {\n                    var start = inputUnzonedRange.getStart();\n                    var end = inputUnzonedRange.getEnd();\n                    if (start) {\n                        start = this.skipHiddenDays(start);\n                    }\n                    if (end) {\n                        end = this.skipHiddenDays(end, -1, true);\n                    }\n                    if (start === null || end === null || start < end) {\n                        return new UnzonedRange_1.default(start, end);\n                    }\n                    return null;\n                };\n                // Is the current day hidden?\n                // `day` is a day-of-week index (0-6), or a Moment\n                View.prototype.isHiddenDay = function (day) {\n                    if (moment.isMoment(day)) {\n                        day = day.day();\n                    }\n                    return this.isHiddenDayHash[day];\n                };\n                // Incrementing the current day until it is no longer a hidden day, returning a copy.\n                // DOES NOT CONSIDER validUnzonedRange!\n                // If the initial value of `date` is not a hidden day, don't do anything.\n                // Pass `isExclusive` as `true` if you are dealing with an end date.\n                // `inc` defaults to `1` (increment one day forward each time)\n                View.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n                    if (inc === void 0) {\n                        inc = 1;\n                    }\n                    if (isExclusive === void 0) {\n                        isExclusive = false;\n                    }\n                    var out = date.clone();\n                    while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {\n                        out.add(inc, 'days');\n                    }\n                    return out;\n                };\n                return View;\n            }(InteractiveDateComponent_1.default));\n            exports.default = View;\n            View.prototype.usesMinMaxTime = false;\n            View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;\n            View.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {\n                this.requestDateRender(deps.dateProfile);\n            }, function () {\n                this.requestDateUnrender();\n            });\n            View.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {\n                this.requestBusinessHoursRender(deps.businessHourGenerator);\n            }, function () {\n                this.requestBusinessHoursUnrender();\n            });\n            View.watch('initialEvents', ['dateProfile'], function (deps) {\n                return this.fetchInitialEvents(deps.dateProfile);\n            });\n            View.watch('bindingEvents', ['initialEvents'], function (deps) {\n                this.setEvents(deps.initialEvents);\n                this.bindEventChanges();\n            }, function () {\n                this.unbindEventChanges();\n                this.unsetEvents();\n            });\n            View.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {\n                this.requestEventsRender(this.get('currentEvents'));\n            }, function () {\n                this.requestEventsUnrender();\n            });\n            View.watch('title', ['dateProfile'], function (deps) {\n                return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons\n            });\n            View.watch('legacyDateProps', ['dateProfile'], function (deps) {\n                var calendar = this.calendar;\n                var dateProfile = deps.dateProfile;\n                // DEPRECATED, but we need to keep it updated...\n                this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);\n                this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);\n                this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);\n                this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);\n            });\n            /***/ \n        }),\n        /* 42 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var EventRenderer = /*@__PURE__*/ (function () {\n                function EventRenderer(component, fillRenderer) {\n                    this.view = component._getView();\n                    this.component = component;\n                    this.fillRenderer = fillRenderer;\n                }\n                EventRenderer.prototype.opt = function (name) {\n                    return this.view.opt(name);\n                };\n                // Updates values that rely on options and also relate to range\n                EventRenderer.prototype.rangeUpdated = function () {\n                    var displayEventTime;\n                    var displayEventEnd;\n                    this.eventTimeFormat =\n                        this.opt('eventTimeFormat') ||\n                            this.opt('timeFormat') || // deprecated\n                            this.computeEventTimeFormat();\n                    displayEventTime = this.opt('displayEventTime');\n                    if (displayEventTime == null) {\n                        displayEventTime = this.computeDisplayEventTime(); // might be based off of range\n                    }\n                    displayEventEnd = this.opt('displayEventEnd');\n                    if (displayEventEnd == null) {\n                        displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\n                    }\n                    this.displayEventTime = displayEventTime;\n                    this.displayEventEnd = displayEventEnd;\n                };\n                EventRenderer.prototype.render = function (eventsPayload) {\n                    var dateProfile = this.component._getDateProfile();\n                    var eventDefId;\n                    var instanceGroup;\n                    var eventRanges;\n                    var bgRanges = [];\n                    var fgRanges = [];\n                    for (eventDefId in eventsPayload) {\n                        instanceGroup = eventsPayload[eventDefId];\n                        eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);\n                        if (instanceGroup.getEventDef().hasBgRendering()) {\n                            bgRanges.push.apply(bgRanges, eventRanges);\n                        }\n                        else {\n                            fgRanges.push.apply(fgRanges, eventRanges);\n                        }\n                    }\n                    this.renderBgRanges(bgRanges);\n                    this.renderFgRanges(fgRanges);\n                };\n                EventRenderer.prototype.unrender = function () {\n                    this.unrenderBgRanges();\n                    this.unrenderFgRanges();\n                };\n                EventRenderer.prototype.renderFgRanges = function (eventRanges) {\n                    var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\n                    var segs = this.component.eventFootprintsToSegs(eventFootprints);\n                    // render an `.el` on each seg\n                    // returns a subset of the segs. segs that were actually rendered\n                    segs = this.renderFgSegEls(segs);\n                    if (this.renderFgSegs(segs) !== false) {\n                        this.fgSegs = segs;\n                    }\n                };\n                EventRenderer.prototype.unrenderFgRanges = function () {\n                    this.unrenderFgSegs(this.fgSegs || []);\n                    this.fgSegs = null;\n                };\n                EventRenderer.prototype.renderBgRanges = function (eventRanges) {\n                    var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\n                    var segs = this.component.eventFootprintsToSegs(eventFootprints);\n                    if (this.renderBgSegs(segs) !== false) {\n                        this.bgSegs = segs;\n                    }\n                };\n                EventRenderer.prototype.unrenderBgRanges = function () {\n                    this.unrenderBgSegs();\n                    this.bgSegs = null;\n                };\n                EventRenderer.prototype.getSegs = function () {\n                    return (this.bgSegs || []).concat(this.fgSegs || []);\n                };\n                // Renders foreground event segments onto the grid\n                EventRenderer.prototype.renderFgSegs = function (segs) {\n                    // subclasses must implement\n                    // segs already has rendered els, and has been filtered.\n                    return false; // signal failure if not implemented\n                };\n                // Unrenders all currently rendered foreground segments\n                EventRenderer.prototype.unrenderFgSegs = function (segs) {\n                    // subclasses must implement\n                };\n                EventRenderer.prototype.renderBgSegs = function (segs) {\n                    var _this = this;\n                    if (this.fillRenderer) {\n                        this.fillRenderer.renderSegs('bgEvent', segs, {\n                            getClasses: function (seg) {\n                                return _this.getBgClasses(seg.footprint.eventDef);\n                            },\n                            getCss: function (seg) {\n                                return {\n                                    'background-color': _this.getBgColor(seg.footprint.eventDef)\n                                };\n                            },\n                            filterEl: function (seg, el) {\n                                return _this.filterEventRenderEl(seg.footprint, el);\n                            }\n                        });\n                    }\n                    else {\n                        return false; // signal failure if no fillRenderer\n                    }\n                };\n                EventRenderer.prototype.unrenderBgSegs = function () {\n                    if (this.fillRenderer) {\n                        this.fillRenderer.unrender('bgEvent');\n                    }\n                };\n                // Renders and assigns an `el` property for each foreground event segment.\n                // Only returns segments that successfully rendered.\n                EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {\n                    var _this = this;\n                    if (disableResizing === void 0) {\n                        disableResizing = false;\n                    }\n                    var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');\n                    var html = '';\n                    var renderedSegs = [];\n                    var i;\n                    if (segs.length) {\n                        // build a large concatenation of event segment HTML\n                        for (i = 0; i < segs.length; i++) {\n                            this.beforeFgSegHtml(segs[i]);\n                            html += this.fgSegHtml(segs[i], disableResizing);\n                        }\n                        // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                        // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\n                        $(html).each(function (i, node) {\n                            var seg = segs[i];\n                            var el = $(node);\n                            if (hasEventRenderHandlers) {\n                                el = _this.filterEventRenderEl(seg.footprint, el);\n                            }\n                            if (el) {\n                                el.data('fc-seg', seg); // used by handlers\n                                seg.el = el;\n                                renderedSegs.push(seg);\n                            }\n                        });\n                    }\n                    return renderedSegs;\n                };\n                EventRenderer.prototype.beforeFgSegHtml = function (seg) {\n                };\n                // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\n                EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\n                    // subclasses should implement\n                };\n                // Generic utility for generating the HTML classNames for an event segment's element\n                EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {\n                    var classes = [\n                        'fc-event',\n                        seg.isStart ? 'fc-start' : 'fc-not-start',\n                        seg.isEnd ? 'fc-end' : 'fc-not-end'\n                    ].concat(this.getClasses(seg.footprint.eventDef));\n                    if (isDraggable) {\n                        classes.push('fc-draggable');\n                    }\n                    if (isResizable) {\n                        classes.push('fc-resizable');\n                    }\n                    // event is currently selected? attach a className.\n                    if (this.view.isEventDefSelected(seg.footprint.eventDef)) {\n                        classes.push('fc-selected');\n                    }\n                    return classes;\n                };\n                // Given an event and the default element used for rendering, returns the element that should actually be used.\n                // Basically runs events and elements through the eventRender hook.\n                EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {\n                    var legacy = eventFootprint.getEventLegacy();\n                    var custom = this.view.publiclyTrigger('eventRender', {\n                        context: legacy,\n                        args: [legacy, el, this.view]\n                    });\n                    if (custom === false) {\n                        el = null;\n                    }\n                    else if (custom && custom !== true) {\n                        el = $(custom);\n                    }\n                    return el;\n                };\n                // Compute the text that should be displayed on an event's element.\n                // `range` can be the Event object itself, or something range-like, with at least a `start`.\n                // If event times are disabled, or the event has no time, will return a blank string.\n                // If not specified, formatStr will default to the eventTimeFormat setting,\n                // and displayEnd will default to the displayEventEnd setting.\n                EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {\n                    return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);\n                };\n                EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {\n                    if (formatStr == null) {\n                        formatStr = this.eventTimeFormat;\n                    }\n                    if (displayEnd == null) {\n                        displayEnd = this.displayEventEnd;\n                    }\n                    if (this.displayEventTime && !isAllDay) {\n                        if (displayEnd && end) {\n                            return this.view.formatRange({ start: start, end: end }, false, // allDay\n                            formatStr);\n                        }\n                        else {\n                            return start.format(formatStr);\n                        }\n                    }\n                    return '';\n                };\n                EventRenderer.prototype.computeEventTimeFormat = function () {\n                    return this.opt('smallTimeFormat');\n                };\n                EventRenderer.prototype.computeDisplayEventTime = function () {\n                    return true;\n                };\n                EventRenderer.prototype.computeDisplayEventEnd = function () {\n                    return true;\n                };\n                EventRenderer.prototype.getBgClasses = function (eventDef) {\n                    var classNames = this.getClasses(eventDef);\n                    classNames.push('fc-bgevent');\n                    return classNames;\n                };\n                EventRenderer.prototype.getClasses = function (eventDef) {\n                    var objs = this.getStylingObjs(eventDef);\n                    var i;\n                    var classNames = [];\n                    for (i = 0; i < objs.length; i++) {\n                        classNames.push.apply(// append\n                        classNames, objs[i].eventClassName || objs[i].className || []);\n                    }\n                    return classNames;\n                };\n                // Utility for generating event skin-related CSS properties\n                EventRenderer.prototype.getSkinCss = function (eventDef) {\n                    return {\n                        'background-color': this.getBgColor(eventDef),\n                        'border-color': this.getBorderColor(eventDef),\n                        color: this.getTextColor(eventDef)\n                    };\n                };\n                // Queries for caller-specified color, then falls back to default\n                EventRenderer.prototype.getBgColor = function (eventDef) {\n                    var objs = this.getStylingObjs(eventDef);\n                    var i;\n                    var val;\n                    for (i = 0; i < objs.length && !val; i++) {\n                        val = objs[i].eventBackgroundColor || objs[i].eventColor ||\n                            objs[i].backgroundColor || objs[i].color;\n                    }\n                    if (!val) {\n                        val = this.opt('eventBackgroundColor') || this.opt('eventColor');\n                    }\n                    return val;\n                };\n                // Queries for caller-specified color, then falls back to default\n                EventRenderer.prototype.getBorderColor = function (eventDef) {\n                    var objs = this.getStylingObjs(eventDef);\n                    var i;\n                    var val;\n                    for (i = 0; i < objs.length && !val; i++) {\n                        val = objs[i].eventBorderColor || objs[i].eventColor ||\n                            objs[i].borderColor || objs[i].color;\n                    }\n                    if (!val) {\n                        val = this.opt('eventBorderColor') || this.opt('eventColor');\n                    }\n                    return val;\n                };\n                // Queries for caller-specified color, then falls back to default\n                EventRenderer.prototype.getTextColor = function (eventDef) {\n                    var objs = this.getStylingObjs(eventDef);\n                    var i;\n                    var val;\n                    for (i = 0; i < objs.length && !val; i++) {\n                        val = objs[i].eventTextColor ||\n                            objs[i].textColor;\n                    }\n                    if (!val) {\n                        val = this.opt('eventTextColor');\n                    }\n                    return val;\n                };\n                EventRenderer.prototype.getStylingObjs = function (eventDef) {\n                    var objs = this.getFallbackStylingObjs(eventDef);\n                    objs.unshift(eventDef);\n                    return objs;\n                };\n                EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {\n                    return [eventDef.source];\n                };\n                EventRenderer.prototype.sortEventSegs = function (segs) {\n                    segs.sort(util_1.proxy(this, 'compareEventSegs'));\n                };\n                // A cmp function for determining which segments should take visual priority\n                EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {\n                    var f1 = seg1.footprint;\n                    var f2 = seg2.footprint;\n                    var cf1 = f1.componentFootprint;\n                    var cf2 = f2.componentFootprint;\n                    var r1 = cf1.unzonedRange;\n                    var r2 = cf2.unzonedRange;\n                    return r1.startMs - r2.startMs || // earlier events go first\n                        (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first\n                        cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)\n                        util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);\n                };\n                return EventRenderer;\n            }());\n            exports.default = EventRenderer;\n            /***/ \n        }),\n        /* 43 */ ,\n        /* 44 */ ,\n        /* 45 */ ,\n        /* 46 */ ,\n        /* 47 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment_ext_1 = __webpack_require__(10);\n            // Plugin\n            // -------------------------------------------------------------------------------------------------\n            moment_ext_1.newMomentProto.format = function () {\n                if (this._fullCalendar && arguments[0]) {\n                    return formatDate(this, arguments[0]); // our extended formatting\n                }\n                if (this._ambigTime) {\n                    return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\n                }\n                if (this._ambigZone) {\n                    return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\n                }\n                if (this._fullCalendar) {\n                    // moment.format() doesn't ensure english, but we want to.\n                    return moment_ext_1.oldMomentFormat(englishMoment(this));\n                }\n                return moment_ext_1.oldMomentProto.format.apply(this, arguments);\n            };\n            moment_ext_1.newMomentProto.toISOString = function () {\n                if (this._ambigTime) {\n                    return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\n                }\n                if (this._ambigZone) {\n                    return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\n                }\n                if (this._fullCalendar) {\n                    // depending on browser, moment might not output english. ensure english.\n                    // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\n                    return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);\n                }\n                return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);\n            };\n            function englishMoment(mom) {\n                if (mom.locale() !== 'en') {\n                    return mom.clone().locale('en');\n                }\n                return mom;\n            }\n            // Config\n            // ---------------------------------------------------------------------------------------------------------------------\n            /*\n            Inserted between chunks in the fake (\"intermediate\") formatting string.\n            Important that it passes as whitespace (\\s) because moment often identifies non-standalone months\n            via a regexp with an \\s.\n            */\n            var PART_SEPARATOR = '\\u000b'; // vertical tab\n            /*\n            Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\n            but rather, a \"special\" token that has custom rendering (see specialTokens map).\n            */\n            var SPECIAL_TOKEN_MARKER = '\\u001f'; // information separator 1\n            /*\n            Inserted at the beginning and end of a span of text that must have non-zero numeric characters.\n            Handling of these markers is done in a post-processing step at the very end of text rendering.\n            */\n            var MAYBE_MARKER = '\\u001e'; // information separator 2\n            var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\n            /*\n            Addition formatting tokens we want recognized\n            */\n            var specialTokens = {\n                t: function (date) {\n                    return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);\n                },\n                T: function (date) {\n                    return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);\n                }\n            };\n            /*\n            The first characters of formatting tokens for units that are 1 day or larger.\n            `value` is for ranking relative size (lower means bigger).\n            `unit` is a normalized unit, used for comparing moments.\n            */\n            var largeTokenMap = {\n                Y: { value: 1, unit: 'year' },\n                M: { value: 2, unit: 'month' },\n                W: { value: 3, unit: 'week' },\n                w: { value: 3, unit: 'week' },\n                D: { value: 4, unit: 'day' },\n                d: { value: 4, unit: 'day' } // day of week\n            };\n            // Single Date Formatting\n            // ---------------------------------------------------------------------------------------------------------------------\n            /*\n            Formats `date` with a Moment formatting string, but allow our non-zero areas and special token\n            */\n            function formatDate(date, formatStr) {\n                return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);\n            }\n            exports.formatDate = formatDate;\n            // Date Range Formatting\n            // -------------------------------------------------------------------------------------------------\n            // TODO: make it work with timezone offset\n            /*\n            Using a formatting string meant for a single date, generate a range string, like\n            \"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\n            If the dates are the same as far as the format string is concerned, just return a single\n            rendering of one date, without any separator.\n            */\n            function formatRange(date1, date2, formatStr, separator, isRTL) {\n                var localeData;\n                date1 = moment_ext_1.default.parseZone(date1);\n                date2 = moment_ext_1.default.parseZone(date2);\n                localeData = date1.localeData();\n                // Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\".\n                // BTW, this is not important for `formatDate` because it is impossible to put custom tokens\n                // or non-zero areas in Moment's localized format strings.\n                formatStr = localeData.longDateFormat(formatStr) || formatStr;\n                return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);\n            }\n            exports.formatRange = formatRange;\n            /*\n            Renders a range with an already-parsed format string.\n            */\n            function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\n                var sameUnits = parsedFormat.sameUnits;\n                var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\n                var unzonedDate2 = date2.clone().stripZone(); // \"\n                var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\n                var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\n                var leftI;\n                var leftStr = '';\n                var rightI;\n                var rightStr = '';\n                var middleI;\n                var middleStr1 = '';\n                var middleStr2 = '';\n                var middleStr = '';\n                // Start at the leftmost side of the formatting string and continue until you hit a token\n                // that is not the same between dates.\n                for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {\n                    leftStr += renderedParts1[leftI];\n                }\n                // Similarly, start at the rightmost side of the formatting string and move left\n                for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {\n                    // If current chunk is on the boundary of unique date-content, and is a special-case\n                    // date-formatting postfix character, then don't consume it. Consider it unique date-content.\n                    // TODO: make configurable\n                    if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\n                        break;\n                    }\n                    rightStr = renderedParts1[rightI] + rightStr;\n                }\n                // The area in the middle is different for both of the dates.\n                // Collect them distinctly so we can jam them together later.\n                for (middleI = leftI; middleI <= rightI; middleI++) {\n                    middleStr1 += renderedParts1[middleI];\n                    middleStr2 += renderedParts2[middleI];\n                }\n                if (middleStr1 || middleStr2) {\n                    if (isRTL) {\n                        middleStr = middleStr2 + separator + middleStr1;\n                    }\n                    else {\n                        middleStr = middleStr1 + separator + middleStr2;\n                    }\n                }\n                return processMaybeMarkers(leftStr + middleStr + rightStr);\n            }\n            // Format String Parsing\n            // ---------------------------------------------------------------------------------------------------------------------\n            var parsedFormatStrCache = {};\n            /*\n            Returns a parsed format string, leveraging a cache.\n            */\n            function getParsedFormatString(formatStr) {\n                return parsedFormatStrCache[formatStr] ||\n                    (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\n            }\n            /*\n            Parses a format string into the following:\n            - fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\n            - sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \"day\"),\n              that indicates how similar a range's start & end must be in order to share the same formatted text.\n              If not a token, then the value is null.\n              Always a flat array (not nested liked \"chunks\").\n            */\n            function parseFormatString(formatStr) {\n                var chunks = chunkFormatString(formatStr);\n                return {\n                    fakeFormatString: buildFakeFormatString(chunks),\n                    sameUnits: buildSameUnits(chunks)\n                };\n            }\n            /*\n            Break the formatting string into an array of chunks.\n            A 'maybe' chunk will have nested chunks.\n            */\n            function chunkFormatString(formatStr) {\n                var chunks = [];\n                var match;\n                // TODO: more descrimination\n                // \\4 is a backreference to the first character of a multi-character set.\n                var chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g;\n                while ((match = chunker.exec(formatStr))) {\n                    if (match[1]) {\n                        chunks.push.apply(chunks, // append\n                        splitStringLiteral(match[1]));\n                    }\n                    else if (match[2]) {\n                        chunks.push({ maybe: chunkFormatString(match[2]) });\n                    }\n                    else if (match[3]) {\n                        chunks.push({ token: match[3] });\n                    }\n                    else if (match[5]) {\n                        chunks.push.apply(chunks, // append\n                        splitStringLiteral(match[5]));\n                    }\n                }\n                return chunks;\n            }\n            /*\n            Potentially splits a literal-text string into multiple parts. For special cases.\n            */\n            function splitStringLiteral(s) {\n                if (s === '. ') {\n                    return ['.', ' ']; // for locales with periods bound to the end of each year/month/date\n                }\n                else {\n                    return [s];\n                }\n            }\n            /*\n            Given chunks parsed from a real format string, generate a fake (aka \"intermediate\") format string with special control\n            characters that will eventually be given to moment for formatting, and then post-processed.\n            */\n            function buildFakeFormatString(chunks) {\n                var parts = [];\n                var i;\n                var chunk;\n                for (i = 0; i < chunks.length; i++) {\n                    chunk = chunks[i];\n                    if (typeof chunk === 'string') {\n                        parts.push('[' + chunk + ']');\n                    }\n                    else if (chunk.token) {\n                        if (chunk.token in specialTokens) {\n                            parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing\n                                '[' + chunk.token + ']' // preserve as literal text\n                            );\n                        }\n                        else {\n                            parts.push(chunk.token); // unprotected text implies a format string\n                        }\n                    }\n                    else if (chunk.maybe) {\n                        parts.push(MAYBE_MARKER + // useful during post-processing\n                            buildFakeFormatString(chunk.maybe) +\n                            MAYBE_MARKER);\n                    }\n                }\n                return parts.join(PART_SEPARATOR);\n            }\n            /*\n            Given parsed chunks from a real formatting string, generates an array of unit strings (like \"day\") that indicate\n            in which regard two dates must be similar in order to share range formatting text.\n            The `chunks` can be nested (because of \"maybe\" chunks), however, the returned array will be flat.\n            */\n            function buildSameUnits(chunks) {\n                var units = [];\n                var i;\n                var chunk;\n                var tokenInfo;\n                for (i = 0; i < chunks.length; i++) {\n                    chunk = chunks[i];\n                    if (chunk.token) {\n                        tokenInfo = largeTokenMap[chunk.token.charAt(0)];\n                        units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\n                    }\n                    else if (chunk.maybe) {\n                        units.push.apply(units, // append\n                        buildSameUnits(chunk.maybe));\n                    }\n                    else {\n                        units.push(null);\n                    }\n                }\n                return units;\n            }\n            // Rendering to text\n            // ---------------------------------------------------------------------------------------------------------------------\n            /*\n            Formats a date with a fake format string, post-processes the control characters, then returns.\n            */\n            function renderFakeFormatString(fakeFormatString, date) {\n                return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));\n            }\n            /*\n            Formats a date into parts that will have been post-processed, EXCEPT for the \"maybe\" markers.\n            */\n            function renderFakeFormatStringParts(fakeFormatString, date) {\n                var parts = [];\n                var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);\n                var fakeParts = fakeRender.split(PART_SEPARATOR);\n                var i;\n                var fakePart;\n                for (i = 0; i < fakeParts.length; i++) {\n                    fakePart = fakeParts[i];\n                    if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\n                        parts.push(\n                        // the literal string IS the token's name.\n                        // call special token's registered function.\n                        specialTokens[fakePart.substring(1)](date));\n                    }\n                    else {\n                        parts.push(fakePart);\n                    }\n                }\n                return parts;\n            }\n            /*\n            Accepts an almost-finally-formatted string and processes the \"maybe\" control characters, returning a new string.\n            */\n            function processMaybeMarkers(s) {\n                return s.replace(MAYBE_REGEXP, function (m0, m1) {\n                    if (m1.match(/[1-9]/)) {\n                        return m1;\n                    }\n                    else {\n                        return '';\n                    }\n                });\n            }\n            // Misc Utils\n            // -------------------------------------------------------------------------------------------------\n            /*\n            Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\n            */\n            function queryMostGranularFormatUnit(formatStr) {\n                var chunks = chunkFormatString(formatStr);\n                var i;\n                var chunk;\n                var candidate;\n                var best;\n                for (i = 0; i < chunks.length; i++) {\n                    chunk = chunks[i];\n                    if (chunk.token) {\n                        candidate = largeTokenMap[chunk.token.charAt(0)];\n                        if (candidate) {\n                            if (!best || candidate.value > best.value) {\n                                best = candidate;\n                            }\n                        }\n                    }\n                }\n                if (best) {\n                    return best.unit;\n                }\n                return null;\n            }\n            exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\n            /***/ \n        }),\n        /* 48 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Class_1 = __webpack_require__(33);\n            var EmitterMixin_1 = __webpack_require__(11);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var Model = (function (_super) {\n                tslib_1.__extends(Model, _super);\n                function Model() {\n                    var _this = _super.call(this) || this;\n                    _this._watchers = {};\n                    _this._props = {};\n                    _this.applyGlobalWatchers();\n                    _this.constructed();\n                    return _this;\n                }\n                Model.watch = function (name) {\n                    var args = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        args[_i - 1] = arguments[_i];\n                    }\n                    // subclasses should make a masked-copy of the superclass's map\n                    // TODO: write test\n                    if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {\n                        this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);\n                    }\n                    this.prototype._globalWatchArgs[name] = args;\n                };\n                Model.prototype.constructed = function () {\n                    // useful for monkeypatching. TODO: BaseClass?\n                };\n                Model.prototype.applyGlobalWatchers = function () {\n                    var map = this._globalWatchArgs;\n                    var name;\n                    for (name in map) {\n                        this.watch.apply(this, [name].concat(map[name]));\n                    }\n                };\n                Model.prototype.has = function (name) {\n                    return name in this._props;\n                };\n                Model.prototype.get = function (name) {\n                    if (name === undefined) {\n                        return this._props;\n                    }\n                    return this._props[name];\n                };\n                Model.prototype.set = function (name, val) {\n                    var newProps;\n                    if (typeof name === 'string') {\n                        newProps = {};\n                        newProps[name] = val === undefined ? null : val;\n                    }\n                    else {\n                        newProps = name;\n                    }\n                    this.setProps(newProps);\n                };\n                Model.prototype.reset = function (newProps) {\n                    var oldProps = this._props;\n                    var changeset = {}; // will have undefined's to signal unsets\n                    var name;\n                    for (name in oldProps) {\n                        changeset[name] = undefined;\n                    }\n                    for (name in newProps) {\n                        changeset[name] = newProps[name];\n                    }\n                    this.setProps(changeset);\n                };\n                Model.prototype.unset = function (name) {\n                    var newProps = {};\n                    var names;\n                    var i;\n                    if (typeof name === 'string') {\n                        names = [name];\n                    }\n                    else {\n                        names = name;\n                    }\n                    for (i = 0; i < names.length; i++) {\n                        newProps[names[i]] = undefined;\n                    }\n                    this.setProps(newProps);\n                };\n                Model.prototype.setProps = function (newProps) {\n                    var changedProps = {};\n                    var changedCnt = 0;\n                    var name;\n                    var val;\n                    for (name in newProps) {\n                        val = newProps[name];\n                        // a change in value?\n                        // if an object, don't check equality, because might have been mutated internally.\n                        // TODO: eventually enforce immutability.\n                        if (typeof val === 'object' ||\n                            val !== this._props[name]) {\n                            changedProps[name] = val;\n                            changedCnt++;\n                        }\n                    }\n                    if (changedCnt) {\n                        this.trigger('before:batchChange', changedProps);\n                        for (name in changedProps) {\n                            val = changedProps[name];\n                            this.trigger('before:change', name, val);\n                            this.trigger('before:change:' + name, val);\n                        }\n                        for (name in changedProps) {\n                            val = changedProps[name];\n                            if (val === undefined) {\n                                delete this._props[name];\n                            }\n                            else {\n                                this._props[name] = val;\n                            }\n                            this.trigger('change:' + name, val);\n                            this.trigger('change', name, val);\n                        }\n                        this.trigger('batchChange', changedProps);\n                    }\n                };\n                Model.prototype.watch = function (name, depList, startFunc, stopFunc) {\n                    var _this = this;\n                    this.unwatch(name);\n                    this._watchers[name] = this._watchDeps(depList, function (deps) {\n                        var res = startFunc.call(_this, deps);\n                        if (res && res.then) {\n                            _this.unset(name); // put in an unset state while resolving\n                            res.then(function (val) {\n                                _this.set(name, val);\n                            });\n                        }\n                        else {\n                            _this.set(name, res);\n                        }\n                    }, function (deps) {\n                        _this.unset(name);\n                        if (stopFunc) {\n                            stopFunc.call(_this, deps);\n                        }\n                    });\n                };\n                Model.prototype.unwatch = function (name) {\n                    var watcher = this._watchers[name];\n                    if (watcher) {\n                        delete this._watchers[name];\n                        watcher.teardown();\n                    }\n                };\n                Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {\n                    var _this = this;\n                    var queuedChangeCnt = 0;\n                    var depCnt = depList.length;\n                    var satisfyCnt = 0;\n                    var values = {}; // what's passed as the `deps` arguments\n                    var bindTuples = []; // array of [ eventName, handlerFunc ] arrays\n                    var isCallingStop = false;\n                    var onBeforeDepChange = function (depName, val, isOptional) {\n                        queuedChangeCnt++;\n                        if (queuedChangeCnt === 1) {\n                            if (satisfyCnt === depCnt) {\n                                isCallingStop = true;\n                                stopFunc(values);\n                                isCallingStop = false;\n                            }\n                        }\n                    };\n                    var onDepChange = function (depName, val, isOptional) {\n                        if (val === undefined) {\n                            // required dependency that was previously set?\n                            if (!isOptional && values[depName] !== undefined) {\n                                satisfyCnt--;\n                            }\n                            delete values[depName];\n                        }\n                        else {\n                            // required dependency that was previously unset?\n                            if (!isOptional && values[depName] === undefined) {\n                                satisfyCnt++;\n                            }\n                            values[depName] = val;\n                        }\n                        queuedChangeCnt--;\n                        if (!queuedChangeCnt) {\n                            // now finally satisfied or satisfied all along?\n                            if (satisfyCnt === depCnt) {\n                                // if the stopFunc initiated another value change, ignore it.\n                                // it will be processed by another change event anyway.\n                                if (!isCallingStop) {\n                                    startFunc(values);\n                                }\n                            }\n                        }\n                    };\n                    // intercept for .on() that remembers handlers\n                    var bind = function (eventName, handler) {\n                        _this.on(eventName, handler);\n                        bindTuples.push([eventName, handler]);\n                    };\n                    // listen to dependency changes\n                    depList.forEach(function (depName) {\n                        var isOptional = false;\n                        if (depName.charAt(0) === '?') {\n                            depName = depName.substring(1);\n                            isOptional = true;\n                        }\n                        bind('before:change:' + depName, function (val) {\n                            onBeforeDepChange(depName, val, isOptional);\n                        });\n                        bind('change:' + depName, function (val) {\n                            onDepChange(depName, val, isOptional);\n                        });\n                    });\n                    // process current dependency values\n                    depList.forEach(function (depName) {\n                        var isOptional = false;\n                        if (depName.charAt(0) === '?') {\n                            depName = depName.substring(1);\n                            isOptional = true;\n                        }\n                        if (_this.has(depName)) {\n                            values[depName] = _this.get(depName);\n                            satisfyCnt++;\n                        }\n                        else if (isOptional) {\n                            satisfyCnt++;\n                        }\n                    });\n                    // initially satisfied\n                    if (satisfyCnt === depCnt) {\n                        startFunc(values);\n                    }\n                    return {\n                        teardown: function () {\n                            // remove all handlers\n                            for (var i = 0; i < bindTuples.length; i++) {\n                                _this.off(bindTuples[i][0], bindTuples[i][1]);\n                            }\n                            bindTuples = null;\n                            // was satisfied, so call stopFunc\n                            if (satisfyCnt === depCnt) {\n                                stopFunc();\n                            }\n                        },\n                        flash: function () {\n                            if (satisfyCnt === depCnt) {\n                                stopFunc();\n                                startFunc(values);\n                            }\n                        }\n                    };\n                };\n                Model.prototype.flash = function (name) {\n                    var watcher = this._watchers[name];\n                    if (watcher) {\n                        watcher.flash();\n                    }\n                };\n                return Model;\n            }(Class_1.default));\n            exports.default = Model;\n            Model.prototype._globalWatchArgs = {}; // mutation protection in Model.watch\n            EmitterMixin_1.default.mixInto(Model);\n            ListenerMixin_1.default.mixInto(Model);\n            /***/ \n        }),\n        /* 49 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var RecurringEventDef_1 = __webpack_require__(210);\n            exports.default = {\n                parse: function (eventInput, source) {\n                    if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||\n                        util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {\n                        return RecurringEventDef_1.default.parse(eventInput, source);\n                    }\n                    else {\n                        return SingleEventDef_1.default.parse(eventInput, source);\n                    }\n                }\n            };\n            /***/ \n        }),\n        /* 50 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var util_1 = __webpack_require__(4);\n            var EventDateProfile_1 = __webpack_require__(17);\n            var EventDefDateMutation = /*@__PURE__*/ (function () {\n                function EventDefDateMutation() {\n                    this.clearEnd = false;\n                    this.forceTimed = false;\n                    this.forceAllDay = false;\n                }\n                EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {\n                    var clearEnd = dateProfile0.end && !dateProfile1.end;\n                    var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();\n                    var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();\n                    var dateDelta;\n                    var endDiff;\n                    var endDelta;\n                    var mutation;\n                    // subtracts the dates in the appropriate way, returning a duration\n                    function subtractDates(date1, date0) {\n                        if (largeUnit) {\n                            return util_1.diffByUnit(date1, date0, largeUnit); // poorly named\n                        }\n                        else if (dateProfile1.isAllDay()) {\n                            return util_1.diffDay(date1, date0); // poorly named\n                        }\n                        else {\n                            return util_1.diffDayTime(date1, date0); // poorly named\n                        }\n                    }\n                    dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);\n                    if (dateProfile1.end) {\n                        // use unzonedRanges because dateProfile0.end might be null\n                        endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());\n                        endDelta = endDiff.subtract(dateDelta);\n                    }\n                    mutation = new EventDefDateMutation();\n                    mutation.clearEnd = clearEnd;\n                    mutation.forceTimed = forceTimed;\n                    mutation.forceAllDay = forceAllDay;\n                    mutation.setDateDelta(dateDelta);\n                    mutation.setEndDelta(endDelta);\n                    return mutation;\n                };\n                /*\n                returns an undo function.\n                */\n                EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {\n                    var start = eventDateProfile.start.clone();\n                    var end = null;\n                    var shouldRezone = false;\n                    if (eventDateProfile.end && !this.clearEnd) {\n                        end = eventDateProfile.end.clone();\n                    }\n                    else if (this.endDelta && !end) {\n                        end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\n                    }\n                    if (this.forceTimed) {\n                        shouldRezone = true;\n                        if (!start.hasTime()) {\n                            start.time(0);\n                        }\n                        if (end && !end.hasTime()) {\n                            end.time(0);\n                        }\n                    }\n                    else if (this.forceAllDay) {\n                        if (start.hasTime()) {\n                            start.stripTime();\n                        }\n                        if (end && end.hasTime()) {\n                            end.stripTime();\n                        }\n                    }\n                    if (this.dateDelta) {\n                        shouldRezone = true;\n                        start.add(this.dateDelta);\n                        if (end) {\n                            end.add(this.dateDelta);\n                        }\n                    }\n                    // do this before adding startDelta to start, so we can work off of start\n                    if (this.endDelta) {\n                        shouldRezone = true;\n                        end.add(this.endDelta);\n                    }\n                    if (this.startDelta) {\n                        shouldRezone = true;\n                        start.add(this.startDelta);\n                    }\n                    if (shouldRezone) {\n                        start = calendar.applyTimezone(start);\n                        if (end) {\n                            end = calendar.applyTimezone(end);\n                        }\n                    }\n                    // TODO: okay to access calendar option?\n                    if (!end && calendar.opt('forceEventDuration')) {\n                        end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\n                    }\n                    return new EventDateProfile_1.default(start, end, calendar);\n                };\n                EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {\n                    if (dateDelta && dateDelta.valueOf()) {\n                        this.dateDelta = dateDelta;\n                    }\n                    else {\n                        this.dateDelta = null;\n                    }\n                };\n                EventDefDateMutation.prototype.setStartDelta = function (startDelta) {\n                    if (startDelta && startDelta.valueOf()) {\n                        this.startDelta = startDelta;\n                    }\n                    else {\n                        this.startDelta = null;\n                    }\n                };\n                EventDefDateMutation.prototype.setEndDelta = function (endDelta) {\n                    if (endDelta && endDelta.valueOf()) {\n                        this.endDelta = endDelta;\n                    }\n                    else {\n                        this.endDelta = null;\n                    }\n                };\n                EventDefDateMutation.prototype.isEmpty = function () {\n                    return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&\n                        !this.dateDelta && !this.startDelta && !this.endDelta;\n                };\n                return EventDefDateMutation;\n            }());\n            exports.default = EventDefDateMutation;\n            /***/ \n        }),\n        /* 51 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var StandardTheme_1 = __webpack_require__(213);\n            var JqueryUiTheme_1 = __webpack_require__(214);\n            var themeClassHash = {};\n            function defineThemeSystem(themeName, themeClass) {\n                themeClassHash[themeName] = themeClass;\n            }\n            exports.defineThemeSystem = defineThemeSystem;\n            function getThemeSystemClass(themeSetting) {\n                if (!themeSetting) {\n                    return StandardTheme_1.default;\n                }\n                else if (themeSetting === true) {\n                    return JqueryUiTheme_1.default;\n                }\n                else {\n                    return themeClassHash[themeSetting];\n                }\n            }\n            exports.getThemeSystemClass = getThemeSystemClass;\n            /***/ \n        }),\n        /* 52 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Promise_1 = __webpack_require__(20);\n            var EventSource_1 = __webpack_require__(6);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var ArrayEventSource = (function (_super) {\n                tslib_1.__extends(ArrayEventSource, _super);\n                function ArrayEventSource(calendar) {\n                    var _this = _super.call(this, calendar) || this;\n                    _this.eventDefs = []; // for if setRawEventDefs is never called\n                    return _this;\n                }\n                ArrayEventSource.parse = function (rawInput, calendar) {\n                    var rawProps;\n                    // normalize raw input\n                    if ($.isArray(rawInput.events)) {\n                        rawProps = rawInput;\n                    }\n                    else if ($.isArray(rawInput)) {\n                        rawProps = { events: rawInput };\n                    }\n                    if (rawProps) {\n                        return EventSource_1.default.parse.call(this, rawProps, calendar);\n                    }\n                    return false;\n                };\n                ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {\n                    this.rawEventDefs = rawEventDefs;\n                    this.eventDefs = this.parseEventDefs(rawEventDefs);\n                };\n                ArrayEventSource.prototype.fetch = function (start, end, timezone) {\n                    var eventDefs = this.eventDefs;\n                    var i;\n                    if (this.currentTimezone != null &&\n                        this.currentTimezone !== timezone) {\n                        for (i = 0; i < eventDefs.length; i++) {\n                            if (eventDefs[i] instanceof SingleEventDef_1.default) {\n                                eventDefs[i].rezone();\n                            }\n                        }\n                    }\n                    this.currentTimezone = timezone;\n                    return Promise_1.default.resolve(eventDefs);\n                };\n                ArrayEventSource.prototype.addEventDef = function (eventDef) {\n                    this.eventDefs.push(eventDef);\n                };\n                /*\n                eventDefId already normalized to a string\n                */\n                ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {\n                    return util_1.removeMatching(this.eventDefs, function (eventDef) {\n                        return eventDef.id === eventDefId;\n                    });\n                };\n                ArrayEventSource.prototype.removeAllEventDefs = function () {\n                    this.eventDefs = [];\n                };\n                ArrayEventSource.prototype.getPrimitive = function () {\n                    return this.rawEventDefs;\n                };\n                ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {\n                    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\n                    this.setRawEventDefs(rawProps.events);\n                    return superSuccess;\n                };\n                return ArrayEventSource;\n            }(EventSource_1.default));\n            exports.default = ArrayEventSource;\n            ArrayEventSource.defineStandardProps({\n                events: false // don't automatically transfer\n            });\n            /***/ \n        }),\n        /* 53 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            /*\n            A cache for the left/right/top/bottom/width/height values for one or more elements.\n            Works with both offset (from topleft document) and position (from offsetParent).\n            \n            options:\n            - els\n            - isHorizontal\n            - isVertical\n            */\n            var CoordCache = /*@__PURE__*/ (function () {\n                function CoordCache(options) {\n                    this.isHorizontal = false; // whether to query for left/right/width\n                    this.isVertical = false; // whether to query for top/bottom/height\n                    this.els = $(options.els);\n                    this.isHorizontal = options.isHorizontal;\n                    this.isVertical = options.isVertical;\n                    this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\n                }\n                // Queries the els for coordinates and stores them.\n                // Call this method before using and of the get* methods below.\n                CoordCache.prototype.build = function () {\n                    var offsetParentEl = this.forcedOffsetParentEl;\n                    if (!offsetParentEl && this.els.length > 0) {\n                        offsetParentEl = this.els.eq(0).offsetParent();\n                    }\n                    this.origin = offsetParentEl ?\n                        offsetParentEl.offset() :\n                        null;\n                    this.boundingRect = this.queryBoundingRect();\n                    if (this.isHorizontal) {\n                        this.buildElHorizontals();\n                    }\n                    if (this.isVertical) {\n                        this.buildElVerticals();\n                    }\n                };\n                // Destroys all internal data about coordinates, freeing memory\n                CoordCache.prototype.clear = function () {\n                    this.origin = null;\n                    this.boundingRect = null;\n                    this.lefts = null;\n                    this.rights = null;\n                    this.tops = null;\n                    this.bottoms = null;\n                };\n                // When called, if coord caches aren't built, builds them\n                CoordCache.prototype.ensureBuilt = function () {\n                    if (!this.origin) {\n                        this.build();\n                    }\n                };\n                // Populates the left/right internal coordinate arrays\n                CoordCache.prototype.buildElHorizontals = function () {\n                    var lefts = [];\n                    var rights = [];\n                    this.els.each(function (i, node) {\n                        var el = $(node);\n                        var left = el.offset().left;\n                        var width = el.outerWidth();\n                        lefts.push(left);\n                        rights.push(left + width);\n                    });\n                    this.lefts = lefts;\n                    this.rights = rights;\n                };\n                // Populates the top/bottom internal coordinate arrays\n                CoordCache.prototype.buildElVerticals = function () {\n                    var tops = [];\n                    var bottoms = [];\n                    this.els.each(function (i, node) {\n                        var el = $(node);\n                        var top = el.offset().top;\n                        var height = el.outerHeight();\n                        tops.push(top);\n                        bottoms.push(top + height);\n                    });\n                    this.tops = tops;\n                    this.bottoms = bottoms;\n                };\n                // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n                // If no intersection is made, returns undefined.\n                CoordCache.prototype.getHorizontalIndex = function (leftOffset) {\n                    this.ensureBuilt();\n                    var lefts = this.lefts;\n                    var rights = this.rights;\n                    var len = lefts.length;\n                    var i;\n                    for (i = 0; i < len; i++) {\n                        if (leftOffset >= lefts[i] && leftOffset < rights[i]) {\n                            return i;\n                        }\n                    }\n                };\n                // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n                // If no intersection is made, returns undefined.\n                CoordCache.prototype.getVerticalIndex = function (topOffset) {\n                    this.ensureBuilt();\n                    var tops = this.tops;\n                    var bottoms = this.bottoms;\n                    var len = tops.length;\n                    var i;\n                    for (i = 0; i < len; i++) {\n                        if (topOffset >= tops[i] && topOffset < bottoms[i]) {\n                            return i;\n                        }\n                    }\n                };\n                // Gets the left offset (from document left) of the element at the given index\n                CoordCache.prototype.getLeftOffset = function (leftIndex) {\n                    this.ensureBuilt();\n                    return this.lefts[leftIndex];\n                };\n                // Gets the left position (from offsetParent left) of the element at the given index\n                CoordCache.prototype.getLeftPosition = function (leftIndex) {\n                    this.ensureBuilt();\n                    return this.lefts[leftIndex] - this.origin.left;\n                };\n                // Gets the right offset (from document left) of the element at the given index.\n                // This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\n                CoordCache.prototype.getRightOffset = function (leftIndex) {\n                    this.ensureBuilt();\n                    return this.rights[leftIndex];\n                };\n                // Gets the right position (from offsetParent left) of the element at the given index.\n                // This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\n                CoordCache.prototype.getRightPosition = function (leftIndex) {\n                    this.ensureBuilt();\n                    return this.rights[leftIndex] - this.origin.left;\n                };\n                // Gets the width of the element at the given index\n                CoordCache.prototype.getWidth = function (leftIndex) {\n                    this.ensureBuilt();\n                    return this.rights[leftIndex] - this.lefts[leftIndex];\n                };\n                // Gets the top offset (from document top) of the element at the given index\n                CoordCache.prototype.getTopOffset = function (topIndex) {\n                    this.ensureBuilt();\n                    return this.tops[topIndex];\n                };\n                // Gets the top position (from offsetParent top) of the element at the given position\n                CoordCache.prototype.getTopPosition = function (topIndex) {\n                    this.ensureBuilt();\n                    return this.tops[topIndex] - this.origin.top;\n                };\n                // Gets the bottom offset (from the document top) of the element at the given index.\n                // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n                CoordCache.prototype.getBottomOffset = function (topIndex) {\n                    this.ensureBuilt();\n                    return this.bottoms[topIndex];\n                };\n                // Gets the bottom position (from the offsetParent top) of the element at the given index.\n                // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n                CoordCache.prototype.getBottomPosition = function (topIndex) {\n                    this.ensureBuilt();\n                    return this.bottoms[topIndex] - this.origin.top;\n                };\n                // Gets the height of the element at the given index\n                CoordCache.prototype.getHeight = function (topIndex) {\n                    this.ensureBuilt();\n                    return this.bottoms[topIndex] - this.tops[topIndex];\n                };\n                // Bounding Rect\n                // TODO: decouple this from CoordCache\n                // Compute and return what the elements' bounding rectangle is, from the user's perspective.\n                // Right now, only returns a rectangle if constrained by an overflow:scroll element.\n                // Returns null if there are no elements\n                CoordCache.prototype.queryBoundingRect = function () {\n                    var scrollParentEl;\n                    if (this.els.length > 0) {\n                        scrollParentEl = util_1.getScrollParent(this.els.eq(0));\n                        if (!scrollParentEl.is(document)) {\n                            return util_1.getClientRect(scrollParentEl);\n                        }\n                    }\n                    return null;\n                };\n                CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {\n                    return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\n                };\n                CoordCache.prototype.isLeftInBounds = function (leftOffset) {\n                    return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\n                };\n                CoordCache.prototype.isTopInBounds = function (topOffset) {\n                    return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\n                };\n                return CoordCache;\n            }());\n            exports.default = CoordCache;\n            /***/ \n        }),\n        /* 54 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var GlobalEmitter_1 = __webpack_require__(21);\n            /* Tracks a drag's mouse movement, firing various handlers\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // TODO: use Emitter\n            var DragListener = /*@__PURE__*/ (function () {\n                function DragListener(options) {\n                    this.isInteracting = false;\n                    this.isDistanceSurpassed = false;\n                    this.isDelayEnded = false;\n                    this.isDragging = false;\n                    this.isTouch = false;\n                    this.isGeneric = false; // initiated by 'dragstart' (jqui)\n                    this.shouldCancelTouchScroll = true;\n                    this.scrollAlwaysKills = false;\n                    this.isAutoScroll = false;\n                    // defaults\n                    this.scrollSensitivity = 30; // pixels from edge for scrolling to start\n                    this.scrollSpeed = 200; // pixels per second, at maximum speed\n                    this.scrollIntervalMs = 50; // millisecond wait between scroll increment\n                    this.options = options || {};\n                }\n                // Interaction (high-level)\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.startInteraction = function (ev, extraOptions) {\n                    if (extraOptions === void 0) {\n                        extraOptions = {};\n                    }\n                    if (ev.type === 'mousedown') {\n                        if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {\n                            return;\n                        }\n                        else if (!util_1.isPrimaryMouseButton(ev)) {\n                            return;\n                        }\n                        else {\n                            ev.preventDefault(); // prevents native selection in most browsers\n                        }\n                    }\n                    if (!this.isInteracting) {\n                        // process options\n                        this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);\n                        this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);\n                        this.subjectEl = this.options.subjectEl;\n                        util_1.preventSelection($('body'));\n                        this.isInteracting = true;\n                        this.isTouch = util_1.getEvIsTouch(ev);\n                        this.isGeneric = ev.type === 'dragstart';\n                        this.isDelayEnded = false;\n                        this.isDistanceSurpassed = false;\n                        this.originX = util_1.getEvX(ev);\n                        this.originY = util_1.getEvY(ev);\n                        this.scrollEl = util_1.getScrollParent($(ev.target));\n                        this.bindHandlers();\n                        this.initAutoScroll();\n                        this.handleInteractionStart(ev);\n                        this.startDelay(ev);\n                        if (!this.minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                };\n                DragListener.prototype.handleInteractionStart = function (ev) {\n                    this.trigger('interactionStart', ev);\n                };\n                DragListener.prototype.endInteraction = function (ev, isCancelled) {\n                    if (this.isInteracting) {\n                        this.endDrag(ev);\n                        if (this.delayTimeoutId) {\n                            clearTimeout(this.delayTimeoutId);\n                            this.delayTimeoutId = null;\n                        }\n                        this.destroyAutoScroll();\n                        this.unbindHandlers();\n                        this.isInteracting = false;\n                        this.handleInteractionEnd(ev, isCancelled);\n                        util_1.allowSelection($('body'));\n                    }\n                };\n                DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\n                    this.trigger('interactionEnd', ev, isCancelled || false);\n                };\n                // Binding To DOM\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.bindHandlers = function () {\n                    // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\n                    // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\n                    var globalEmitter = GlobalEmitter_1.default.get();\n                    if (this.isGeneric) {\n                        this.listenTo($(document), {\n                            drag: this.handleMove,\n                            dragstop: this.endInteraction\n                        });\n                    }\n                    else if (this.isTouch) {\n                        this.listenTo(globalEmitter, {\n                            touchmove: this.handleTouchMove,\n                            touchend: this.endInteraction,\n                            scroll: this.handleTouchScroll\n                        });\n                    }\n                    else {\n                        this.listenTo(globalEmitter, {\n                            mousemove: this.handleMouseMove,\n                            mouseup: this.endInteraction\n                        });\n                    }\n                    this.listenTo(globalEmitter, {\n                        selectstart: util_1.preventDefault,\n                        contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools\n                    });\n                };\n                DragListener.prototype.unbindHandlers = function () {\n                    this.stopListeningTo(GlobalEmitter_1.default.get());\n                    this.stopListeningTo($(document)); // for isGeneric\n                };\n                // Drag (high-level)\n                // -----------------------------------------------------------------------------------------------------------------\n                // extraOptions ignored if drag already started\n                DragListener.prototype.startDrag = function (ev, extraOptions) {\n                    this.startInteraction(ev, extraOptions); // ensure interaction began\n                    if (!this.isDragging) {\n                        this.isDragging = true;\n                        this.handleDragStart(ev);\n                    }\n                };\n                DragListener.prototype.handleDragStart = function (ev) {\n                    this.trigger('dragStart', ev);\n                };\n                DragListener.prototype.handleMove = function (ev) {\n                    var dx = util_1.getEvX(ev) - this.originX;\n                    var dy = util_1.getEvY(ev) - this.originY;\n                    var minDistance = this.minDistance;\n                    var distanceSq; // current distance from the origin, squared\n                    if (!this.isDistanceSurpassed) {\n                        distanceSq = dx * dx + dy * dy;\n                        if (distanceSq >= minDistance * minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                    if (this.isDragging) {\n                        this.handleDrag(dx, dy, ev);\n                    }\n                };\n                // Called while the mouse is being moved and when we know a legitimate drag is taking place\n                DragListener.prototype.handleDrag = function (dx, dy, ev) {\n                    this.trigger('drag', dx, dy, ev);\n                    this.updateAutoScroll(ev); // will possibly cause scrolling\n                };\n                DragListener.prototype.endDrag = function (ev) {\n                    if (this.isDragging) {\n                        this.isDragging = false;\n                        this.handleDragEnd(ev);\n                    }\n                };\n                DragListener.prototype.handleDragEnd = function (ev) {\n                    this.trigger('dragEnd', ev);\n                };\n                // Delay\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.startDelay = function (initialEv) {\n                    var _this = this;\n                    if (this.delay) {\n                        this.delayTimeoutId = setTimeout(function () {\n                            _this.handleDelayEnd(initialEv);\n                        }, this.delay);\n                    }\n                    else {\n                        this.handleDelayEnd(initialEv);\n                    }\n                };\n                DragListener.prototype.handleDelayEnd = function (initialEv) {\n                    this.isDelayEnded = true;\n                    if (this.isDistanceSurpassed) {\n                        this.startDrag(initialEv);\n                    }\n                };\n                // Distance\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.handleDistanceSurpassed = function (ev) {\n                    this.isDistanceSurpassed = true;\n                    if (this.isDelayEnded) {\n                        this.startDrag(ev);\n                    }\n                };\n                // Mouse / Touch\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.handleTouchMove = function (ev) {\n                    // prevent inertia and touchmove-scrolling while dragging\n                    if (this.isDragging && this.shouldCancelTouchScroll) {\n                        ev.preventDefault();\n                    }\n                    this.handleMove(ev);\n                };\n                DragListener.prototype.handleMouseMove = function (ev) {\n                    this.handleMove(ev);\n                };\n                // Scrolling (unrelated to auto-scroll)\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.handleTouchScroll = function (ev) {\n                    // if the drag is being initiated by touch, but a scroll happens before\n                    // the drag-initiating delay is over, cancel the drag\n                    if (!this.isDragging || this.scrollAlwaysKills) {\n                        this.endInteraction(ev, true); // isCancelled=true\n                    }\n                };\n                // Utils\n                // -----------------------------------------------------------------------------------------------------------------\n                // Triggers a callback. Calls a function in the option hash of the same name.\n                // Arguments beyond the first `name` are forwarded on.\n                DragListener.prototype.trigger = function (name) {\n                    var args = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        args[_i - 1] = arguments[_i];\n                    }\n                    if (this.options[name]) {\n                        this.options[name].apply(this, args);\n                    }\n                    // makes _methods callable by event name. TODO: kill this\n                    if (this['_' + name]) {\n                        this['_' + name].apply(this, args);\n                    }\n                };\n                // Auto-scroll\n                // -----------------------------------------------------------------------------------------------------------------\n                DragListener.prototype.initAutoScroll = function () {\n                    var scrollEl = this.scrollEl;\n                    this.isAutoScroll =\n                        this.options.scroll &&\n                            scrollEl &&\n                            !scrollEl.is(window) &&\n                            !scrollEl.is(document);\n                    if (this.isAutoScroll) {\n                        // debounce makes sure rapid calls don't happen\n                        this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));\n                    }\n                };\n                DragListener.prototype.destroyAutoScroll = function () {\n                    this.endAutoScroll(); // kill any animation loop\n                    // remove the scroll handler if there is a scrollEl\n                    if (this.isAutoScroll) {\n                        this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\n                    }\n                };\n                // Computes and stores the bounding rectangle of scrollEl\n                DragListener.prototype.computeScrollBounds = function () {\n                    if (this.isAutoScroll) {\n                        this.scrollBounds = util_1.getOuterRect(this.scrollEl);\n                        // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\n                    }\n                };\n                // Called when the dragging is in progress and scrolling should be updated\n                DragListener.prototype.updateAutoScroll = function (ev) {\n                    var sensitivity = this.scrollSensitivity;\n                    var bounds = this.scrollBounds;\n                    var topCloseness;\n                    var bottomCloseness;\n                    var leftCloseness;\n                    var rightCloseness;\n                    var topVel = 0;\n                    var leftVel = 0;\n                    if (bounds) {\n                        // compute closeness to edges. valid range is from 0.0 - 1.0\n                        topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;\n                        bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;\n                        leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;\n                        rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;\n                        // translate vertical closeness into velocity.\n                        // mouse must be completely in bounds for velocity to happen.\n                        if (topCloseness >= 0 && topCloseness <= 1) {\n                            topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\n                        }\n                        else if (bottomCloseness >= 0 && bottomCloseness <= 1) {\n                            topVel = bottomCloseness * this.scrollSpeed;\n                        }\n                        // translate horizontal closeness into velocity\n                        if (leftCloseness >= 0 && leftCloseness <= 1) {\n                            leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\n                        }\n                        else if (rightCloseness >= 0 && rightCloseness <= 1) {\n                            leftVel = rightCloseness * this.scrollSpeed;\n                        }\n                    }\n                    this.setScrollVel(topVel, leftVel);\n                };\n                // Sets the speed-of-scrolling for the scrollEl\n                DragListener.prototype.setScrollVel = function (topVel, leftVel) {\n                    this.scrollTopVel = topVel;\n                    this.scrollLeftVel = leftVel;\n                    this.constrainScrollVel(); // massages into realistic values\n                    // if there is non-zero velocity, and an animation loop hasn't already started, then START\n                    if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\n                        this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`\n                        this.scrollIntervalMs);\n                    }\n                };\n                // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\n                DragListener.prototype.constrainScrollVel = function () {\n                    var el = this.scrollEl;\n                    if (this.scrollTopVel < 0) {\n                        if (el.scrollTop() <= 0) {\n                            this.scrollTopVel = 0;\n                        }\n                    }\n                    else if (this.scrollTopVel > 0) {\n                        if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {\n                            this.scrollTopVel = 0;\n                        }\n                    }\n                    if (this.scrollLeftVel < 0) {\n                        if (el.scrollLeft() <= 0) {\n                            this.scrollLeftVel = 0;\n                        }\n                    }\n                    else if (this.scrollLeftVel > 0) {\n                        if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {\n                            this.scrollLeftVel = 0;\n                        }\n                    }\n                };\n                // This function gets called during every iteration of the scrolling animation loop\n                DragListener.prototype.scrollIntervalFunc = function () {\n                    var el = this.scrollEl;\n                    var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\n                    // change the value of scrollEl's scroll\n                    if (this.scrollTopVel) {\n                        el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\n                    }\n                    if (this.scrollLeftVel) {\n                        el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\n                    }\n                    this.constrainScrollVel(); // since the scroll values changed, recompute the velocities\n                    // if scrolled all the way, which causes the vels to be zero, stop the animation loop\n                    if (!this.scrollTopVel && !this.scrollLeftVel) {\n                        this.endAutoScroll();\n                    }\n                };\n                // Kills any existing scrolling animation loop\n                DragListener.prototype.endAutoScroll = function () {\n                    if (this.scrollIntervalId) {\n                        clearInterval(this.scrollIntervalId);\n                        this.scrollIntervalId = null;\n                        this.handleScrollEnd();\n                    }\n                };\n                // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\n                DragListener.prototype.handleDebouncedScroll = function () {\n                    // recompute all coordinates, but *only* if this is *not* part of our scrolling animation\n                    if (!this.scrollIntervalId) {\n                        this.handleScrollEnd();\n                    }\n                };\n                DragListener.prototype.handleScrollEnd = function () {\n                    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n                };\n                return DragListener;\n            }());\n            exports.default = DragListener;\n            ListenerMixin_1.default.mixInto(DragListener);\n            /***/ \n        }),\n        /* 55 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var Mixin_1 = __webpack_require__(14);\n            /*\n            A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\n            Prerequisite: the object being mixed into needs to be a *Grid*\n            */\n            var DayTableMixin = (function (_super) {\n                tslib_1.__extends(DayTableMixin, _super);\n                function DayTableMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // Populates internal variables used for date calculation and rendering\n                DayTableMixin.prototype.updateDayTable = function () {\n                    var t = this;\n                    var view = t.view;\n                    var calendar = view.calendar;\n                    var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);\n                    var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);\n                    var dayIndex = -1;\n                    var dayIndices = [];\n                    var dayDates = [];\n                    var daysPerRow;\n                    var firstDay;\n                    var rowCnt;\n                    while (date.isBefore(end)) {\n                        if (view.isHiddenDay(date)) {\n                            dayIndices.push(dayIndex + 0.5); // mark that it's between indices\n                        }\n                        else {\n                            dayIndex++;\n                            dayIndices.push(dayIndex);\n                            dayDates.push(date.clone());\n                        }\n                        date.add(1, 'days');\n                    }\n                    if (this.breakOnWeeks) {\n                        // count columns until the day-of-week repeats\n                        firstDay = dayDates[0].day();\n                        for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\n                            if (dayDates[daysPerRow].day() === firstDay) {\n                                break;\n                            }\n                        }\n                        rowCnt = Math.ceil(dayDates.length / daysPerRow);\n                    }\n                    else {\n                        rowCnt = 1;\n                        daysPerRow = dayDates.length;\n                    }\n                    this.dayDates = dayDates;\n                    this.dayIndices = dayIndices;\n                    this.daysPerRow = daysPerRow;\n                    this.rowCnt = rowCnt;\n                    this.updateDayTableCols();\n                };\n                // Computes and assigned the colCnt property and updates any options that may be computed from it\n                DayTableMixin.prototype.updateDayTableCols = function () {\n                    this.colCnt = this.computeColCnt();\n                    this.colHeadFormat =\n                        this.opt('columnHeaderFormat') ||\n                            this.opt('columnFormat') || // deprecated\n                            this.computeColHeadFormat();\n                };\n                // Determines how many columns there should be in the table\n                DayTableMixin.prototype.computeColCnt = function () {\n                    return this.daysPerRow;\n                };\n                // Computes the ambiguously-timed moment for the given cell\n                DayTableMixin.prototype.getCellDate = function (row, col) {\n                    return this.dayDates[this.getCellDayIndex(row, col)].clone();\n                };\n                // Computes the ambiguously-timed date range for the given cell\n                DayTableMixin.prototype.getCellRange = function (row, col) {\n                    var start = this.getCellDate(row, col);\n                    var end = start.clone().add(1, 'days');\n                    return { start: start, end: end };\n                };\n                // Returns the number of day cells, chronologically, from the first of the grid (0-based)\n                DayTableMixin.prototype.getCellDayIndex = function (row, col) {\n                    return row * this.daysPerRow + this.getColDayIndex(col);\n                };\n                // Returns the numner of day cells, chronologically, from the first cell in *any given row*\n                DayTableMixin.prototype.getColDayIndex = function (col) {\n                    if (this.isRTL) {\n                        return this.colCnt - 1 - col;\n                    }\n                    else {\n                        return col;\n                    }\n                };\n                // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n                // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n                // If before the first offset, returns a negative number.\n                // If after the last offset, returns an offset past the last cell offset.\n                // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n                DayTableMixin.prototype.getDateDayIndex = function (date) {\n                    var dayIndices = this.dayIndices;\n                    var dayOffset = date.diff(this.dayDates[0], 'days');\n                    if (dayOffset < 0) {\n                        return dayIndices[0] - 1;\n                    }\n                    else if (dayOffset >= dayIndices.length) {\n                        return dayIndices[dayIndices.length - 1] + 1;\n                    }\n                    else {\n                        return dayIndices[dayOffset];\n                    }\n                };\n                /* Options\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Computes a default column header formatting string if `colFormat` is not explicitly defined\n                DayTableMixin.prototype.computeColHeadFormat = function () {\n                    // if more than one week row, or if there are a lot of columns with not much space,\n                    // put just the day numbers will be in each cell\n                    if (this.rowCnt > 1 || this.colCnt > 10) {\n                        return 'ddd'; // \"Sat\"\n                    }\n                    else if (this.colCnt > 1) {\n                        return this.opt('dayOfMonthFormat'); // \"Sat 12/10\"\n                    }\n                    else {\n                        return 'dddd'; // \"Saturday\"\n                    }\n                };\n                /* Slicing\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Slices up a date range into a segment for every week-row it intersects with\n                DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {\n                    var daysPerRow = this.daysPerRow;\n                    var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\n                    var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n                    var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n                    var segs = [];\n                    var row;\n                    var rowFirst;\n                    var rowLast; // inclusive day-index range for current row\n                    var segFirst;\n                    var segLast; // inclusive day-index range for segment\n                    for (row = 0; row < this.rowCnt; row++) {\n                        rowFirst = row * daysPerRow;\n                        rowLast = rowFirst + daysPerRow - 1;\n                        // intersect segment's offset range with the row's\n                        segFirst = Math.max(rangeFirst, rowFirst);\n                        segLast = Math.min(rangeLast, rowLast);\n                        // deal with in-between indices\n                        segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n                        segLast = Math.floor(segLast); // in-between ends round to prev cell\n                        if (segFirst <= segLast) {\n                            segs.push({\n                                row: row,\n                                // normalize to start of row\n                                firstRowDayIndex: segFirst - rowFirst,\n                                lastRowDayIndex: segLast - rowFirst,\n                                // must be matching integers to be the segment's start/end\n                                isStart: segFirst === rangeFirst,\n                                isEnd: segLast === rangeLast\n                            });\n                        }\n                    }\n                    return segs;\n                };\n                // Slices up a date range into a segment for every day-cell it intersects with.\n                // TODO: make more DRY with sliceRangeByRow somehow.\n                DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {\n                    var daysPerRow = this.daysPerRow;\n                    var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\n                    var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n                    var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n                    var segs = [];\n                    var row;\n                    var rowFirst;\n                    var rowLast; // inclusive day-index range for current row\n                    var i;\n                    var segFirst;\n                    var segLast; // inclusive day-index range for segment\n                    for (row = 0; row < this.rowCnt; row++) {\n                        rowFirst = row * daysPerRow;\n                        rowLast = rowFirst + daysPerRow - 1;\n                        for (i = rowFirst; i <= rowLast; i++) {\n                            // intersect segment's offset range with the row's\n                            segFirst = Math.max(rangeFirst, i);\n                            segLast = Math.min(rangeLast, i);\n                            // deal with in-between indices\n                            segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n                            segLast = Math.floor(segLast); // in-between ends round to prev cell\n                            if (segFirst <= segLast) {\n                                segs.push({\n                                    row: row,\n                                    // normalize to start of row\n                                    firstRowDayIndex: segFirst - rowFirst,\n                                    lastRowDayIndex: segLast - rowFirst,\n                                    // must be matching integers to be the segment's start/end\n                                    isStart: segFirst === rangeFirst,\n                                    isEnd: segLast === rangeLast\n                                });\n                            }\n                        }\n                    }\n                    return segs;\n                };\n                /* Header Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayTableMixin.prototype.renderHeadHtml = function () {\n                    var theme = this.view.calendar.theme;\n                    return '' +\n                        '<div class=\"fc-row ' + theme.getClass('headerRow') + '\">' +\n                        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        '<thead>' +\n                        this.renderHeadTrHtml() +\n                        '</thead>' +\n                        '</table>' +\n                        '</div>';\n                };\n                DayTableMixin.prototype.renderHeadIntroHtml = function () {\n                    return this.renderIntroHtml(); // fall back to generic\n                };\n                DayTableMixin.prototype.renderHeadTrHtml = function () {\n                    return '' +\n                        '<tr>' +\n                        (this.isRTL ? '' : this.renderHeadIntroHtml()) +\n                        this.renderHeadDateCellsHtml() +\n                        (this.isRTL ? this.renderHeadIntroHtml() : '') +\n                        '</tr>';\n                };\n                DayTableMixin.prototype.renderHeadDateCellsHtml = function () {\n                    var htmls = [];\n                    var col;\n                    var date;\n                    for (col = 0; col < this.colCnt; col++) {\n                        date = this.getCellDate(0, col);\n                        htmls.push(this.renderHeadDateCellHtml(date));\n                    }\n                    return htmls.join('');\n                };\n                // TODO: when internalApiVersion, accept an object for HTML attributes\n                // (colspan should be no different)\n                DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {\n                    var t = this;\n                    var view = t.view;\n                    var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\n                    var classNames = [\n                        'fc-day-header',\n                        view.calendar.theme.getClass('widgetHeader')\n                    ];\n                    var innerHtml;\n                    if (typeof t.opt('columnHeaderHtml') === 'function') {\n                        innerHtml = t.opt('columnHeaderHtml')(date);\n                    }\n                    else if (typeof t.opt('columnHeaderText') === 'function') {\n                        innerHtml = util_1.htmlEscape(t.opt('columnHeaderText')(date));\n                    }\n                    else {\n                        innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));\n                    }\n                    // if only one row of days, the classNames on the header can represent the specific days beneath\n                    if (t.rowCnt === 1) {\n                        classNames = classNames.concat(\n                        // includes the day-of-week class\n                        // noThemeHighlight=true (don't highlight the header)\n                        t.getDayClasses(date, true));\n                    }\n                    else {\n                        classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class\n                    }\n                    return '' +\n                        '<th class=\"' + classNames.join(' ') + '\"' +\n                        ((isDateValid && t.rowCnt) === 1 ?\n                            ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\n                            '') +\n                        (colspan > 1 ?\n                            ' colspan=\"' + colspan + '\"' :\n                            '') +\n                        (otherAttrs ?\n                            ' ' + otherAttrs :\n                            '') +\n                        '>' +\n                        (isDateValid ?\n                            // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\n                            view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :\n                            // if not valid, display text, but no link\n                            innerHtml) +\n                        '</th>';\n                };\n                /* Background Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayTableMixin.prototype.renderBgTrHtml = function (row) {\n                    return '' +\n                        '<tr>' +\n                        (this.isRTL ? '' : this.renderBgIntroHtml(row)) +\n                        this.renderBgCellsHtml(row) +\n                        (this.isRTL ? this.renderBgIntroHtml(row) : '') +\n                        '</tr>';\n                };\n                DayTableMixin.prototype.renderBgIntroHtml = function (row) {\n                    return this.renderIntroHtml(); // fall back to generic\n                };\n                DayTableMixin.prototype.renderBgCellsHtml = function (row) {\n                    var htmls = [];\n                    var col;\n                    var date;\n                    for (col = 0; col < this.colCnt; col++) {\n                        date = this.getCellDate(row, col);\n                        htmls.push(this.renderBgCellHtml(date));\n                    }\n                    return htmls.join('');\n                };\n                DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {\n                    var t = this;\n                    var view = t.view;\n                    var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\n                    var classes = t.getDayClasses(date);\n                    classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));\n                    return '<td class=\"' + classes.join(' ') + '\"' +\n                        (isDateValid ?\n                            ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : // if date has a time, won't format it\n                            '') +\n                        (otherAttrs ?\n                            ' ' + otherAttrs :\n                            '') +\n                        '></td>';\n                };\n                /* Generic\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayTableMixin.prototype.renderIntroHtml = function () {\n                    // Generates the default HTML intro for any row. User classes should override\n                };\n                // TODO: a generic method for dealing with <tr>, RTL, intro\n                // when increment internalApiVersion\n                // wrapTr (scheduler)\n                /* Utils\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Applies the generic \"intro\" and \"outro\" HTML to the given cells.\n                // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\n                DayTableMixin.prototype.bookendCells = function (trEl) {\n                    var introHtml = this.renderIntroHtml();\n                    if (introHtml) {\n                        if (this.isRTL) {\n                            trEl.append(introHtml);\n                        }\n                        else {\n                            trEl.prepend(introHtml);\n                        }\n                    }\n                };\n                return DayTableMixin;\n            }(Mixin_1.default));\n            exports.default = DayTableMixin;\n            /***/ \n        }),\n        /* 56 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var BusinessHourRenderer = /*@__PURE__*/ (function () {\n                /*\n                component implements:\n                  - eventRangesToEventFootprints\n                  - eventFootprintsToSegs\n                */\n                function BusinessHourRenderer(component, fillRenderer) {\n                    this.component = component;\n                    this.fillRenderer = fillRenderer;\n                }\n                BusinessHourRenderer.prototype.render = function (businessHourGenerator) {\n                    var component = this.component;\n                    var unzonedRange = component._getDateProfile().activeUnzonedRange;\n                    var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);\n                    var eventFootprints = eventInstanceGroup ?\n                        component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :\n                        [];\n                    this.renderEventFootprints(eventFootprints);\n                };\n                BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {\n                    var segs = this.component.eventFootprintsToSegs(eventFootprints);\n                    this.renderSegs(segs);\n                    this.segs = segs;\n                };\n                BusinessHourRenderer.prototype.renderSegs = function (segs) {\n                    if (this.fillRenderer) {\n                        this.fillRenderer.renderSegs('businessHours', segs, {\n                            getClasses: function (seg) {\n                                return ['fc-nonbusiness', 'fc-bgevent'];\n                            }\n                        });\n                    }\n                };\n                BusinessHourRenderer.prototype.unrender = function () {\n                    if (this.fillRenderer) {\n                        this.fillRenderer.unrender('businessHours');\n                    }\n                    this.segs = null;\n                };\n                BusinessHourRenderer.prototype.getSegs = function () {\n                    return this.segs || [];\n                };\n                return BusinessHourRenderer;\n            }());\n            exports.default = BusinessHourRenderer;\n            /***/ \n        }),\n        /* 57 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var FillRenderer = /*@__PURE__*/ (function () {\n                function FillRenderer(component) {\n                    this.fillSegTag = 'div';\n                    this.component = component;\n                    this.elsByFill = {};\n                }\n                FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {\n                    this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);\n                };\n                FillRenderer.prototype.renderSegs = function (type, segs, props) {\n                    var els;\n                    segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs\n                    els = this.attachSegEls(type, segs);\n                    if (els) {\n                        this.reportEls(type, els);\n                    }\n                    return segs;\n                };\n                // Unrenders a specific type of fill that is currently rendered on the grid\n                FillRenderer.prototype.unrender = function (type) {\n                    var el = this.elsByFill[type];\n                    if (el) {\n                        el.remove();\n                        delete this.elsByFill[type];\n                    }\n                };\n                // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\n                // Only returns segments that successfully rendered.\n                FillRenderer.prototype.buildSegEls = function (type, segs, props) {\n                    var _this = this;\n                    var html = '';\n                    var renderedSegs = [];\n                    var i;\n                    if (segs.length) {\n                        // build a large concatenation of segment HTML\n                        for (i = 0; i < segs.length; i++) {\n                            html += this.buildSegHtml(type, segs[i], props);\n                        }\n                        // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                        // Then, compute the 'el' for each segment.\n                        $(html).each(function (i, node) {\n                            var seg = segs[i];\n                            var el = $(node);\n                            // allow custom filter methods per-type\n                            if (props.filterEl) {\n                                el = props.filterEl(seg, el);\n                            }\n                            if (el) {\n                                el = $(el); // allow custom filter to return raw DOM node\n                                // correct element type? (would be bad if a non-TD were inserted into a table for example)\n                                if (el.is(_this.fillSegTag)) {\n                                    seg.el = el;\n                                    renderedSegs.push(seg);\n                                }\n                            }\n                        });\n                    }\n                    return renderedSegs;\n                };\n                // Builds the HTML needed for one fill segment. Generic enough to work with different types.\n                FillRenderer.prototype.buildSegHtml = function (type, seg, props) {\n                    // custom hooks per-type\n                    var classes = props.getClasses ? props.getClasses(seg) : [];\n                    var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});\n                    return '<' + this.fillSegTag +\n                        (classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\n                        (css ? ' style=\"' + css + '\"' : '') +\n                        ' />';\n                };\n                // Should return wrapping DOM structure\n                FillRenderer.prototype.attachSegEls = function (type, segs) {\n                    // subclasses must implement\n                };\n                FillRenderer.prototype.reportEls = function (type, nodes) {\n                    if (this.elsByFill[type]) {\n                        this.elsByFill[type] = this.elsByFill[type].add(nodes);\n                    }\n                    else {\n                        this.elsByFill[type] = $(nodes);\n                    }\n                };\n                return FillRenderer;\n            }());\n            exports.default = FillRenderer;\n            /***/ \n        }),\n        /* 58 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var SingleEventDef_1 = __webpack_require__(13);\n            var EventFootprint_1 = __webpack_require__(36);\n            var EventSource_1 = __webpack_require__(6);\n            var HelperRenderer = /*@__PURE__*/ (function () {\n                function HelperRenderer(component, eventRenderer) {\n                    this.view = component._getView();\n                    this.component = component;\n                    this.eventRenderer = eventRenderer;\n                }\n                HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {\n                    this.renderEventFootprints([\n                        this.fabricateEventFootprint(componentFootprint)\n                    ]);\n                };\n                HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {\n                    this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));\n                };\n                HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {\n                    this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');\n                };\n                HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {\n                    var segs = this.component.eventFootprintsToSegs(eventFootprints);\n                    var classNames = 'fc-helper ' + (extraClassNames || '');\n                    var i;\n                    // assigns each seg's el and returns a subset of segs that were rendered\n                    segs = this.eventRenderer.renderFgSegEls(segs);\n                    for (i = 0; i < segs.length; i++) {\n                        segs[i].el.addClass(classNames);\n                    }\n                    if (opacity != null) {\n                        for (i = 0; i < segs.length; i++) {\n                            segs[i].el.css('opacity', opacity);\n                        }\n                    }\n                    this.helperEls = this.renderSegs(segs, sourceSeg);\n                };\n                /*\n                Must return all mock event elements\n                */\n                HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\n                    // Subclasses must implement\n                };\n                HelperRenderer.prototype.unrender = function () {\n                    if (this.helperEls) {\n                        this.helperEls.remove();\n                        this.helperEls = null;\n                    }\n                };\n                HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {\n                    var calendar = this.view.calendar;\n                    var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);\n                    var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));\n                    var dummyInstance;\n                    dummyEvent.dateProfile = eventDateProfile;\n                    dummyInstance = dummyEvent.buildInstance();\n                    return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);\n                };\n                return HelperRenderer;\n            }());\n            exports.default = HelperRenderer;\n            /***/ \n        }),\n        /* 59 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var GlobalEmitter_1 = __webpack_require__(21);\n            var Interaction_1 = __webpack_require__(15);\n            var EventPointing = (function (_super) {\n                tslib_1.__extends(EventPointing, _super);\n                function EventPointing() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                /*\n                component must implement:\n                  - publiclyTrigger\n                */\n                EventPointing.prototype.bindToEl = function (el) {\n                    var component = this.component;\n                    component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));\n                    component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));\n                    component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));\n                };\n                EventPointing.prototype.handleClick = function (seg, ev) {\n                    var res = this.component.publiclyTrigger('eventClick', {\n                        context: seg.el[0],\n                        args: [seg.footprint.getEventLegacy(), ev, this.view]\n                    });\n                    if (res === false) {\n                        ev.preventDefault();\n                    }\n                };\n                // Updates internal state and triggers handlers for when an event element is moused over\n                EventPointing.prototype.handleMouseover = function (seg, ev) {\n                    if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&\n                        !this.mousedOverSeg) {\n                        this.mousedOverSeg = seg;\n                        // TODO: move to EventSelecting's responsibility\n                        if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\n                            seg.el.addClass('fc-allow-mouse-resize');\n                        }\n                        this.component.publiclyTrigger('eventMouseover', {\n                            context: seg.el[0],\n                            args: [seg.footprint.getEventLegacy(), ev, this.view]\n                        });\n                    }\n                };\n                // Updates internal state and triggers handlers for when an event element is moused out.\n                // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\n                EventPointing.prototype.handleMouseout = function (seg, ev) {\n                    if (this.mousedOverSeg) {\n                        this.mousedOverSeg = null;\n                        // TODO: move to EventSelecting's responsibility\n                        if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\n                            seg.el.removeClass('fc-allow-mouse-resize');\n                        }\n                        this.component.publiclyTrigger('eventMouseout', {\n                            context: seg.el[0],\n                            args: [\n                                seg.footprint.getEventLegacy(),\n                                ev || {},\n                                this.view\n                            ]\n                        });\n                    }\n                };\n                EventPointing.prototype.end = function () {\n                    if (this.mousedOverSeg) {\n                        this.handleMouseout(this.mousedOverSeg);\n                    }\n                };\n                return EventPointing;\n            }(Interaction_1.default));\n            exports.default = EventPointing;\n            /***/ \n        }),\n        /* 60 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Mixin_1 = __webpack_require__(14);\n            var DateClicking_1 = __webpack_require__(245);\n            var DateSelecting_1 = __webpack_require__(225);\n            var EventPointing_1 = __webpack_require__(59);\n            var EventDragging_1 = __webpack_require__(224);\n            var EventResizing_1 = __webpack_require__(223);\n            var ExternalDropping_1 = __webpack_require__(222);\n            var StandardInteractionsMixin = (function (_super) {\n                tslib_1.__extends(StandardInteractionsMixin, _super);\n                function StandardInteractionsMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return StandardInteractionsMixin;\n            }(Mixin_1.default));\n            exports.default = StandardInteractionsMixin;\n            StandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;\n            StandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;\n            StandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;\n            StandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;\n            StandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;\n            StandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;\n            /***/ \n        }),\n        /* 61 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var CoordCache_1 = __webpack_require__(53);\n            var Popover_1 = __webpack_require__(249);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            var EventFootprint_1 = __webpack_require__(36);\n            var BusinessHourRenderer_1 = __webpack_require__(56);\n            var StandardInteractionsMixin_1 = __webpack_require__(60);\n            var InteractiveDateComponent_1 = __webpack_require__(40);\n            var DayTableMixin_1 = __webpack_require__(55);\n            var DayGridEventRenderer_1 = __webpack_require__(250);\n            var DayGridHelperRenderer_1 = __webpack_require__(251);\n            var DayGridFillRenderer_1 = __webpack_require__(252);\n            /* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var DayGrid = (function (_super) {\n                tslib_1.__extends(DayGrid, _super);\n                function DayGrid(view) {\n                    var _this = _super.call(this, view) || this;\n                    _this.cellWeekNumbersVisible = false; // display week numbers in day cell?\n                    _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\n                    // isRigid determines whether the individual rows should ignore the contents and be a constant height.\n                    // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\n                    _this.isRigid = false;\n                    _this.hasAllDayBusinessHours = true;\n                    return _this;\n                }\n                // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n                DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);\n                    var i;\n                    var seg;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        if (this.isRTL) {\n                            seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\n                            seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\n                        }\n                        else {\n                            seg.leftCol = seg.firstRowDayIndex;\n                            seg.rightCol = seg.lastRowDayIndex;\n                        }\n                    }\n                    return segs;\n                };\n                /* Date Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayGrid.prototype.renderDates = function (dateProfile) {\n                    this.dateProfile = dateProfile;\n                    this.updateDayTable();\n                    this.renderGrid();\n                };\n                DayGrid.prototype.unrenderDates = function () {\n                    this.removeSegPopover();\n                };\n                // Renders the rows and columns into the component's `this.el`, which should already be assigned.\n                DayGrid.prototype.renderGrid = function () {\n                    var view = this.view;\n                    var rowCnt = this.rowCnt;\n                    var colCnt = this.colCnt;\n                    var html = '';\n                    var row;\n                    var col;\n                    if (this.headContainerEl) {\n                        this.headContainerEl.html(this.renderHeadHtml());\n                    }\n                    for (row = 0; row < rowCnt; row++) {\n                        html += this.renderDayRowHtml(row, this.isRigid);\n                    }\n                    this.el.html(html);\n                    this.rowEls = this.el.find('.fc-row');\n                    this.cellEls = this.el.find('.fc-day, .fc-disabled-day');\n                    this.rowCoordCache = new CoordCache_1.default({\n                        els: this.rowEls,\n                        isVertical: true\n                    });\n                    this.colCoordCache = new CoordCache_1.default({\n                        els: this.cellEls.slice(0, this.colCnt),\n                        isHorizontal: true\n                    });\n                    // trigger dayRender with each cell's element\n                    for (row = 0; row < rowCnt; row++) {\n                        for (col = 0; col < colCnt; col++) {\n                            this.publiclyTrigger('dayRender', {\n                                context: view,\n                                args: [\n                                    this.getCellDate(row, col),\n                                    this.getCellEl(row, col),\n                                    view\n                                ]\n                            });\n                        }\n                    }\n                };\n                // Generates the HTML for a single row, which is a div that wraps a table.\n                // `row` is the row number.\n                DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\n                    var theme = this.view.calendar.theme;\n                    var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\n                    if (isRigid) {\n                        classes.push('fc-rigid');\n                    }\n                    return '' +\n                        '<div class=\"' + classes.join(' ') + '\">' +\n                        '<div class=\"fc-bg\">' +\n                        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        this.renderBgTrHtml(row) +\n                        '</table>' +\n                        '</div>' +\n                        '<div class=\"fc-content-skeleton\">' +\n                        '<table>' +\n                        (this.getIsNumbersVisible() ?\n                            '<thead>' +\n                                this.renderNumberTrHtml(row) +\n                                '</thead>' :\n                            '') +\n                        '</table>' +\n                        '</div>' +\n                        '</div>';\n                };\n                DayGrid.prototype.getIsNumbersVisible = function () {\n                    return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;\n                };\n                DayGrid.prototype.getIsDayNumbersVisible = function () {\n                    return this.rowCnt > 1;\n                };\n                /* Grid Number Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayGrid.prototype.renderNumberTrHtml = function (row) {\n                    return '' +\n                        '<tr>' +\n                        (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\n                        this.renderNumberCellsHtml(row) +\n                        (this.isRTL ? this.renderNumberIntroHtml(row) : '') +\n                        '</tr>';\n                };\n                DayGrid.prototype.renderNumberIntroHtml = function (row) {\n                    return this.renderIntroHtml();\n                };\n                DayGrid.prototype.renderNumberCellsHtml = function (row) {\n                    var htmls = [];\n                    var col;\n                    var date;\n                    for (col = 0; col < this.colCnt; col++) {\n                        date = this.getCellDate(row, col);\n                        htmls.push(this.renderNumberCellHtml(date));\n                    }\n                    return htmls.join('');\n                };\n                // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n                // The number row will only exist if either day numbers or week numbers are turned on.\n                DayGrid.prototype.renderNumberCellHtml = function (date) {\n                    var view = this.view;\n                    var html = '';\n                    var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\n                    var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\n                    var classes;\n                    var weekCalcFirstDoW;\n                    if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {\n                        // no numbers in day cell (week number must be along the side)\n                        return '<td/>'; //  will create an empty space above events :(\n                    }\n                    classes = this.getDayClasses(date);\n                    classes.unshift('fc-day-top');\n                    if (this.cellWeekNumbersVisible) {\n                        // To determine the day of week number change under ISO, we cannot\n                        // rely on moment.js methods such as firstDayOfWeek() or weekday(),\n                        // because they rely on the locale's dow (possibly overridden by\n                        // our firstDay option), which may not be Monday. We cannot change\n                        // dow, because that would affect the calendar start day as well.\n                        if (date._locale._fullCalendar_weekCalc === 'ISO') {\n                            weekCalcFirstDoW = 1; // Monday by ISO 8601 definition\n                        }\n                        else {\n                            weekCalcFirstDoW = date._locale.firstDayOfWeek();\n                        }\n                    }\n                    html += '<td class=\"' + classes.join(' ') + '\"' +\n                        (isDateValid ?\n                            ' data-date=\"' + date.format() + '\"' :\n                            '') +\n                        '>';\n                    if (this.cellWeekNumbersVisible && (date.day() === weekCalcFirstDoW)) {\n                        html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML\n                        );\n                    }\n                    if (isDayNumberVisible) {\n                        html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.format('D') // inner HTML\n                        );\n                    }\n                    html += '</td>';\n                    return html;\n                };\n                /* Hit System\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayGrid.prototype.prepareHits = function () {\n                    this.colCoordCache.build();\n                    this.rowCoordCache.build();\n                    this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n                };\n                DayGrid.prototype.releaseHits = function () {\n                    this.colCoordCache.clear();\n                    this.rowCoordCache.clear();\n                };\n                DayGrid.prototype.queryHit = function (leftOffset, topOffset) {\n                    if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\n                        var col = this.colCoordCache.getHorizontalIndex(leftOffset);\n                        var row = this.rowCoordCache.getVerticalIndex(topOffset);\n                        if (row != null && col != null) {\n                            return this.getCellHit(row, col);\n                        }\n                    }\n                };\n                DayGrid.prototype.getHitFootprint = function (hit) {\n                    var range = this.getCellRange(hit.row, hit.col);\n                    return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?\n                    );\n                };\n                DayGrid.prototype.getHitEl = function (hit) {\n                    return this.getCellEl(hit.row, hit.col);\n                };\n                /* Cell System\n                ------------------------------------------------------------------------------------------------------------------*/\n                // FYI: the first column is the leftmost column, regardless of date\n                DayGrid.prototype.getCellHit = function (row, col) {\n                    return {\n                        row: row,\n                        col: col,\n                        component: this,\n                        left: this.colCoordCache.getLeftOffset(col),\n                        right: this.colCoordCache.getRightOffset(col),\n                        top: this.rowCoordCache.getTopOffset(row),\n                        bottom: this.rowCoordCache.getBottomOffset(row)\n                    };\n                };\n                DayGrid.prototype.getCellEl = function (row, col) {\n                    return this.cellEls.eq(row * this.colCnt + col);\n                };\n                /* Event Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Unrenders all events currently rendered on the grid\n                DayGrid.prototype.executeEventUnrender = function () {\n                    this.removeSegPopover(); // removes the \"more..\" events popover\n                    _super.prototype.executeEventUnrender.call(this);\n                };\n                // Retrieves all rendered segment objects currently rendered on the grid\n                DayGrid.prototype.getOwnEventSegs = function () {\n                    // append the segments from the \"more...\" popover\n                    return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);\n                };\n                /* Event Drag Visualization\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of an event or external element being dragged.\n                // `eventLocation` has zoned start and end (optional)\n                DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    var i;\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        this.renderHighlight(eventFootprints[i].componentFootprint);\n                    }\n                    // render drags from OTHER components as helpers\n                    if (eventFootprints.length && seg && seg.component !== this) {\n                        this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\n                        return true; // signal helpers rendered\n                    }\n                };\n                // Unrenders any visual indication of a hovering event\n                DayGrid.prototype.unrenderDrag = function () {\n                    this.unrenderHighlight();\n                    this.helperRenderer.unrender();\n                };\n                /* Event Resize Visualization\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of an event being resized\n                DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    var i;\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        this.renderHighlight(eventFootprints[i].componentFootprint);\n                    }\n                    this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\n                };\n                // Unrenders a visual indication of an event being resized\n                DayGrid.prototype.unrenderEventResize = function () {\n                    this.unrenderHighlight();\n                    this.helperRenderer.unrender();\n                };\n                /* More+ Link Popover\n                ------------------------------------------------------------------------------------------------------------------*/\n                DayGrid.prototype.removeSegPopover = function () {\n                    if (this.segPopover) {\n                        this.segPopover.hide(); // in handler, will call segPopover's removeElement\n                    }\n                };\n                // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n                // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n                DayGrid.prototype.limitRows = function (levelLimit) {\n                    var rowStructs = this.eventRenderer.rowStructs || [];\n                    var row; // row #\n                    var rowLevelLimit;\n                    for (row = 0; row < rowStructs.length; row++) {\n                        this.unlimitRow(row);\n                        if (!levelLimit) {\n                            rowLevelLimit = false;\n                        }\n                        else if (typeof levelLimit === 'number') {\n                            rowLevelLimit = levelLimit;\n                        }\n                        else {\n                            rowLevelLimit = this.computeRowLevelLimit(row);\n                        }\n                        if (rowLevelLimit !== false) {\n                            this.limitRow(row, rowLevelLimit);\n                        }\n                    }\n                };\n                // Computes the number of levels a row will accomodate without going outside its bounds.\n                // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n                // `row` is the row number.\n                DayGrid.prototype.computeRowLevelLimit = function (row) {\n                    var rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\n                    var rowHeight = rowEl.height(); // TODO: cache somehow?\n                    var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();\n                    var i;\n                    var trEl;\n                    var trHeight;\n                    function iterInnerHeights(i, childNode) {\n                        trHeight = Math.max(trHeight, $(childNode).outerHeight());\n                    }\n                    // Reveal one level <tr> at a time and stop when we find one out of bounds\n                    for (i = 0; i < trEls.length; i++) {\n                        trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\n                        // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\n                        // so instead, find the tallest inner content element.\n                        trHeight = 0;\n                        trEl.find('> td > :first-child').each(iterInnerHeights);\n                        if (trEl.position().top + trHeight > rowHeight) {\n                            return i;\n                        }\n                    }\n                    return false; // should not limit at all\n                };\n                // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n                // `row` is the row number.\n                // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n                DayGrid.prototype.limitRow = function (row, levelLimit) {\n                    var _this = this;\n                    var rowStruct = this.eventRenderer.rowStructs[row];\n                    var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n                    var col = 0; // col #, left-to-right (not chronologically)\n                    var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n                    var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\n                    var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n                    var i;\n                    var seg;\n                    var segsBelow; // array of segment objects below `seg` in the current `col`\n                    var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n                    var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n                    var td;\n                    var rowspan;\n                    var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n                    var j;\n                    var moreTd;\n                    var moreWrap;\n                    var moreLink;\n                    // Iterates through empty level cells and places \"more\" links inside if need be\n                    var emptyCellsUntil = function (endCol) {\n                        while (col < endCol) {\n                            segsBelow = _this.getCellSegs(row, col, levelLimit);\n                            if (segsBelow.length) {\n                                td = cellMatrix[levelLimit - 1][col];\n                                moreLink = _this.renderMoreLink(row, col, segsBelow);\n                                moreWrap = $('<div/>').append(moreLink);\n                                td.append(moreWrap);\n                                moreNodes.push(moreWrap[0]);\n                            }\n                            col++;\n                        }\n                    };\n                    if (levelLimit && levelLimit < rowStruct.segLevels.length) {\n                        levelSegs = rowStruct.segLevels[levelLimit - 1];\n                        cellMatrix = rowStruct.cellMatrix;\n                        limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\n                            .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\n                        // iterate though segments in the last allowable level\n                        for (i = 0; i < levelSegs.length; i++) {\n                            seg = levelSegs[i];\n                            emptyCellsUntil(seg.leftCol); // process empty cells before the segment\n                            // determine *all* segments below `seg` that occupy the same columns\n                            colSegsBelow = [];\n                            totalSegsBelow = 0;\n                            while (col <= seg.rightCol) {\n                                segsBelow = this.getCellSegs(row, col, levelLimit);\n                                colSegsBelow.push(segsBelow);\n                                totalSegsBelow += segsBelow.length;\n                                col++;\n                            }\n                            if (totalSegsBelow) {\n                                td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\n                                rowspan = td.attr('rowspan') || 1;\n                                segMoreNodes = [];\n                                // make a replacement <td> for each column the segment occupies. will be one for each colspan\n                                for (j = 0; j < colSegsBelow.length; j++) {\n                                    moreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\n                                    segsBelow = colSegsBelow[j];\n                                    moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\n                                    );\n                                    moreWrap = $('<div/>').append(moreLink);\n                                    moreTd.append(moreWrap);\n                                    segMoreNodes.push(moreTd[0]);\n                                    moreNodes.push(moreTd[0]);\n                                }\n                                td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\n                                limitedNodes.push(td[0]);\n                            }\n                        }\n                        emptyCellsUntil(this.colCnt); // finish off the level\n                        rowStruct.moreEls = $(moreNodes); // for easy undoing later\n                        rowStruct.limitedEls = $(limitedNodes); // for easy undoing later\n                    }\n                };\n                // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n                // `row` is a row number.\n                DayGrid.prototype.unlimitRow = function (row) {\n                    var rowStruct = this.eventRenderer.rowStructs[row];\n                    if (rowStruct.moreEls) {\n                        rowStruct.moreEls.remove();\n                        rowStruct.moreEls = null;\n                    }\n                    if (rowStruct.limitedEls) {\n                        rowStruct.limitedEls.removeClass('fc-limited');\n                        rowStruct.limitedEls = null;\n                    }\n                };\n                // Renders an <a> element that represents hidden event element for a cell.\n                // Responsible for attaching click handler as well.\n                DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\n                    var _this = this;\n                    var view = this.view;\n                    return $('<a class=\"fc-more\"/>')\n                        .text(this.getMoreLinkText(hiddenSegs.length))\n                        .on('click', function (ev) {\n                        var clickOption = _this.opt('eventLimitClick');\n                        var date = _this.getCellDate(row, col);\n                        var moreEl = $(ev.currentTarget);\n                        var dayEl = _this.getCellEl(row, col);\n                        var allSegs = _this.getCellSegs(row, col);\n                        // rescope the segments to be within the cell's date\n                        var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n                        var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n                        if (typeof clickOption === 'function') {\n                            // the returned value can be an atomic option\n                            clickOption = _this.publiclyTrigger('eventLimitClick', {\n                                context: view,\n                                args: [\n                                    {\n                                        date: date.clone(),\n                                        dayEl: dayEl,\n                                        moreEl: moreEl,\n                                        segs: reslicedAllSegs,\n                                        hiddenSegs: reslicedHiddenSegs\n                                    },\n                                    ev,\n                                    view\n                                ]\n                            });\n                        }\n                        if (clickOption === 'popover') {\n                            _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n                        }\n                        else if (typeof clickOption === 'string') {\n                            view.calendar.zoomTo(date, clickOption);\n                        }\n                    });\n                };\n                // Reveals the popover that displays all events within a cell\n                DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\n                    var _this = this;\n                    var view = this.view;\n                    var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\n                    var topEl; // the element we want to match the top coordinate of\n                    var options;\n                    if (this.rowCnt === 1) {\n                        topEl = view.el; // will cause the popover to cover any sort of header\n                    }\n                    else {\n                        topEl = this.rowEls.eq(row); // will align with top of row\n                    }\n                    options = {\n                        className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),\n                        content: this.renderSegPopoverContent(row, col, segs),\n                        parentEl: view.el,\n                        top: topEl.offset().top,\n                        autoHide: true,\n                        viewportConstrain: this.opt('popoverViewportConstrain'),\n                        hide: function () {\n                            // kill everything when the popover is hidden\n                            // notify events to be removed\n                            if (_this.popoverSegs) {\n                                _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);\n                            }\n                            _this.segPopover.removeElement();\n                            _this.segPopover = null;\n                            _this.popoverSegs = null;\n                        }\n                    };\n                    // Determine horizontal coordinate.\n                    // We use the moreWrap instead of the <td> to avoid border confusion.\n                    if (this.isRTL) {\n                        options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\n                    }\n                    else {\n                        options.left = moreWrap.offset().left - 1; // -1 to be over cell border\n                    }\n                    this.segPopover = new Popover_1.default(options);\n                    this.segPopover.show();\n                    // the popover doesn't live within the grid's container element, and thus won't get the event\n                    // delegated-handlers for free. attach event-related handlers to the popover.\n                    this.bindAllSegHandlersToEl(this.segPopover.el);\n                    this.triggerAfterEventSegsRendered(segs);\n                };\n                // Builds the inner DOM contents of the segment popover\n                DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {\n                    var view = this.view;\n                    var theme = view.calendar.theme;\n                    var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));\n                    var content = $('<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' +\n                        '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' +\n                        '<span class=\"fc-title\">' +\n                        util_1.htmlEscape(title) +\n                        '</span>' +\n                        '<div class=\"fc-clear\"/>' +\n                        '</div>' +\n                        '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' +\n                        '<div class=\"fc-event-container\"></div>' +\n                        '</div>');\n                    var segContainer = content.find('.fc-event-container');\n                    var i;\n                    // render each seg's `el` and only return the visible segs\n                    segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true\n                    this.popoverSegs = segs;\n                    for (i = 0; i < segs.length; i++) {\n                        // because segments in the popover are not part of a grid coordinate system, provide a hint to any\n                        // grids that want to do drag-n-drop about which cell it came from\n                        this.hitsNeeded();\n                        segs[i].hit = this.getCellHit(row, col);\n                        this.hitsNotNeeded();\n                        segContainer.append(segs[i].el);\n                    }\n                    return content;\n                };\n                // Given the events within an array of segment objects, reslice them to be in a single day\n                DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\n                    var dayStart = dayDate.clone();\n                    var dayEnd = dayStart.clone().add(1, 'days');\n                    var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);\n                    var newSegs = [];\n                    var i;\n                    var seg;\n                    var slicedRange;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);\n                        if (slicedRange) {\n                            newSegs.push($.extend({}, seg, {\n                                footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),\n                                isStart: seg.isStart && slicedRange.isStart,\n                                isEnd: seg.isEnd && slicedRange.isEnd\n                            }));\n                        }\n                    }\n                    // force an order because eventsToSegs doesn't guarantee one\n                    // TODO: research if still needed\n                    this.eventRenderer.sortEventSegs(newSegs);\n                    return newSegs;\n                };\n                // Generates the text that should be inside a \"more\" link, given the number of events it represents\n                DayGrid.prototype.getMoreLinkText = function (num) {\n                    var opt = this.opt('eventLimitText');\n                    if (typeof opt === 'function') {\n                        return opt(num);\n                    }\n                    else {\n                        return '+' + num + ' ' + opt;\n                    }\n                };\n                // Returns segments within a given cell.\n                // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n                DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\n                    var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\n                    var level = startLevel || 0;\n                    var segs = [];\n                    var seg;\n                    while (level < segMatrix.length) {\n                        seg = segMatrix[level][col];\n                        if (seg) {\n                            segs.push(seg);\n                        }\n                        level++;\n                    }\n                    return segs;\n                };\n                return DayGrid;\n            }(InteractiveDateComponent_1.default));\n            exports.default = DayGrid;\n            DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;\n            DayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\n            DayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;\n            DayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;\n            StandardInteractionsMixin_1.default.mixInto(DayGrid);\n            DayTableMixin_1.default.mixInto(DayGrid);\n            /***/ \n        }),\n        /* 62 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Scroller_1 = __webpack_require__(39);\n            var View_1 = __webpack_require__(41);\n            var BasicViewDateProfileGenerator_1 = __webpack_require__(228);\n            var DayGrid_1 = __webpack_require__(61);\n            /* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n            // It is responsible for managing width/height.\n            var BasicView = (function (_super) {\n                tslib_1.__extends(BasicView, _super);\n                function BasicView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.dayGrid = _this.instantiateDayGrid();\n                    _this.dayGrid.isRigid = _this.hasRigidRows();\n                    if (_this.opt('weekNumbers')) {\n                        if (_this.opt('weekNumbersWithinDays')) {\n                            _this.dayGrid.cellWeekNumbersVisible = true;\n                            _this.dayGrid.colWeekNumbersVisible = false;\n                        }\n                        else {\n                            _this.dayGrid.cellWeekNumbersVisible = false;\n                            _this.dayGrid.colWeekNumbersVisible = true;\n                        }\n                    }\n                    _this.addChild(_this.dayGrid);\n                    _this.scroller = new Scroller_1.default({\n                        overflowX: 'hidden',\n                        overflowY: 'auto'\n                    });\n                    return _this;\n                }\n                // Generates the DayGrid object this view needs. Draws from this.dayGridClass\n                BasicView.prototype.instantiateDayGrid = function () {\n                    // generate a subclass on the fly with BasicView-specific behavior\n                    // TODO: cache this subclass\n                    var subclass = makeDayGridSubclass(this.dayGridClass);\n                    return new subclass(this);\n                };\n                BasicView.prototype.executeDateRender = function (dateProfile) {\n                    this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);\n                    _super.prototype.executeDateRender.call(this, dateProfile);\n                };\n                BasicView.prototype.renderSkeleton = function () {\n                    var dayGridContainerEl;\n                    var dayGridEl;\n                    this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\n                    this.scroller.render();\n                    dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\n                    dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\n                    this.el.find('.fc-body > tr > td').append(dayGridContainerEl);\n                    this.dayGrid.headContainerEl = this.el.find('.fc-head-container');\n                    this.dayGrid.setElement(dayGridEl);\n                };\n                BasicView.prototype.unrenderSkeleton = function () {\n                    this.dayGrid.removeElement();\n                    this.scroller.destroy();\n                };\n                // Builds the HTML skeleton for the view.\n                // The day-grid component will render inside of a container defined by this HTML.\n                BasicView.prototype.renderSkeletonHtml = function () {\n                    var theme = this.calendar.theme;\n                    return '' +\n                        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        (this.opt('columnHeader') ?\n                            '<thead class=\"fc-head\">' +\n                                '<tr>' +\n                                '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\n                                '</tr>' +\n                                '</thead>' :\n                            '') +\n                        '<tbody class=\"fc-body\">' +\n                        '<tr>' +\n                        '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' +\n                        '</tr>' +\n                        '</tbody>' +\n                        '</table>';\n                };\n                // Generates an HTML attribute string for setting the width of the week number column, if it is known\n                BasicView.prototype.weekNumberStyleAttr = function () {\n                    if (this.weekNumberWidth != null) {\n                        return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n                    }\n                    return '';\n                };\n                // Determines whether each row should have a constant height\n                BasicView.prototype.hasRigidRows = function () {\n                    var eventLimit = this.opt('eventLimit');\n                    return eventLimit && typeof eventLimit !== 'number';\n                };\n                /* Dimensions\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Refreshes the horizontal dimensions of the view\n                BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    var eventLimit = this.opt('eventLimit');\n                    var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');\n                    var scrollerHeight;\n                    var scrollbarWidths;\n                    // hack to give the view some height prior to dayGrid's columns being rendered\n                    // TODO: separate setting height from scroller VS dayGrid.\n                    if (!this.dayGrid.rowEls) {\n                        if (!isAuto) {\n                            scrollerHeight = this.computeScrollerHeight(totalHeight);\n                            this.scroller.setHeight(scrollerHeight);\n                        }\n                        return;\n                    }\n                    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    if (this.dayGrid.colWeekNumbersVisible) {\n                        // Make sure all week number cells running down the side have the same width.\n                        // Record the width for cells created later.\n                        this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));\n                    }\n                    // reset all heights to be natural\n                    this.scroller.clear();\n                    util_1.uncompensateScroll(headRowEl);\n                    this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n                    // is the event limit a constant level number?\n                    if (eventLimit && typeof eventLimit === 'number') {\n                        this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n                    }\n                    // distribute the height to the rows\n                    // (totalHeight is a \"recommended\" value if isAuto)\n                    scrollerHeight = this.computeScrollerHeight(totalHeight);\n                    this.setGridHeight(scrollerHeight, isAuto);\n                    // is the event limit dynamically calculated?\n                    if (eventLimit && typeof eventLimit !== 'number') {\n                        this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n                    }\n                    if (!isAuto) {\n                        this.scroller.setHeight(scrollerHeight);\n                        scrollbarWidths = this.scroller.getScrollbarWidths();\n                        if (scrollbarWidths.left || scrollbarWidths.right) {\n                            util_1.compensateScroll(headRowEl, scrollbarWidths);\n                            // doing the scrollbar compensation might have created text overflow which created more height. redo\n                            scrollerHeight = this.computeScrollerHeight(totalHeight);\n                            this.scroller.setHeight(scrollerHeight);\n                        }\n                        // guarantees the same scrollbar widths\n                        this.scroller.lockOverflow(scrollbarWidths);\n                    }\n                };\n                // given a desired total height of the view, returns what the height of the scroller should be\n                BasicView.prototype.computeScrollerHeight = function (totalHeight) {\n                    return totalHeight -\n                        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n                };\n                // Sets the height of just the DayGrid component in this view\n                BasicView.prototype.setGridHeight = function (height, isAuto) {\n                    if (isAuto) {\n                        util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n                    }\n                    else {\n                        util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n                    }\n                };\n                /* Scroll\n                ------------------------------------------------------------------------------------------------------------------*/\n                BasicView.prototype.computeInitialDateScroll = function () {\n                    return { top: 0 };\n                };\n                BasicView.prototype.queryDateScroll = function () {\n                    return { top: this.scroller.getScrollTop() };\n                };\n                BasicView.prototype.applyDateScroll = function (scroll) {\n                    if (scroll.top !== undefined) {\n                        this.scroller.setScrollTop(scroll.top);\n                    }\n                };\n                return BasicView;\n            }(View_1.default));\n            exports.default = BasicView;\n            BasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;\n            BasicView.prototype.dayGridClass = DayGrid_1.default;\n            // customize the rendering behavior of BasicView's dayGrid\n            function makeDayGridSubclass(SuperClass) {\n                return /** @class */ (function (_super) {\n                    tslib_1.__extends(SubClass, _super);\n                    function SubClass() {\n                        var _this = _super !== null && _super.apply(this, arguments) || this;\n                        _this.colWeekNumbersVisible = false; // display week numbers along the side?\n                        return _this;\n                    }\n                    // Generates the HTML that will go before the day-of week header cells\n                    SubClass.prototype.renderHeadIntroHtml = function () {\n                        var view = this.view;\n                        if (this.colWeekNumbersVisible) {\n                            return '' +\n                                '<th class=\"fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '\" ' + view.weekNumberStyleAttr() + '>' +\n                                '<span>' + // needed for matchCellWidths\n                                util_1.htmlEscape(this.opt('weekNumberTitle')) +\n                                '</span>' +\n                                '</th>';\n                        }\n                        return '';\n                    };\n                    // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n                    SubClass.prototype.renderNumberIntroHtml = function (row) {\n                        var view = this.view;\n                        var weekStart = this.getCellDate(row, 0);\n                        if (this.colWeekNumbersVisible) {\n                            return '' +\n                                '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\n                                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\n                                { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML\n                                ) +\n                                '</td>';\n                        }\n                        return '';\n                    };\n                    // Generates the HTML that goes before the day bg cells for each day-row\n                    SubClass.prototype.renderBgIntroHtml = function () {\n                        var view = this.view;\n                        if (this.colWeekNumbersVisible) {\n                            return '<td class=\"fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '\" ' +\n                                view.weekNumberStyleAttr() + '></td>';\n                        }\n                        return '';\n                    };\n                    // Generates the HTML that goes before every other type of row generated by DayGrid.\n                    // Affects helper-skeleton and highlight-skeleton rows.\n                    SubClass.prototype.renderIntroHtml = function () {\n                        var view = this.view;\n                        if (this.colWeekNumbersVisible) {\n                            return '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\n                        }\n                        return '';\n                    };\n                    SubClass.prototype.getIsNumbersVisible = function () {\n                        return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;\n                    };\n                    return SubClass;\n                }(SuperClass));\n            }\n            /***/ \n        }),\n        /* 63 */ ,\n        /* 64 */ ,\n        /* 65 */ ,\n        /* 66 */ ,\n        /* 67 */ ,\n        /* 68 */ ,\n        /* 69 */ ,\n        /* 70 */ ,\n        /* 71 */ ,\n        /* 72 */ ,\n        /* 73 */ ,\n        /* 74 */ ,\n        /* 75 */ ,\n        /* 76 */ ,\n        /* 77 */ ,\n        /* 78 */ ,\n        /* 79 */ ,\n        /* 80 */ ,\n        /* 81 */ ,\n        /* 82 */ ,\n        /* 83 */ ,\n        /* 84 */ ,\n        /* 85 */ ,\n        /* 86 */ ,\n        /* 87 */ ,\n        /* 88 */ ,\n        /* 89 */ ,\n        /* 90 */ ,\n        /* 91 */ ,\n        /* 92 */ ,\n        /* 93 */ ,\n        /* 94 */ ,\n        /* 95 */ ,\n        /* 96 */ ,\n        /* 97 */ ,\n        /* 98 */ ,\n        /* 99 */ ,\n        /* 100 */ ,\n        /* 101 */ ,\n        /* 102 */ ,\n        /* 103 */ ,\n        /* 104 */ ,\n        /* 105 */ ,\n        /* 106 */ ,\n        /* 107 */ ,\n        /* 108 */ ,\n        /* 109 */ ,\n        /* 110 */ ,\n        /* 111 */ ,\n        /* 112 */ ,\n        /* 113 */ ,\n        /* 114 */ ,\n        /* 115 */ ,\n        /* 116 */ ,\n        /* 117 */ ,\n        /* 118 */ ,\n        /* 119 */ ,\n        /* 120 */ ,\n        /* 121 */ ,\n        /* 122 */ ,\n        /* 123 */ ,\n        /* 124 */ ,\n        /* 125 */ ,\n        /* 126 */ ,\n        /* 127 */ ,\n        /* 128 */ ,\n        /* 129 */ ,\n        /* 130 */ ,\n        /* 131 */ ,\n        /* 132 */ ,\n        /* 133 */ ,\n        /* 134 */ ,\n        /* 135 */ ,\n        /* 136 */ ,\n        /* 137 */ ,\n        /* 138 */ ,\n        /* 139 */ ,\n        /* 140 */ ,\n        /* 141 */ ,\n        /* 142 */ ,\n        /* 143 */ ,\n        /* 144 */ ,\n        /* 145 */ ,\n        /* 146 */ ,\n        /* 147 */ ,\n        /* 148 */ ,\n        /* 149 */ ,\n        /* 150 */ ,\n        /* 151 */ ,\n        /* 152 */ ,\n        /* 153 */ ,\n        /* 154 */ ,\n        /* 155 */ ,\n        /* 156 */ ,\n        /* 157 */ ,\n        /* 158 */ ,\n        /* 159 */ ,\n        /* 160 */ ,\n        /* 161 */ ,\n        /* 162 */ ,\n        /* 163 */ ,\n        /* 164 */ ,\n        /* 165 */ ,\n        /* 166 */ ,\n        /* 167 */ ,\n        /* 168 */ ,\n        /* 169 */ ,\n        /* 170 */ ,\n        /* 171 */ ,\n        /* 172 */ ,\n        /* 173 */ ,\n        /* 174 */ ,\n        /* 175 */ ,\n        /* 176 */ ,\n        /* 177 */ ,\n        /* 178 */ ,\n        /* 179 */ ,\n        /* 180 */ ,\n        /* 181 */ ,\n        /* 182 */ ,\n        /* 183 */ ,\n        /* 184 */ ,\n        /* 185 */ ,\n        /* 186 */ ,\n        /* 187 */ ,\n        /* 188 */ ,\n        /* 189 */ ,\n        /* 190 */ ,\n        /* 191 */ ,\n        /* 192 */ ,\n        /* 193 */ ,\n        /* 194 */ ,\n        /* 195 */ ,\n        /* 196 */ ,\n        /* 197 */ ,\n        /* 198 */ ,\n        /* 199 */ ,\n        /* 200 */ ,\n        /* 201 */ ,\n        /* 202 */ ,\n        /* 203 */ ,\n        /* 204 */ ,\n        /* 205 */ ,\n        /* 206 */ ,\n        /* 207 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var UnzonedRange_1 = __webpack_require__(5);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            var EventDefParser_1 = __webpack_require__(49);\n            var EventSource_1 = __webpack_require__(6);\n            var util_1 = __webpack_require__(35);\n            var Constraints = /*@__PURE__*/ (function () {\n                function Constraints(eventManager, _calendar) {\n                    this.eventManager = eventManager;\n                    this._calendar = _calendar;\n                }\n                Constraints.prototype.opt = function (name) {\n                    return this._calendar.opt(name);\n                };\n                /*\n                determines if eventInstanceGroup is allowed,\n                in relation to other EVENTS and business hours.\n                */\n                Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\n                    var eventDef = eventInstanceGroup.getEventDef();\n                    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\n                    var i;\n                    var peerEventInstances = this.getPeerEventInstances(eventDef);\n                    var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\n                    var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\n                    var constraintVal = eventDef.getConstraint();\n                    var overlapVal = eventDef.getOverlap();\n                    var eventAllowFunc = this.opt('eventAllow');\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {\n                            return false;\n                        }\n                    }\n                    if (eventAllowFunc) {\n                        for (i = 0; i < eventFootprints.length; i++) {\n                            if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                };\n                Constraints.prototype.getPeerEventInstances = function (eventDef) {\n                    return this.eventManager.getEventInstancesWithoutId(eventDef.id);\n                };\n                Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\n                    var peerEventInstances = this.eventManager.getEventInstances();\n                    var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\n                    var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\n                    var selectAllowFunc;\n                    if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {\n                        selectAllowFunc = this.opt('selectAllow');\n                        if (selectAllowFunc) {\n                            return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;\n                        }\n                        else {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional\n                ) {\n                    var constraintFootprints; // ComponentFootprint[]\n                    var overlapEventFootprints; // EventFootprint[]\n                    if (constraintVal != null) {\n                        constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);\n                        if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {\n                            return false;\n                        }\n                    }\n                    overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);\n                    if (overlapVal === false) {\n                        if (overlapEventFootprints.length) {\n                            return false;\n                        }\n                    }\n                    else if (typeof overlapVal === 'function') {\n                        if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {\n                            return false;\n                        }\n                    }\n                    if (subjectEventInstance) {\n                        if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n                // Constraint\n                // ------------------------------------------------------------------------------------------------\n                Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {\n                    var i;\n                    for (i = 0; i < constraintFootprints.length; i++) {\n                        if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {\n                    var eventInstances;\n                    if (constraintVal === 'businessHours') {\n                        return this.buildCurrentBusinessFootprints(isAllDay);\n                    }\n                    else if (typeof constraintVal === 'object') {\n                        eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events\n                        if (!eventInstances) {\n                            return this.parseFootprints(constraintVal);\n                        }\n                        else {\n                            return this.eventInstancesToFootprints(eventInstances);\n                        }\n                    }\n                    else if (constraintVal != null) {\n                        eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);\n                        return this.eventInstancesToFootprints(eventInstances);\n                    }\n                };\n                // returns ComponentFootprint[]\n                // uses current view's range\n                Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {\n                    var view = this._calendar.view;\n                    var businessHourGenerator = view.get('businessHourGenerator');\n                    var unzonedRange = view.dateProfile.activeUnzonedRange;\n                    var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);\n                    if (eventInstanceGroup) {\n                        return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);\n                    }\n                    else {\n                        return [];\n                    }\n                };\n                // conversion util\n                Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {\n                    var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);\n                    var eventFootprints = this.eventRangesToEventFootprints(eventRanges);\n                    return eventFootprints.map(util_1.eventFootprintToComponentFootprint);\n                };\n                // Overlap\n                // ------------------------------------------------------------------------------------------------\n                Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {\n                    var overlapEventFootprints = [];\n                    var i;\n                    for (i = 0; i < peerEventFootprints.length; i++) {\n                        if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {\n                            overlapEventFootprints.push(peerEventFootprints[i]);\n                        }\n                    }\n                    return overlapEventFootprints;\n                };\n                // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints\n                // ------------------------------------------------------------------------------------------------\n                // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to\n                // constraints whereas the Grid code is related to rendering. Each approach might want to convert\n                // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make\n                // this more DRY.\n                /*\n                Returns false on invalid input.\n                */\n                Constraints.prototype.parseEventDefToInstances = function (eventInput) {\n                    var eventManager = this.eventManager;\n                    var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));\n                    if (!eventDef) {\n                        return false;\n                    }\n                    return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);\n                };\n                Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {\n                    var i;\n                    var eventFootprints = [];\n                    for (i = 0; i < eventRanges.length; i++) {\n                        eventFootprints.push.apply(// footprints\n                        eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\n                    }\n                    return eventFootprints;\n                };\n                Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {\n                    return [util_1.eventRangeToEventFootprint(eventRange)];\n                };\n                /*\n                Parses footprints directly.\n                Very similar to EventDateProfile::parse :(\n                */\n                Constraints.prototype.parseFootprints = function (rawInput) {\n                    var start;\n                    var end;\n                    if (rawInput.start) {\n                        start = this._calendar.moment(rawInput.start);\n                        if (!start.isValid()) {\n                            start = null;\n                        }\n                    }\n                    if (rawInput.end) {\n                        end = this._calendar.moment(rawInput.end);\n                        if (!end.isValid()) {\n                            end = null;\n                        }\n                    }\n                    return [\n                        new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay\n                        )\n                    ];\n                };\n                // Footprint Utils\n                // ----------------------------------------------------------------------------------------\n                Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {\n                    return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);\n                };\n                Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {\n                    return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);\n                };\n                return Constraints;\n            }());\n            exports.default = Constraints;\n            // optional subjectEventInstance\n            function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {\n                var i;\n                for (i = 0; i < overlapEventFootprints.length; i++) {\n                    if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {\n                var subjectLegacyInstance = subjectEventInstance.toLegacy();\n                var i;\n                var overlapEventInstance;\n                var overlapEventDef;\n                var overlapVal;\n                for (i = 0; i < overlapEventFootprints.length; i++) {\n                    overlapEventInstance = overlapEventFootprints[i].eventInstance;\n                    overlapEventDef = overlapEventInstance.def;\n                    // don't need to pass in calendar, because don't want to consider global eventOverlap property,\n                    // because we already considered that earlier in the process.\n                    overlapVal = overlapEventDef.getOverlap();\n                    if (overlapVal === false) {\n                        return false;\n                    }\n                    else if (typeof overlapVal === 'function') {\n                        if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            /***/ \n        }),\n        /* 208 */\n        /***/ (function (module, exports, __webpack_require__) {\n            /*\n            USAGE:\n              import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'\n            in class:\n              applyProps: ParsableModelInterface['applyProps']\n              applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']\n              applyMiscProps: ParsableModelInterface['applyMiscProps']\n              isStandardProp: ParsableModelInterface['isStandardProp']\n              static defineStandardProps = ParsableModelMixin.defineStandardProps\n              static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps\n            after class:\n              ParsableModelMixin.mixInto(TheClass)\n            */\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var Mixin_1 = __webpack_require__(14);\n            var ParsableModelMixin = (function (_super) {\n                tslib_1.__extends(ParsableModelMixin, _super);\n                function ParsableModelMixin() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ParsableModelMixin.defineStandardProps = function (propDefs) {\n                    var proto = this.prototype;\n                    if (!proto.hasOwnProperty('standardPropMap')) {\n                        proto.standardPropMap = Object.create(proto.standardPropMap);\n                    }\n                    util_1.copyOwnProps(propDefs, proto.standardPropMap);\n                };\n                ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {\n                    var map = this.prototype.standardPropMap;\n                    var propName;\n                    for (propName in map) {\n                        if (src[propName] != null && // in the src object?\n                            map[propName] === true // false means \"copy verbatim\"\n                        ) {\n                            dest[propName] = src[propName];\n                        }\n                    }\n                };\n                /*\n                Returns true/false for success.\n                Meant to be only called ONCE, at object creation.\n                */\n                ParsableModelMixin.prototype.applyProps = function (rawProps) {\n                    var standardPropMap = this.standardPropMap;\n                    var manualProps = {};\n                    var miscProps = {};\n                    var propName;\n                    for (propName in rawProps) {\n                        if (standardPropMap[propName] === true) {\n                            this[propName] = rawProps[propName];\n                        }\n                        else if (standardPropMap[propName] === false) {\n                            manualProps[propName] = rawProps[propName];\n                        }\n                        else {\n                            miscProps[propName] = rawProps[propName];\n                        }\n                    }\n                    this.applyMiscProps(miscProps);\n                    return this.applyManualStandardProps(manualProps);\n                };\n                /*\n                If subclasses override, they must call this supermethod and return the boolean response.\n                Meant to be only called ONCE, at object creation.\n                */\n                ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {\n                    return true;\n                };\n                /*\n                Can be called even after initial object creation.\n                */\n                ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {\n                    // subclasses can implement\n                };\n                /*\n                TODO: why is this a method when defineStandardProps is static\n                */\n                ParsableModelMixin.prototype.isStandardProp = function (propName) {\n                    return propName in this.standardPropMap;\n                };\n                return ParsableModelMixin;\n            }(Mixin_1.default));\n            exports.default = ParsableModelMixin;\n            ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps\n            /***/ \n        }),\n        /* 209 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EventInstance = /*@__PURE__*/ (function () {\n                function EventInstance(def, dateProfile) {\n                    this.def = def;\n                    this.dateProfile = dateProfile;\n                }\n                EventInstance.prototype.toLegacy = function () {\n                    var dateProfile = this.dateProfile;\n                    var obj = this.def.toLegacy();\n                    obj.start = dateProfile.start.clone();\n                    obj.end = dateProfile.end ? dateProfile.end.clone() : null;\n                    return obj;\n                };\n                return EventInstance;\n            }());\n            exports.default = EventInstance;\n            /***/ \n        }),\n        /* 210 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var EventDef_1 = __webpack_require__(34);\n            var EventInstance_1 = __webpack_require__(209);\n            var EventDateProfile_1 = __webpack_require__(17);\n            var RecurringEventDef = (function (_super) {\n                tslib_1.__extends(RecurringEventDef, _super);\n                function RecurringEventDef() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                RecurringEventDef.prototype.isAllDay = function () {\n                    return !this.startTime && !this.endTime;\n                };\n                RecurringEventDef.prototype.buildInstances = function (unzonedRange) {\n                    var calendar = this.source.calendar;\n                    var unzonedDate = unzonedRange.getStart();\n                    var unzonedEnd = unzonedRange.getEnd();\n                    var zonedDayStart;\n                    var instanceStart;\n                    var instanceEnd;\n                    var instances = [];\n                    while (unzonedDate.isBefore(unzonedEnd)) {\n                        // if everyday, or this particular day-of-week\n                        if (!this.dowHash || this.dowHash[unzonedDate.day()]) {\n                            zonedDayStart = calendar.applyTimezone(unzonedDate);\n                            instanceStart = zonedDayStart.clone();\n                            instanceEnd = null;\n                            if (this.startTime) {\n                                instanceStart.time(this.startTime);\n                            }\n                            else {\n                                instanceStart.stripTime();\n                            }\n                            if (this.endTime) {\n                                instanceEnd = zonedDayStart.clone().time(this.endTime);\n                            }\n                            instances.push(new EventInstance_1.default(this, // definition\n                            new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));\n                        }\n                        unzonedDate.add(1, 'days');\n                    }\n                    return instances;\n                };\n                RecurringEventDef.prototype.setDow = function (dowNumbers) {\n                    if (!this.dowHash) {\n                        this.dowHash = {};\n                    }\n                    for (var i = 0; i < dowNumbers.length; i++) {\n                        this.dowHash[dowNumbers[i]] = true;\n                    }\n                };\n                RecurringEventDef.prototype.clone = function () {\n                    var def = _super.prototype.clone.call(this);\n                    if (def.startTime) {\n                        def.startTime = moment.duration(this.startTime);\n                    }\n                    if (def.endTime) {\n                        def.endTime = moment.duration(this.endTime);\n                    }\n                    if (this.dowHash) {\n                        def.dowHash = $.extend({}, this.dowHash);\n                    }\n                    return def;\n                };\n                return RecurringEventDef;\n            }(EventDef_1.default));\n            exports.default = RecurringEventDef;\n            /*\n            HACK to work with TypeScript mixins\n            NOTE: if super-method fails, should still attempt to apply\n            */\n            RecurringEventDef.prototype.applyProps = function (rawProps) {\n                var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);\n                if (rawProps.start) {\n                    this.startTime = moment.duration(rawProps.start);\n                }\n                if (rawProps.end) {\n                    this.endTime = moment.duration(rawProps.end);\n                }\n                if (rawProps.dow) {\n                    this.setDow(rawProps.dow);\n                }\n                return superSuccess;\n            };\n            // Parsing\n            // ---------------------------------------------------------------------------------------------------------------------\n            RecurringEventDef.defineStandardProps({\n                start: false,\n                end: false,\n                dow: false\n            });\n            /***/ \n        }),\n        /* 211 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EventRange = /*@__PURE__*/ (function () {\n                function EventRange(unzonedRange, eventDef, eventInstance) {\n                    this.unzonedRange = unzonedRange;\n                    this.eventDef = eventDef;\n                    if (eventInstance) {\n                        this.eventInstance = eventInstance;\n                    }\n                }\n                return EventRange;\n            }());\n            exports.default = EventRange;\n            /***/ \n        }),\n        /* 212 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(35);\n            var EventInstanceGroup_1 = __webpack_require__(18);\n            var RecurringEventDef_1 = __webpack_require__(210);\n            var EventSource_1 = __webpack_require__(6);\n            var BUSINESS_HOUR_EVENT_DEFAULTS = {\n                start: '09:00',\n                end: '17:00',\n                dow: [1, 2, 3, 4, 5],\n                rendering: 'inverse-background'\n                // classNames are defined in businessHoursSegClasses\n            };\n            var BusinessHourGenerator = /*@__PURE__*/ (function () {\n                function BusinessHourGenerator(rawComplexDef, calendar) {\n                    this.rawComplexDef = rawComplexDef;\n                    this.calendar = calendar;\n                }\n                BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {\n                    var eventDefs = this.buildEventDefs(isAllDay);\n                    var eventInstanceGroup;\n                    if (eventDefs.length) {\n                        eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));\n                        // so that inverse-background rendering can happen even when no eventRanges in view\n                        eventInstanceGroup.explicitEventDef = eventDefs[0];\n                        return eventInstanceGroup;\n                    }\n                };\n                BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {\n                    var rawComplexDef = this.rawComplexDef;\n                    var rawDefs = [];\n                    var requireDow = false;\n                    var i;\n                    var defs = [];\n                    if (rawComplexDef === true) {\n                        rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim\n                    }\n                    else if ($.isPlainObject(rawComplexDef)) {\n                        rawDefs = [rawComplexDef];\n                    }\n                    else if ($.isArray(rawComplexDef)) {\n                        rawDefs = rawComplexDef;\n                        requireDow = true; // every sub-definition NEEDS a day-of-week\n                    }\n                    for (i = 0; i < rawDefs.length; i++) {\n                        if (!requireDow || rawDefs[i].dow) {\n                            defs.push(this.buildEventDef(isAllDay, rawDefs[i]));\n                        }\n                    }\n                    return defs;\n                };\n                BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {\n                    var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);\n                    if (isAllDay) {\n                        fullRawDef.start = null;\n                        fullRawDef.end = null;\n                    }\n                    return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source\n                    );\n                };\n                return BusinessHourGenerator;\n            }());\n            exports.default = BusinessHourGenerator;\n            /***/ \n        }),\n        /* 213 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Theme_1 = __webpack_require__(19);\n            var StandardTheme = (function (_super) {\n                tslib_1.__extends(StandardTheme, _super);\n                function StandardTheme() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return StandardTheme;\n            }(Theme_1.default));\n            exports.default = StandardTheme;\n            StandardTheme.prototype.classes = {\n                widget: 'fc-unthemed',\n                widgetHeader: 'fc-widget-header',\n                widgetContent: 'fc-widget-content',\n                buttonGroup: 'fc-button-group',\n                button: 'fc-button',\n                cornerLeft: 'fc-corner-left',\n                cornerRight: 'fc-corner-right',\n                stateDefault: 'fc-state-default',\n                stateActive: 'fc-state-active',\n                stateDisabled: 'fc-state-disabled',\n                stateHover: 'fc-state-hover',\n                stateDown: 'fc-state-down',\n                popoverHeader: 'fc-widget-header',\n                popoverContent: 'fc-widget-content',\n                // day grid\n                headerRow: 'fc-widget-header',\n                dayRow: 'fc-widget-content',\n                // list view\n                listView: 'fc-widget-content'\n            };\n            StandardTheme.prototype.baseIconClass = 'fc-icon';\n            StandardTheme.prototype.iconClasses = {\n                close: 'fc-icon-x',\n                prev: 'fc-icon-left-single-arrow',\n                next: 'fc-icon-right-single-arrow',\n                prevYear: 'fc-icon-left-double-arrow',\n                nextYear: 'fc-icon-right-double-arrow'\n            };\n            StandardTheme.prototype.iconOverrideOption = 'buttonIcons';\n            StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\n            StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n            /***/ \n        }),\n        /* 214 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Theme_1 = __webpack_require__(19);\n            var JqueryUiTheme = (function (_super) {\n                tslib_1.__extends(JqueryUiTheme, _super);\n                function JqueryUiTheme() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return JqueryUiTheme;\n            }(Theme_1.default));\n            exports.default = JqueryUiTheme;\n            JqueryUiTheme.prototype.classes = {\n                widget: 'ui-widget',\n                widgetHeader: 'ui-widget-header',\n                widgetContent: 'ui-widget-content',\n                buttonGroup: 'fc-button-group',\n                button: 'ui-button',\n                cornerLeft: 'ui-corner-left',\n                cornerRight: 'ui-corner-right',\n                stateDefault: 'ui-state-default',\n                stateActive: 'ui-state-active',\n                stateDisabled: 'ui-state-disabled',\n                stateHover: 'ui-state-hover',\n                stateDown: 'ui-state-down',\n                today: 'ui-state-highlight',\n                popoverHeader: 'ui-widget-header',\n                popoverContent: 'ui-widget-content',\n                // day grid\n                headerRow: 'ui-widget-header',\n                dayRow: 'ui-widget-content',\n                // list view\n                listView: 'ui-widget-content'\n            };\n            JqueryUiTheme.prototype.baseIconClass = 'ui-icon';\n            JqueryUiTheme.prototype.iconClasses = {\n                close: 'ui-icon-closethick',\n                prev: 'ui-icon-circle-triangle-w',\n                next: 'ui-icon-circle-triangle-e',\n                prevYear: 'ui-icon-seek-prev',\n                nextYear: 'ui-icon-seek-next'\n            };\n            JqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';\n            JqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';\n            JqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';\n            /***/ \n        }),\n        /* 215 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var Promise_1 = __webpack_require__(20);\n            var EventSource_1 = __webpack_require__(6);\n            var FuncEventSource = (function (_super) {\n                tslib_1.__extends(FuncEventSource, _super);\n                function FuncEventSource() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                FuncEventSource.parse = function (rawInput, calendar) {\n                    var rawProps;\n                    // normalize raw input\n                    if ($.isFunction(rawInput.events)) {\n                        rawProps = rawInput;\n                    }\n                    else if ($.isFunction(rawInput)) {\n                        rawProps = { events: rawInput };\n                    }\n                    if (rawProps) {\n                        return EventSource_1.default.parse.call(this, rawProps, calendar);\n                    }\n                    return false;\n                };\n                FuncEventSource.prototype.fetch = function (start, end, timezone) {\n                    var _this = this;\n                    this.calendar.pushLoading();\n                    return Promise_1.default.construct(function (onResolve) {\n                        _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {\n                            _this.calendar.popLoading();\n                            onResolve(_this.parseEventDefs(rawEventDefs));\n                        });\n                    });\n                };\n                FuncEventSource.prototype.getPrimitive = function () {\n                    return this.func;\n                };\n                FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {\n                    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\n                    this.func = rawProps.events;\n                    return superSuccess;\n                };\n                return FuncEventSource;\n            }(EventSource_1.default));\n            exports.default = FuncEventSource;\n            FuncEventSource.defineStandardProps({\n                events: false // don't automatically transfer\n            });\n            /***/ \n        }),\n        /* 216 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Promise_1 = __webpack_require__(20);\n            var EventSource_1 = __webpack_require__(6);\n            var JsonFeedEventSource = (function (_super) {\n                tslib_1.__extends(JsonFeedEventSource, _super);\n                function JsonFeedEventSource() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                JsonFeedEventSource.parse = function (rawInput, calendar) {\n                    var rawProps;\n                    // normalize raw input\n                    if (typeof rawInput.url === 'string') {\n                        rawProps = rawInput;\n                    }\n                    else if (typeof rawInput === 'string') {\n                        rawProps = { url: rawInput };\n                    }\n                    if (rawProps) {\n                        return EventSource_1.default.parse.call(this, rawProps, calendar);\n                    }\n                    return false;\n                };\n                JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {\n                    var _this = this;\n                    var ajaxSettings = this.ajaxSettings;\n                    var onSuccess = ajaxSettings.success;\n                    var onError = ajaxSettings.error;\n                    var requestParams = this.buildRequestParams(start, end, timezone);\n                    // todo: eventually handle the promise's then,\n                    // don't intercept success/error\n                    // tho will be a breaking API change\n                    this.calendar.pushLoading();\n                    return Promise_1.default.construct(function (onResolve, onReject) {\n                        $.ajax($.extend({}, // destination\n                        JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {\n                            url: _this.url,\n                            data: requestParams,\n                            success: function (rawEventDefs, status, xhr) {\n                                var callbackRes;\n                                _this.calendar.popLoading();\n                                if (rawEventDefs) {\n                                    callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`\n                                    if ($.isArray(callbackRes)) {\n                                        rawEventDefs = callbackRes;\n                                    }\n                                    onResolve(_this.parseEventDefs(rawEventDefs));\n                                }\n                                else {\n                                    onReject();\n                                }\n                            },\n                            error: function (xhr, statusText, errorThrown) {\n                                _this.calendar.popLoading();\n                                util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`\n                                onReject();\n                            }\n                        }));\n                    });\n                };\n                JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {\n                    var calendar = this.calendar;\n                    var ajaxSettings = this.ajaxSettings;\n                    var startParam;\n                    var endParam;\n                    var timezoneParam;\n                    var customRequestParams;\n                    var params = {};\n                    startParam = this.startParam;\n                    if (startParam == null) {\n                        startParam = calendar.opt('startParam');\n                    }\n                    endParam = this.endParam;\n                    if (endParam == null) {\n                        endParam = calendar.opt('endParam');\n                    }\n                    timezoneParam = this.timezoneParam;\n                    if (timezoneParam == null) {\n                        timezoneParam = calendar.opt('timezoneParam');\n                    }\n                    // retrieve any outbound GET/POST $.ajax data from the options\n                    if ($.isFunction(ajaxSettings.data)) {\n                        // supplied as a function that returns a key/value object\n                        customRequestParams = ajaxSettings.data();\n                    }\n                    else {\n                        // probably supplied as a straight key/value object\n                        customRequestParams = ajaxSettings.data || {};\n                    }\n                    $.extend(params, customRequestParams);\n                    params[startParam] = start.format();\n                    params[endParam] = end.format();\n                    if (timezone && timezone !== 'local') {\n                        params[timezoneParam] = timezone;\n                    }\n                    return params;\n                };\n                JsonFeedEventSource.prototype.getPrimitive = function () {\n                    return this.url;\n                };\n                JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {\n                    this.ajaxSettings = rawProps;\n                };\n                JsonFeedEventSource.AJAX_DEFAULTS = {\n                    dataType: 'json',\n                    cache: false\n                };\n                return JsonFeedEventSource;\n            }(EventSource_1.default));\n            exports.default = JsonFeedEventSource;\n            JsonFeedEventSource.defineStandardProps({\n                // automatically transfer (true)...\n                url: true,\n                startParam: true,\n                endParam: true,\n                timezoneParam: true\n            });\n            /***/ \n        }),\n        /* 217 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EmitterMixin_1 = __webpack_require__(11);\n            var TaskQueue = /*@__PURE__*/ (function () {\n                function TaskQueue() {\n                    this.q = [];\n                    this.isPaused = false;\n                    this.isRunning = false;\n                }\n                TaskQueue.prototype.queue = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    this.q.push.apply(this.q, args); // append\n                    this.tryStart();\n                };\n                TaskQueue.prototype.pause = function () {\n                    this.isPaused = true;\n                };\n                TaskQueue.prototype.resume = function () {\n                    this.isPaused = false;\n                    this.tryStart();\n                };\n                TaskQueue.prototype.getIsIdle = function () {\n                    return !this.isRunning && !this.isPaused;\n                };\n                TaskQueue.prototype.tryStart = function () {\n                    if (!this.isRunning && this.canRunNext()) {\n                        this.isRunning = true;\n                        this.trigger('start');\n                        this.runRemaining();\n                    }\n                };\n                TaskQueue.prototype.canRunNext = function () {\n                    return !this.isPaused && this.q.length;\n                };\n                TaskQueue.prototype.runRemaining = function () {\n                    var _this = this;\n                    var task;\n                    var res;\n                    do {\n                        task = this.q.shift(); // always freshly reference q. might have been reassigned.\n                        res = this.runTask(task);\n                        if (res && res.then) {\n                            res.then(function () {\n                                if (_this.canRunNext()) {\n                                    _this.runRemaining();\n                                }\n                            });\n                            return; // prevent marking as stopped\n                        }\n                    } while (this.canRunNext());\n                    this.trigger('stop'); // not really a 'stop' ... more of a 'drained'\n                    this.isRunning = false;\n                    // if 'stop' handler added more tasks.... TODO: write test for this\n                    this.tryStart();\n                };\n                TaskQueue.prototype.runTask = function (task) {\n                    return task(); // task *is* the function, but subclasses can change the format of a task\n                };\n                return TaskQueue;\n            }());\n            exports.default = TaskQueue;\n            EmitterMixin_1.default.mixInto(TaskQueue);\n            /***/ \n        }),\n        /* 218 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var TaskQueue_1 = __webpack_require__(217);\n            var RenderQueue = (function (_super) {\n                tslib_1.__extends(RenderQueue, _super);\n                function RenderQueue(waitsByNamespace) {\n                    var _this = _super.call(this) || this;\n                    _this.waitsByNamespace = waitsByNamespace || {};\n                    return _this;\n                }\n                RenderQueue.prototype.queue = function (taskFunc, namespace, type) {\n                    var task = {\n                        func: taskFunc,\n                        namespace: namespace,\n                        type: type\n                    };\n                    var waitMs;\n                    if (namespace) {\n                        waitMs = this.waitsByNamespace[namespace];\n                    }\n                    if (this.waitNamespace) {\n                        if (namespace === this.waitNamespace && waitMs != null) {\n                            this.delayWait(waitMs);\n                        }\n                        else {\n                            this.clearWait();\n                            this.tryStart();\n                        }\n                    }\n                    if (this.compoundTask(task)) {\n                        if (!this.waitNamespace && waitMs != null) {\n                            this.startWait(namespace, waitMs);\n                        }\n                        else {\n                            this.tryStart();\n                        }\n                    }\n                };\n                RenderQueue.prototype.startWait = function (namespace, waitMs) {\n                    this.waitNamespace = namespace;\n                    this.spawnWait(waitMs);\n                };\n                RenderQueue.prototype.delayWait = function (waitMs) {\n                    clearTimeout(this.waitId);\n                    this.spawnWait(waitMs);\n                };\n                RenderQueue.prototype.spawnWait = function (waitMs) {\n                    var _this = this;\n                    this.waitId = setTimeout(function () {\n                        _this.waitNamespace = null;\n                        _this.tryStart();\n                    }, waitMs);\n                };\n                RenderQueue.prototype.clearWait = function () {\n                    if (this.waitNamespace) {\n                        clearTimeout(this.waitId);\n                        this.waitId = null;\n                        this.waitNamespace = null;\n                    }\n                };\n                RenderQueue.prototype.canRunNext = function () {\n                    if (!_super.prototype.canRunNext.call(this)) {\n                        return false;\n                    }\n                    // waiting for a certain namespace to stop receiving tasks?\n                    if (this.waitNamespace) {\n                        var q = this.q;\n                        // if there was a different namespace task in the meantime,\n                        // that forces all previously-waiting tasks to suddenly execute.\n                        // TODO: find a way to do this in constant time.\n                        for (var i = 0; i < q.length; i++) {\n                            if (q[i].namespace !== this.waitNamespace) {\n                                return true; // allow execution\n                            }\n                        }\n                        return false;\n                    }\n                    return true;\n                };\n                RenderQueue.prototype.runTask = function (task) {\n                    task.func();\n                };\n                RenderQueue.prototype.compoundTask = function (newTask) {\n                    var q = this.q;\n                    var shouldAppend = true;\n                    var i;\n                    var task;\n                    if (newTask.namespace && newTask.type === 'destroy') {\n                        // remove all init/add/remove ops with same namespace, regardless of order\n                        for (i = q.length - 1; i >= 0; i--) {\n                            task = q[i];\n                            switch (task.type) {\n                                case 'init':\n                                    shouldAppend = false;\n                                // the latest destroy is cancelled out by not doing the init\n                                /* falls through */\n                                case 'add':\n                                /* falls through */\n                                case 'remove':\n                                    q.splice(i, 1); // remove task\n                            }\n                        }\n                    }\n                    if (shouldAppend) {\n                        q.push(newTask);\n                    }\n                    return shouldAppend;\n                };\n                return RenderQueue;\n            }(TaskQueue_1.default));\n            exports.default = RenderQueue;\n            /***/ \n        }),\n        /* 219 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var moment_ext_1 = __webpack_require__(10);\n            var date_formatting_1 = __webpack_require__(47);\n            var Component_1 = __webpack_require__(237);\n            var util_2 = __webpack_require__(35);\n            var DateComponent = (function (_super) {\n                tslib_1.__extends(DateComponent, _super);\n                function DateComponent(_view, _options) {\n                    var _this = _super.call(this) || this;\n                    _this.isRTL = false; // frequently accessed options\n                    _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits\n                    _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?\n                    _this.isDatesRendered = false;\n                    // hack to set options prior to the this.opt calls\n                    if (_view) {\n                        _this['view'] = _view;\n                    }\n                    if (_options) {\n                        _this['options'] = _options;\n                    }\n                    _this.uid = String(DateComponent.guid++);\n                    _this.childrenByUid = {};\n                    _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));\n                    _this.isRTL = _this.opt('isRTL');\n                    if (_this.fillRendererClass) {\n                        _this.fillRenderer = new _this.fillRendererClass(_this);\n                    }\n                    if (_this.eventRendererClass) {\n                        _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);\n                    }\n                    if (_this.helperRendererClass && _this.eventRenderer) {\n                        _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);\n                    }\n                    if (_this.businessHourRendererClass && _this.fillRenderer) {\n                        _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);\n                    }\n                    return _this;\n                }\n                DateComponent.prototype.addChild = function (child) {\n                    if (!this.childrenByUid[child.uid]) {\n                        this.childrenByUid[child.uid] = child;\n                        return true;\n                    }\n                    return false;\n                };\n                DateComponent.prototype.removeChild = function (child) {\n                    if (this.childrenByUid[child.uid]) {\n                        delete this.childrenByUid[child.uid];\n                        return true;\n                    }\n                    return false;\n                };\n                // TODO: only do if isInDom?\n                // TODO: make part of Component, along with children/batch-render system?\n                DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    this.callChildren('updateSize', arguments);\n                };\n                // Options\n                // -----------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.opt = function (name) {\n                    return this._getView().opt(name); // default implementation\n                };\n                DateComponent.prototype.publiclyTrigger = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var calendar = this._getCalendar();\n                    return calendar.publiclyTrigger.apply(calendar, args);\n                };\n                DateComponent.prototype.hasPublicHandlers = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var calendar = this._getCalendar();\n                    return calendar.hasPublicHandlers.apply(calendar, args);\n                };\n                // Date\n                // -----------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.executeDateRender = function (dateProfile) {\n                    this.dateProfile = dateProfile; // for rendering\n                    this.renderDates(dateProfile);\n                    this.isDatesRendered = true;\n                    this.callChildren('executeDateRender', arguments);\n                };\n                DateComponent.prototype.executeDateUnrender = function () {\n                    this.callChildren('executeDateUnrender', arguments);\n                    this.dateProfile = null;\n                    this.unrenderDates();\n                    this.isDatesRendered = false;\n                };\n                // date-cell content only\n                DateComponent.prototype.renderDates = function (dateProfile) {\n                    // subclasses should implement\n                };\n                // date-cell content only\n                DateComponent.prototype.unrenderDates = function () {\n                    // subclasses should override\n                };\n                // Now-Indicator\n                // -----------------------------------------------------------------------------------------------------------------\n                // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\n                // should be refreshed. If something falsy is returned, no time indicator is rendered at all.\n                DateComponent.prototype.getNowIndicatorUnit = function () {\n                    // subclasses should implement\n                };\n                // Renders a current time indicator at the given datetime\n                DateComponent.prototype.renderNowIndicator = function (date) {\n                    this.callChildren('renderNowIndicator', arguments);\n                };\n                // Undoes the rendering actions from renderNowIndicator\n                DateComponent.prototype.unrenderNowIndicator = function () {\n                    this.callChildren('unrenderNowIndicator', arguments);\n                };\n                // Business Hours\n                // ---------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {\n                    if (this.businessHourRenderer) {\n                        this.businessHourRenderer.render(businessHourGenerator);\n                    }\n                    this.callChildren('renderBusinessHours', arguments);\n                };\n                // Unrenders previously-rendered business-hours\n                DateComponent.prototype.unrenderBusinessHours = function () {\n                    this.callChildren('unrenderBusinessHours', arguments);\n                    if (this.businessHourRenderer) {\n                        this.businessHourRenderer.unrender();\n                    }\n                };\n                // Event Displaying\n                // -----------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.executeEventRender = function (eventsPayload) {\n                    if (this.eventRenderer) {\n                        this.eventRenderer.rangeUpdated(); // poorly named now\n                        this.eventRenderer.render(eventsPayload);\n                    }\n                    else if (this['renderEvents']) {\n                        this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));\n                    }\n                    this.callChildren('executeEventRender', arguments);\n                };\n                DateComponent.prototype.executeEventUnrender = function () {\n                    this.callChildren('executeEventUnrender', arguments);\n                    if (this.eventRenderer) {\n                        this.eventRenderer.unrender();\n                    }\n                    else if (this['destroyEvents']) {\n                        this['destroyEvents']();\n                    }\n                };\n                DateComponent.prototype.getBusinessHourSegs = function () {\n                    var segs = this.getOwnBusinessHourSegs();\n                    this.iterChildren(function (child) {\n                        segs.push.apply(segs, child.getBusinessHourSegs());\n                    });\n                    return segs;\n                };\n                DateComponent.prototype.getOwnBusinessHourSegs = function () {\n                    if (this.businessHourRenderer) {\n                        return this.businessHourRenderer.getSegs();\n                    }\n                    return [];\n                };\n                DateComponent.prototype.getEventSegs = function () {\n                    var segs = this.getOwnEventSegs();\n                    this.iterChildren(function (child) {\n                        segs.push.apply(segs, child.getEventSegs());\n                    });\n                    return segs;\n                };\n                DateComponent.prototype.getOwnEventSegs = function () {\n                    if (this.eventRenderer) {\n                        return this.eventRenderer.getSegs();\n                    }\n                    return [];\n                };\n                // Event Rendering Triggering\n                // -----------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.triggerAfterEventsRendered = function () {\n                    this.triggerAfterEventSegsRendered(this.getEventSegs());\n                    this.publiclyTrigger('eventAfterAllRender', {\n                        context: this,\n                        args: [this]\n                    });\n                };\n                DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {\n                    var _this = this;\n                    // an optimization, because getEventLegacy is expensive\n                    if (this.hasPublicHandlers('eventAfterRender')) {\n                        segs.forEach(function (seg) {\n                            var legacy;\n                            if (seg.el) {\n                                legacy = seg.footprint.getEventLegacy();\n                                _this.publiclyTrigger('eventAfterRender', {\n                                    context: legacy,\n                                    args: [legacy, seg.el, _this]\n                                });\n                            }\n                        });\n                    }\n                };\n                DateComponent.prototype.triggerBeforeEventsDestroyed = function () {\n                    this.triggerBeforeEventSegsDestroyed(this.getEventSegs());\n                };\n                DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {\n                    var _this = this;\n                    if (this.hasPublicHandlers('eventDestroy')) {\n                        segs.forEach(function (seg) {\n                            var legacy;\n                            if (seg.el) {\n                                legacy = seg.footprint.getEventLegacy();\n                                _this.publiclyTrigger('eventDestroy', {\n                                    context: legacy,\n                                    args: [legacy, seg.el, _this]\n                                });\n                            }\n                        });\n                    }\n                };\n                // Event Rendering Utils\n                // -----------------------------------------------------------------------------------------------------------------\n                // Hides all rendered event segments linked to the given event\n                // RECURSIVE with subcomponents\n                DateComponent.prototype.showEventsWithId = function (eventDefId) {\n                    this.getEventSegs().forEach(function (seg) {\n                        if (seg.footprint.eventDef.id === eventDefId &&\n                            seg.el // necessary?\n                        ) {\n                            seg.el.css('visibility', '');\n                        }\n                    });\n                    this.callChildren('showEventsWithId', arguments);\n                };\n                // Shows all rendered event segments linked to the given event\n                // RECURSIVE with subcomponents\n                DateComponent.prototype.hideEventsWithId = function (eventDefId) {\n                    this.getEventSegs().forEach(function (seg) {\n                        if (seg.footprint.eventDef.id === eventDefId &&\n                            seg.el // necessary?\n                        ) {\n                            seg.el.css('visibility', 'hidden');\n                        }\n                    });\n                    this.callChildren('hideEventsWithId', arguments);\n                };\n                // Drag-n-Drop Rendering (for both events and external elements)\n                // ---------------------------------------------------------------------------------------------------------------\n                // Renders a visual indication of a event or external-element drag over the given drop zone.\n                // If an external-element, seg will be `null`.\n                // Must return elements used for any mock events.\n                DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    var renderedHelper = false;\n                    this.iterChildren(function (child) {\n                        if (child.renderDrag(eventFootprints, seg, isTouch)) {\n                            renderedHelper = true;\n                        }\n                    });\n                    return renderedHelper;\n                };\n                // Unrenders a visual indication of an event or external-element being dragged.\n                DateComponent.prototype.unrenderDrag = function () {\n                    this.callChildren('unrenderDrag', arguments);\n                };\n                // Event Resizing\n                // ---------------------------------------------------------------------------------------------------------------\n                // Renders a visual indication of an event being resized.\n                DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    this.callChildren('renderEventResize', arguments);\n                };\n                // Unrenders a visual indication of an event being resized.\n                DateComponent.prototype.unrenderEventResize = function () {\n                    this.callChildren('unrenderEventResize', arguments);\n                };\n                // Selection\n                // ---------------------------------------------------------------------------------------------------------------\n                // Renders a visual indication of the selection\n                // TODO: rename to `renderSelection` after legacy is gone\n                DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {\n                    this.renderHighlight(componentFootprint);\n                    this.callChildren('renderSelectionFootprint', arguments);\n                };\n                // Unrenders a visual indication of selection\n                DateComponent.prototype.unrenderSelection = function () {\n                    this.unrenderHighlight();\n                    this.callChildren('unrenderSelection', arguments);\n                };\n                // Highlight\n                // ---------------------------------------------------------------------------------------------------------------\n                // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\n                DateComponent.prototype.renderHighlight = function (componentFootprint) {\n                    if (this.fillRenderer) {\n                        this.fillRenderer.renderFootprint('highlight', componentFootprint, {\n                            getClasses: function () {\n                                return ['fc-highlight'];\n                            }\n                        });\n                    }\n                    this.callChildren('renderHighlight', arguments);\n                };\n                // Unrenders the emphasis on a date range\n                DateComponent.prototype.unrenderHighlight = function () {\n                    if (this.fillRenderer) {\n                        this.fillRenderer.unrender('highlight');\n                    }\n                    this.callChildren('unrenderHighlight', arguments);\n                };\n                // Hit Areas\n                // ---------------------------------------------------------------------------------------------------------------\n                // just because all DateComponents support this interface\n                // doesn't mean they need to have their own internal coord system. they can defer to sub-components.\n                DateComponent.prototype.hitsNeeded = function () {\n                    if (!(this.hitsNeededDepth++)) {\n                        this.prepareHits();\n                    }\n                    this.callChildren('hitsNeeded', arguments);\n                };\n                DateComponent.prototype.hitsNotNeeded = function () {\n                    if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\n                        this.releaseHits();\n                    }\n                    this.callChildren('hitsNotNeeded', arguments);\n                };\n                DateComponent.prototype.prepareHits = function () {\n                    // subclasses can implement\n                };\n                DateComponent.prototype.releaseHits = function () {\n                    // subclasses can implement\n                };\n                // Given coordinates from the topleft of the document, return data about the date-related area underneath.\n                // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\n                // Must have a `grid` property, a reference to this current grid. TODO: avoid this\n                // The returned object will be processed by getHitFootprint and getHitEl.\n                DateComponent.prototype.queryHit = function (leftOffset, topOffset) {\n                    var childrenByUid = this.childrenByUid;\n                    var uid;\n                    var hit;\n                    for (uid in childrenByUid) {\n                        hit = childrenByUid[uid].queryHit(leftOffset, topOffset);\n                        if (hit) {\n                            break;\n                        }\n                    }\n                    return hit;\n                };\n                DateComponent.prototype.getSafeHitFootprint = function (hit) {\n                    var footprint = this.getHitFootprint(hit);\n                    if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {\n                        return null;\n                    }\n                    return footprint;\n                };\n                DateComponent.prototype.getHitFootprint = function (hit) {\n                    // what about being abstract!?\n                };\n                // Given position-level information about a date-related area within the grid,\n                // should return a jQuery element that best represents it. passed to dayClick callback.\n                DateComponent.prototype.getHitEl = function (hit) {\n                    // what about being abstract!?\n                };\n                /* Converting eventRange -> eventFootprint\n                ------------------------------------------------------------------------------------------------------------------*/\n                DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {\n                    var eventFootprints = [];\n                    var i;\n                    for (i = 0; i < eventRanges.length; i++) {\n                        eventFootprints.push.apply(// append\n                        eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\n                    }\n                    return eventFootprints;\n                };\n                DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {\n                    return [util_2.eventRangeToEventFootprint(eventRange)];\n                };\n                /* Converting componentFootprint/eventFootprint -> segs\n                ------------------------------------------------------------------------------------------------------------------*/\n                DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {\n                    var segs = [];\n                    var i;\n                    for (i = 0; i < eventFootprints.length; i++) {\n                        segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));\n                    }\n                    return segs;\n                };\n                // Given an event's span (unzoned start/end and other misc data), and the event itself,\n                // slices into segments and attaches event-derived properties to them.\n                // eventSpan - { start, end, isStart, isEnd, otherthings... }\n                DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {\n                    var unzonedRange = eventFootprint.componentFootprint.unzonedRange;\n                    var segs;\n                    var i;\n                    var seg;\n                    segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        if (!unzonedRange.isStart) {\n                            seg.isStart = false;\n                        }\n                        if (!unzonedRange.isEnd) {\n                            seg.isEnd = false;\n                        }\n                        seg.footprint = eventFootprint;\n                        // TODO: rename to seg.eventFootprint\n                    }\n                    return segs;\n                };\n                DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    return [];\n                };\n                // Utils\n                // ---------------------------------------------------------------------------------------------------------------\n                DateComponent.prototype.callChildren = function (methodName, args) {\n                    this.iterChildren(function (child) {\n                        child[methodName].apply(child, args);\n                    });\n                };\n                DateComponent.prototype.iterChildren = function (func) {\n                    var childrenByUid = this.childrenByUid;\n                    var uid;\n                    for (uid in childrenByUid) {\n                        func(childrenByUid[uid]);\n                    }\n                };\n                DateComponent.prototype._getCalendar = function () {\n                    var t = this;\n                    return t.calendar || t.view.calendar;\n                };\n                DateComponent.prototype._getView = function () {\n                    return this.view;\n                };\n                DateComponent.prototype._getDateProfile = function () {\n                    return this._getView().get('dateProfile');\n                };\n                // Generates HTML for an anchor to another view into the calendar.\n                // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\n                // `gotoOptions` can either be a moment input, or an object with the form:\n                // { date, type, forceOff }\n                // `type` is a view-type like \"day\" or \"week\". default value is \"day\".\n                // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\n                DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {\n                    var date;\n                    var type;\n                    var forceOff;\n                    var finalOptions;\n                    if ($.isPlainObject(gotoOptions)) {\n                        date = gotoOptions.date;\n                        type = gotoOptions.type;\n                        forceOff = gotoOptions.forceOff;\n                    }\n                    else {\n                        date = gotoOptions; // a single moment input\n                    }\n                    date = moment_ext_1.default(date); // if a string, parse it\n                    finalOptions = {\n                        date: date.format('YYYY-MM-DD'),\n                        type: type || 'day'\n                    };\n                    if (typeof attrs === 'string') {\n                        innerHtml = attrs;\n                        attrs = null;\n                    }\n                    attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space\n                    innerHtml = innerHtml || '';\n                    if (!forceOff && this.opt('navLinks')) {\n                        return '<a' + attrs +\n                            ' data-goto=\"' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '\">' +\n                            innerHtml +\n                            '</a>';\n                    }\n                    else {\n                        return '<span' + attrs + '>' +\n                            innerHtml +\n                            '</span>';\n                    }\n                };\n                DateComponent.prototype.getAllDayHtml = function () {\n                    return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));\n                };\n                // Computes HTML classNames for a single-day element\n                DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {\n                    var view = this._getView();\n                    var classes = [];\n                    var today;\n                    if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {\n                        classes.push('fc-disabled-day'); // TODO: jQuery UI theme?\n                    }\n                    else {\n                        classes.push('fc-' + util_1.dayIDs[date.day()]);\n                        if (view.isDateInOtherMonth(date, this.dateProfile)) {\n                            classes.push('fc-other-month');\n                        }\n                        today = view.calendar.getNow();\n                        if (date.isSame(today, 'day')) {\n                            classes.push('fc-today');\n                            if (noThemeHighlight !== true) {\n                                classes.push(view.calendar.theme.getClass('today'));\n                            }\n                        }\n                        else if (date < today) {\n                            classes.push('fc-past');\n                        }\n                        else {\n                            classes.push('fc-future');\n                        }\n                    }\n                    return classes;\n                };\n                // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\n                // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\n                // The timezones of the dates within `range` will be respected.\n                DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {\n                    var end = range.end;\n                    if (isAllDay) {\n                        end = end.clone().subtract(1); // convert to inclusive. last ms of previous day\n                    }\n                    return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);\n                };\n                // Compute the number of the give units in the \"current\" range.\n                // Will return a floating-point number. Won't round.\n                DateComponent.prototype.currentRangeAs = function (unit) {\n                    return this._getDateProfile().currentUnzonedRange.as(unit);\n                };\n                // Returns the date range of the full days the given range visually appears to occupy.\n                // Returns a plain object with start/end, NOT an UnzonedRange!\n                DateComponent.prototype.computeDayRange = function (unzonedRange) {\n                    var calendar = this._getCalendar();\n                    var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts\n                    var end = calendar.msToUtcMoment(unzonedRange.endMs);\n                    var endTimeMS = +end.time(); // # of milliseconds into `endDay`\n                    var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\n                    // If the end time is actually inclusively part of the next day and is equal to or\n                    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n                    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n                    if (endTimeMS && endTimeMS >= this.nextDayThreshold) {\n                        endDay.add(1, 'days');\n                    }\n                    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n                    if (endDay <= startDay) {\n                        endDay = startDay.clone().add(1, 'days');\n                    }\n                    return { start: startDay, end: endDay };\n                };\n                // Does the given range visually appear to occupy more than one day?\n                DateComponent.prototype.isMultiDayRange = function (unzonedRange) {\n                    var dayRange = this.computeDayRange(unzonedRange);\n                    return dayRange.end.diff(dayRange.start, 'days') > 1;\n                };\n                DateComponent.guid = 0; // TODO: better system for this?\n                return DateComponent;\n            }(Component_1.default));\n            exports.default = DateComponent;\n            // legacy\n            function convertEventsPayloadToLegacyArray(eventsPayload) {\n                var eventDefId;\n                var eventInstances;\n                var legacyEvents = [];\n                var i;\n                for (eventDefId in eventsPayload) {\n                    eventInstances = eventsPayload[eventDefId].eventInstances;\n                    for (i = 0; i < eventInstances.length; i++) {\n                        legacyEvents.push(eventInstances[i].toLegacy());\n                    }\n                }\n                return legacyEvents;\n            }\n            /***/ \n        }),\n        /* 220 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var options_1 = __webpack_require__(32);\n            var Iterator_1 = __webpack_require__(238);\n            var GlobalEmitter_1 = __webpack_require__(21);\n            var EmitterMixin_1 = __webpack_require__(11);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var Toolbar_1 = __webpack_require__(239);\n            var OptionsManager_1 = __webpack_require__(240);\n            var ViewSpecManager_1 = __webpack_require__(241);\n            var Constraints_1 = __webpack_require__(207);\n            var locale_1 = __webpack_require__(31);\n            var moment_ext_1 = __webpack_require__(10);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            var EventDateProfile_1 = __webpack_require__(17);\n            var EventManager_1 = __webpack_require__(242);\n            var BusinessHourGenerator_1 = __webpack_require__(212);\n            var EventSourceParser_1 = __webpack_require__(38);\n            var EventDefParser_1 = __webpack_require__(49);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var EventDefMutation_1 = __webpack_require__(37);\n            var EventSource_1 = __webpack_require__(6);\n            var ThemeRegistry_1 = __webpack_require__(51);\n            var Calendar = /*@__PURE__*/ (function () {\n                function Calendar(el, overrides) {\n                    this.loadingLevel = 0; // number of simultaneous loading tasks\n                    this.ignoreUpdateViewSize = 0;\n                    this.freezeContentHeightDepth = 0;\n                    // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\n                    // unneeded() is called in destroy.\n                    GlobalEmitter_1.default.needed();\n                    this.el = el;\n                    this.viewsByType = {};\n                    this.optionsManager = new OptionsManager_1.default(this, overrides);\n                    this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);\n                    this.initMomentInternals(); // needs to happen after options hash initialized\n                    this.initCurrentDate();\n                    this.initEventManager();\n                    this.constraints = new Constraints_1.default(this.eventManager, this);\n                    this.constructed();\n                }\n                Calendar.prototype.constructed = function () {\n                    // useful for monkeypatching. used?\n                };\n                Calendar.prototype.getView = function () {\n                    return this.view;\n                };\n                Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {\n                    var optHandler = this.opt(name);\n                    var context;\n                    var args;\n                    if ($.isPlainObject(triggerInfo)) {\n                        context = triggerInfo.context;\n                        args = triggerInfo.args;\n                    }\n                    else if ($.isArray(triggerInfo)) {\n                        args = triggerInfo;\n                    }\n                    if (context == null) {\n                        context = this.el[0]; // fallback context\n                    }\n                    if (!args) {\n                        args = [];\n                    }\n                    this.triggerWith(name, context, args); // Emitter's method\n                    if (optHandler) {\n                        return optHandler.apply(context, args);\n                    }\n                };\n                Calendar.prototype.hasPublicHandlers = function (name) {\n                    return this.hasHandlers(name) ||\n                        this.opt(name); // handler specified in options\n                };\n                // Options Public API\n                // -----------------------------------------------------------------------------------------------------------------\n                // public getter/setter\n                Calendar.prototype.option = function (name, value) {\n                    var newOptionHash;\n                    if (typeof name === 'string') {\n                        if (value === undefined) {\n                            return this.optionsManager.get(name);\n                        }\n                        else {\n                            newOptionHash = {};\n                            newOptionHash[name] = value;\n                            this.optionsManager.add(newOptionHash);\n                        }\n                    }\n                    else if (typeof name === 'object') {\n                        this.optionsManager.add(name);\n                    }\n                };\n                // private getter\n                Calendar.prototype.opt = function (name) {\n                    return this.optionsManager.get(name);\n                };\n                // View\n                // -----------------------------------------------------------------------------------------------------------------\n                // Given a view name for a custom view or a standard view, creates a ready-to-go View object\n                Calendar.prototype.instantiateView = function (viewType) {\n                    var spec = this.viewSpecManager.getViewSpec(viewType);\n                    if (!spec) {\n                        throw new Error(\"View type \\\"\" + viewType + \"\\\" is not valid\");\n                    }\n                    return new spec['class'](this, spec);\n                };\n                // Returns a boolean about whether the view is okay to instantiate at some point\n                Calendar.prototype.isValidViewType = function (viewType) {\n                    return Boolean(this.viewSpecManager.getViewSpec(viewType));\n                };\n                Calendar.prototype.changeView = function (viewName, dateOrRange) {\n                    if (dateOrRange) {\n                        if (dateOrRange.start && dateOrRange.end) {\n                            this.optionsManager.recordOverrides({\n                                visibleRange: dateOrRange\n                            });\n                        }\n                        else {\n                            this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\n                        }\n                    }\n                    this.renderView(viewName);\n                };\n                // Forces navigation to a view for the given date.\n                // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n                Calendar.prototype.zoomTo = function (newDate, viewType) {\n                    var spec;\n                    viewType = viewType || 'day'; // day is default zoom\n                    spec = this.viewSpecManager.getViewSpec(viewType) ||\n                        this.viewSpecManager.getUnitViewSpec(viewType);\n                    this.currentDate = newDate.clone();\n                    this.renderView(spec ? spec.type : null);\n                };\n                // Current Date\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.initCurrentDate = function () {\n                    var defaultDateInput = this.opt('defaultDate');\n                    // compute the initial ambig-timezone date\n                    if (defaultDateInput != null) {\n                        this.currentDate = this.moment(defaultDateInput).stripZone();\n                    }\n                    else {\n                        this.currentDate = this.getNow(); // getNow already returns unzoned\n                    }\n                };\n                Calendar.prototype.prev = function () {\n                    var view = this.view;\n                    var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\n                    if (prevInfo.isValid) {\n                        this.currentDate = prevInfo.date;\n                        this.renderView();\n                    }\n                };\n                Calendar.prototype.next = function () {\n                    var view = this.view;\n                    var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\n                    if (nextInfo.isValid) {\n                        this.currentDate = nextInfo.date;\n                        this.renderView();\n                    }\n                };\n                Calendar.prototype.prevYear = function () {\n                    this.currentDate.add(-1, 'years');\n                    this.renderView();\n                };\n                Calendar.prototype.nextYear = function () {\n                    this.currentDate.add(1, 'years');\n                    this.renderView();\n                };\n                Calendar.prototype.today = function () {\n                    this.currentDate = this.getNow(); // should deny like prev/next?\n                    this.renderView();\n                };\n                Calendar.prototype.gotoDate = function (zonedDateInput) {\n                    this.currentDate = this.moment(zonedDateInput).stripZone();\n                    this.renderView();\n                };\n                Calendar.prototype.incrementDate = function (delta) {\n                    this.currentDate.add(moment.duration(delta));\n                    this.renderView();\n                };\n                // for external API\n                Calendar.prototype.getDate = function () {\n                    return this.applyTimezone(this.currentDate); // infuse the calendar's timezone\n                };\n                // Loading Triggering\n                // -----------------------------------------------------------------------------------------------------------------\n                // Should be called when any type of async data fetching begins\n                Calendar.prototype.pushLoading = function () {\n                    if (!(this.loadingLevel++)) {\n                        this.publiclyTrigger('loading', [true, this.view]);\n                    }\n                };\n                // Should be called when any type of async data fetching completes\n                Calendar.prototype.popLoading = function () {\n                    if (!(--this.loadingLevel)) {\n                        this.publiclyTrigger('loading', [false, this.view]);\n                    }\n                };\n                // High-level Rendering\n                // -----------------------------------------------------------------------------------\n                Calendar.prototype.render = function () {\n                    if (!this.contentEl) {\n                        this.initialRender();\n                    }\n                    else if (this.elementVisible()) {\n                        // mainly for the public API\n                        this.calcSize();\n                        this.updateViewSize();\n                    }\n                };\n                Calendar.prototype.initialRender = function () {\n                    var _this = this;\n                    var el = this.el;\n                    el.addClass('fc');\n                    // event delegation for nav links\n                    el.on('click.fc', 'a[data-goto]', function (ev) {\n                        var anchorEl = $(ev.currentTarget);\n                        var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\n                        var date = _this.moment(gotoOptions.date);\n                        var viewType = gotoOptions.type;\n                        // property like \"navLinkDayClick\". might be a string or a function\n                        var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');\n                        if (typeof customAction === 'function') {\n                            customAction(date, ev);\n                        }\n                        else {\n                            if (typeof customAction === 'string') {\n                                viewType = customAction;\n                            }\n                            _this.zoomTo(date, viewType);\n                        }\n                    });\n                    // called immediately, and upon option change\n                    this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {\n                        var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);\n                        var theme = new themeClass(_this.optionsManager);\n                        var widgetClass = theme.getClass('widget');\n                        _this.theme = theme;\n                        if (widgetClass) {\n                            el.addClass(widgetClass);\n                        }\n                    }, function () {\n                        var widgetClass = _this.theme.getClass('widget');\n                        _this.theme = null;\n                        if (widgetClass) {\n                            el.removeClass(widgetClass);\n                        }\n                    });\n                    this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {\n                        _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);\n                        if (_this.view) {\n                            _this.view.set('businessHourGenerator', _this.businessHourGenerator);\n                        }\n                    }, function () {\n                        _this.businessHourGenerator = null;\n                    });\n                    // called immediately, and upon option change.\n                    // HACK: locale often affects isRTL, so we explicitly listen to that too.\n                    this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {\n                        el.toggleClass('fc-ltr', !opts.isRTL);\n                        el.toggleClass('fc-rtl', opts.isRTL);\n                    });\n                    this.contentEl = $(\"<div class='fc-view-container'/>\").prependTo(el);\n                    this.initToolbars();\n                    this.renderHeader();\n                    this.renderFooter();\n                    this.renderView(this.opt('defaultView'));\n                    if (this.opt('handleWindowResize')) {\n                        $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls\n                        this.windowResize.bind(this), this.opt('windowResizeDelay')));\n                    }\n                };\n                Calendar.prototype.destroy = function () {\n                    if (this.view) {\n                        this.clearView();\n                    }\n                    this.toolbarsManager.proxyCall('removeElement');\n                    this.contentEl.remove();\n                    this.el.removeClass('fc fc-ltr fc-rtl');\n                    // removes theme-related root className\n                    this.optionsManager.unwatch('settingTheme');\n                    this.optionsManager.unwatch('settingBusinessHourGenerator');\n                    this.el.off('.fc'); // unbind nav link handlers\n                    if (this.windowResizeProxy) {\n                        $(window).unbind('resize', this.windowResizeProxy);\n                        this.windowResizeProxy = null;\n                    }\n                    GlobalEmitter_1.default.unneeded();\n                };\n                Calendar.prototype.elementVisible = function () {\n                    return this.el.is(':visible');\n                };\n                // Render Queue\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.bindViewHandlers = function (view) {\n                    var _this = this;\n                    view.watch('titleForCalendar', ['title'], function (deps) {\n                        if (view === _this.view) {\n                            _this.setToolbarsTitle(deps.title);\n                        }\n                    });\n                    view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {\n                        if (view === _this.view) {\n                            _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates\n                            _this.updateToolbarButtons(deps.dateProfile);\n                        }\n                    });\n                };\n                Calendar.prototype.unbindViewHandlers = function (view) {\n                    view.unwatch('titleForCalendar');\n                    view.unwatch('dateProfileForCalendar');\n                };\n                // View Rendering\n                // -----------------------------------------------------------------------------------\n                // Renders a view because of a date change, view-type change, or for the first time.\n                // If not given a viewType, keep the current view but render different dates.\n                // Accepts an optional scroll state to restore to.\n                Calendar.prototype.renderView = function (viewType) {\n                    var oldView = this.view;\n                    var newView;\n                    this.freezeContentHeight();\n                    if (oldView && viewType && oldView.type !== viewType) {\n                        this.clearView();\n                    }\n                    // if viewType changed, or the view was never created, create a fresh view\n                    if (!this.view && viewType) {\n                        newView = this.view =\n                            this.viewsByType[viewType] ||\n                                (this.viewsByType[viewType] = this.instantiateView(viewType));\n                        this.bindViewHandlers(newView);\n                        newView.startBatchRender(); // so that setElement+setDate rendering are joined\n                        newView.setElement($(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(this.contentEl));\n                        this.toolbarsManager.proxyCall('activateButton', viewType);\n                    }\n                    if (this.view) {\n                        // prevent unnecessary change firing\n                        if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {\n                            this.view.set('businessHourGenerator', this.businessHourGenerator);\n                        }\n                        this.view.setDate(this.currentDate);\n                        if (newView) {\n                            newView.stopBatchRender();\n                        }\n                    }\n                    this.thawContentHeight();\n                };\n                // Unrenders the current view and reflects this change in the Header.\n                // Unregsiters the `view`, but does not remove from viewByType hash.\n                Calendar.prototype.clearView = function () {\n                    var currentView = this.view;\n                    this.toolbarsManager.proxyCall('deactivateButton', currentView.type);\n                    this.unbindViewHandlers(currentView);\n                    currentView.removeElement();\n                    currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time\n                    this.view = null;\n                };\n                // Destroys the view, including the view object. Then, re-instantiates it and renders it.\n                // Maintains the same scroll state.\n                // TODO: maintain any other user-manipulated state.\n                Calendar.prototype.reinitView = function () {\n                    var oldView = this.view;\n                    var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll\n                    this.freezeContentHeight();\n                    this.clearView();\n                    this.calcSize();\n                    this.renderView(oldView.type); // needs the type to freshly render\n                    this.view.applyScroll(scroll);\n                    this.thawContentHeight();\n                };\n                // Resizing\n                // -----------------------------------------------------------------------------------\n                Calendar.prototype.getSuggestedViewHeight = function () {\n                    if (this.suggestedViewHeight == null) {\n                        this.calcSize();\n                    }\n                    return this.suggestedViewHeight;\n                };\n                Calendar.prototype.isHeightAuto = function () {\n                    return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\n                };\n                Calendar.prototype.updateViewSize = function (isResize) {\n                    if (isResize === void 0) {\n                        isResize = false;\n                    }\n                    var view = this.view;\n                    var scroll;\n                    if (!this.ignoreUpdateViewSize && view) {\n                        if (isResize) {\n                            this.calcSize();\n                            scroll = view.queryScroll();\n                        }\n                        this.ignoreUpdateViewSize++;\n                        view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);\n                        this.ignoreUpdateViewSize--;\n                        if (isResize) {\n                            view.applyScroll(scroll);\n                        }\n                        return true; // signal success\n                    }\n                };\n                Calendar.prototype.calcSize = function () {\n                    if (this.elementVisible()) {\n                        this._calcSize();\n                    }\n                };\n                Calendar.prototype._calcSize = function () {\n                    var contentHeightInput = this.opt('contentHeight');\n                    var heightInput = this.opt('height');\n                    if (typeof contentHeightInput === 'number') {\n                        this.suggestedViewHeight = contentHeightInput;\n                    }\n                    else if (typeof contentHeightInput === 'function') {\n                        this.suggestedViewHeight = contentHeightInput();\n                    }\n                    else if (typeof heightInput === 'number') {\n                        this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\n                    }\n                    else if (typeof heightInput === 'function') {\n                        this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\n                    }\n                    else if (heightInput === 'parent') {\n                        this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\n                    }\n                    else {\n                        this.suggestedViewHeight = Math.round(this.contentEl.width() /\n                            Math.max(this.opt('aspectRatio'), .5));\n                    }\n                };\n                Calendar.prototype.windowResize = function (ev) {\n                    if (\n                    // the purpose: so we don't process jqui \"resize\" events that have bubbled up\n                    // cast to any because .target, which is Element, can't be compared to window for some reason.\n                    ev.target === window &&\n                        this.view &&\n                        this.view.isDatesRendered) {\n                        if (this.updateViewSize(true)) {\n                            this.publiclyTrigger('windowResize', [this.view]);\n                        }\n                    }\n                };\n                /* Height \"Freezing\"\n                -----------------------------------------------------------------------------*/\n                Calendar.prototype.freezeContentHeight = function () {\n                    if (!(this.freezeContentHeightDepth++)) {\n                        this.forceFreezeContentHeight();\n                    }\n                };\n                Calendar.prototype.forceFreezeContentHeight = function () {\n                    this.contentEl.css({\n                        width: '100%',\n                        height: this.contentEl.height(),\n                        overflow: 'hidden'\n                    });\n                };\n                Calendar.prototype.thawContentHeight = function () {\n                    this.freezeContentHeightDepth--;\n                    // always bring back to natural height\n                    this.contentEl.css({\n                        width: '',\n                        height: '',\n                        overflow: ''\n                    });\n                    // but if there are future thaws, re-freeze\n                    if (this.freezeContentHeightDepth) {\n                        this.forceFreezeContentHeight();\n                    }\n                };\n                // Toolbar\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.initToolbars = function () {\n                    this.header = new Toolbar_1.default(this, this.computeHeaderOptions());\n                    this.footer = new Toolbar_1.default(this, this.computeFooterOptions());\n                    this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);\n                };\n                Calendar.prototype.computeHeaderOptions = function () {\n                    return {\n                        extraClasses: 'fc-header-toolbar',\n                        layout: this.opt('header')\n                    };\n                };\n                Calendar.prototype.computeFooterOptions = function () {\n                    return {\n                        extraClasses: 'fc-footer-toolbar',\n                        layout: this.opt('footer')\n                    };\n                };\n                // can be called repeatedly and Header will rerender\n                Calendar.prototype.renderHeader = function () {\n                    var header = this.header;\n                    header.setToolbarOptions(this.computeHeaderOptions());\n                    header.render();\n                    if (header.el) {\n                        this.el.prepend(header.el);\n                    }\n                };\n                // can be called repeatedly and Footer will rerender\n                Calendar.prototype.renderFooter = function () {\n                    var footer = this.footer;\n                    footer.setToolbarOptions(this.computeFooterOptions());\n                    footer.render();\n                    if (footer.el) {\n                        this.el.append(footer.el);\n                    }\n                };\n                Calendar.prototype.setToolbarsTitle = function (title) {\n                    this.toolbarsManager.proxyCall('updateTitle', title);\n                };\n                Calendar.prototype.updateToolbarButtons = function (dateProfile) {\n                    var now = this.getNow();\n                    var view = this.view;\n                    var todayInfo = view.dateProfileGenerator.build(now);\n                    var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\n                    var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\n                    this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?\n                        'enableButton' :\n                        'disableButton', 'today');\n                    this.toolbarsManager.proxyCall(prevInfo.isValid ?\n                        'enableButton' :\n                        'disableButton', 'prev');\n                    this.toolbarsManager.proxyCall(nextInfo.isValid ?\n                        'enableButton' :\n                        'disableButton', 'next');\n                };\n                Calendar.prototype.queryToolbarsHeight = function () {\n                    return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {\n                        var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\n                        return accumulator + toolbarHeight;\n                    }, 0);\n                };\n                // Selection\n                // -----------------------------------------------------------------------------------------------------------------\n                // this public method receives start/end dates in any format, with any timezone\n                Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {\n                    this.view.select(this.buildSelectFootprint.apply(this, arguments));\n                };\n                Calendar.prototype.unselect = function () {\n                    if (this.view) {\n                        this.view.unselect();\n                    }\n                };\n                // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\n                Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {\n                    var start = this.moment(zonedStartInput).stripZone();\n                    var end;\n                    if (zonedEndInput) {\n                        end = this.moment(zonedEndInput).stripZone();\n                    }\n                    else if (start.hasTime()) {\n                        end = start.clone().add(this.defaultTimedEventDuration);\n                    }\n                    else {\n                        end = start.clone().add(this.defaultAllDayEventDuration);\n                    }\n                    return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());\n                };\n                // Date Utils\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.initMomentInternals = function () {\n                    var _this = this;\n                    this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\n                    this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\n                    // Called immediately, and when any of the options change.\n                    // Happens before any internal objects rebuild or rerender, because this is very core.\n                    this.optionsManager.watch('buildingMomentLocale', [\n                        '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\n                        '?firstDay', '?weekNumberCalculation'\n                    ], function (opts) {\n                        var weekNumberCalculation = opts.weekNumberCalculation;\n                        var firstDay = opts.firstDay;\n                        var _week;\n                        // normalize\n                        if (weekNumberCalculation === 'iso') {\n                            weekNumberCalculation = 'ISO'; // normalize\n                        }\n                        var localeData = Object.create(// make a cheap copy\n                        locale_1.getMomentLocaleData(opts.locale) // will fall back to en\n                        );\n                        if (opts.monthNames) {\n                            localeData._months = opts.monthNames;\n                        }\n                        if (opts.monthNamesShort) {\n                            localeData._monthsShort = opts.monthNamesShort;\n                        }\n                        if (opts.dayNames) {\n                            localeData._weekdays = opts.dayNames;\n                        }\n                        if (opts.dayNamesShort) {\n                            localeData._weekdaysShort = opts.dayNamesShort;\n                        }\n                        if (firstDay == null && weekNumberCalculation === 'ISO') {\n                            firstDay = 1;\n                        }\n                        if (firstDay != null) {\n                            _week = Object.create(localeData._week); // _week: { dow: # }\n                            _week.dow = firstDay;\n                            localeData._week = _week;\n                        }\n                        if (weekNumberCalculation === 'ISO' ||\n                            weekNumberCalculation === 'local' ||\n                            typeof weekNumberCalculation === 'function') {\n                            localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\n                        }\n                        _this.localeData = localeData;\n                        // If the internal current date object already exists, move to new locale.\n                        // We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\n                        if (_this.currentDate) {\n                            _this.localizeMoment(_this.currentDate); // sets to localeData\n                        }\n                    });\n                };\n                // Builds a moment using the settings of the current calendar: timezone and locale.\n                // Accepts anything the vanilla moment() constructor accepts.\n                Calendar.prototype.moment = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var mom;\n                    if (this.opt('timezone') === 'local') {\n                        mom = moment_ext_1.default.apply(null, args);\n                        // Force the moment to be local, because momentExt doesn't guarantee it.\n                        if (mom.hasTime()) {\n                            mom.local();\n                        }\n                    }\n                    else if (this.opt('timezone') === 'UTC') {\n                        mom = moment_ext_1.default.utc.apply(null, args); // process as UTC\n                    }\n                    else {\n                        mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone\n                    }\n                    this.localizeMoment(mom); // TODO\n                    return mom;\n                };\n                Calendar.prototype.msToMoment = function (ms, forceAllDay) {\n                    var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\n                    if (forceAllDay) {\n                        mom.stripTime();\n                    }\n                    else {\n                        mom = this.applyTimezone(mom); // may or may not apply locale\n                    }\n                    this.localizeMoment(mom);\n                    return mom;\n                };\n                Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {\n                    var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\n                    if (forceAllDay) {\n                        mom.stripTime();\n                    }\n                    this.localizeMoment(mom);\n                    return mom;\n                };\n                // Updates the given moment's locale settings to the current calendar locale settings.\n                Calendar.prototype.localizeMoment = function (mom) {\n                    mom._locale = this.localeData;\n                };\n                // Returns a boolean about whether or not the calendar knows how to calculate\n                // the timezone offset of arbitrary dates in the current timezone.\n                Calendar.prototype.getIsAmbigTimezone = function () {\n                    return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\n                };\n                // Returns a copy of the given date in the current timezone. Has no effect on dates without times.\n                Calendar.prototype.applyTimezone = function (date) {\n                    if (!date.hasTime()) {\n                        return date.clone();\n                    }\n                    var zonedDate = this.moment(date.toArray());\n                    var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();\n                    var adjustedZonedDate;\n                    // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\n                    if (timeAdjust) {\n                        adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\n                        if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) {\n                            zonedDate = adjustedZonedDate;\n                        }\n                    }\n                    return zonedDate;\n                };\n                /*\n                Assumes the footprint is non-open-ended.\n                */\n                Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {\n                    if (ignoreEnd === void 0) {\n                        ignoreEnd = false;\n                    }\n                    var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);\n                    var end;\n                    if (!ignoreEnd) {\n                        end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);\n                    }\n                    if (componentFootprint.isAllDay) {\n                        start.stripTime();\n                        if (end) {\n                            end.stripTime();\n                        }\n                    }\n                    else {\n                        start = this.applyTimezone(start);\n                        if (end) {\n                            end = this.applyTimezone(end);\n                        }\n                    }\n                    return new EventDateProfile_1.default(start, end, this);\n                };\n                // Returns a moment for the current date, as defined by the client's computer or from the `now` option.\n                // Will return an moment with an ambiguous timezone.\n                Calendar.prototype.getNow = function () {\n                    var now = this.opt('now');\n                    if (typeof now === 'function') {\n                        now = now();\n                    }\n                    return this.moment(now).stripZone();\n                };\n                // Produces a human-readable string for the given duration.\n                // Side-effect: changes the locale of the given duration.\n                Calendar.prototype.humanizeDuration = function (duration) {\n                    return duration.locale(this.opt('locale')).humanize();\n                };\n                // will return `null` if invalid range\n                Calendar.prototype.parseUnzonedRange = function (rangeInput) {\n                    var start = null;\n                    var end = null;\n                    if (rangeInput.start) {\n                        start = this.moment(rangeInput.start).stripZone();\n                    }\n                    if (rangeInput.end) {\n                        end = this.moment(rangeInput.end).stripZone();\n                    }\n                    if (!start && !end) {\n                        return null;\n                    }\n                    if (start && end && end.isBefore(start)) {\n                        return null;\n                    }\n                    return new UnzonedRange_1.default(start, end);\n                };\n                // Event-Date Utilities\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.initEventManager = function () {\n                    var _this = this;\n                    var eventManager = new EventManager_1.default(this);\n                    var rawSources = this.opt('eventSources') || [];\n                    var singleRawSource = this.opt('events');\n                    this.eventManager = eventManager;\n                    if (singleRawSource) {\n                        rawSources.unshift(singleRawSource);\n                    }\n                    eventManager.on('release', function (eventsPayload) {\n                        _this.trigger('eventsReset', eventsPayload);\n                    });\n                    eventManager.freeze();\n                    rawSources.forEach(function (rawSource) {\n                        var source = EventSourceParser_1.default.parse(rawSource, _this);\n                        if (source) {\n                            eventManager.addSource(source);\n                        }\n                    });\n                    eventManager.thaw();\n                };\n                Calendar.prototype.requestEvents = function (start, end) {\n                    return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));\n                };\n                // Get an event's normalized end date. If not present, calculate it from the defaults.\n                Calendar.prototype.getEventEnd = function (event) {\n                    if (event.end) {\n                        return event.end.clone();\n                    }\n                    else {\n                        return this.getDefaultEventEnd(event.allDay, event.start);\n                    }\n                };\n                // Given an event's allDay status and start date, return what its fallback end date should be.\n                // TODO: rename to computeDefaultEventEnd\n                Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {\n                    var end = zonedStart.clone();\n                    if (allDay) {\n                        end.stripTime().add(this.defaultAllDayEventDuration);\n                    }\n                    else {\n                        end.add(this.defaultTimedEventDuration);\n                    }\n                    if (this.getIsAmbigTimezone()) {\n                        end.stripZone(); // we don't know what the tzo should be\n                    }\n                    return end;\n                };\n                // Public Events API\n                // -----------------------------------------------------------------------------------------------------------------\n                Calendar.prototype.rerenderEvents = function () {\n                    this.view.flash('displayingEvents');\n                };\n                Calendar.prototype.refetchEvents = function () {\n                    this.eventManager.refetchAllSources();\n                };\n                Calendar.prototype.renderEvents = function (eventInputs, isSticky) {\n                    this.eventManager.freeze();\n                    for (var i = 0; i < eventInputs.length; i++) {\n                        this.renderEvent(eventInputs[i], isSticky);\n                    }\n                    this.eventManager.thaw();\n                };\n                Calendar.prototype.renderEvent = function (eventInput, isSticky) {\n                    if (isSticky === void 0) {\n                        isSticky = false;\n                    }\n                    var eventManager = this.eventManager;\n                    var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);\n                    if (eventDef) {\n                        eventManager.addEventDef(eventDef, isSticky);\n                    }\n                };\n                // legacyQuery operates on legacy event instance objects\n                Calendar.prototype.removeEvents = function (legacyQuery) {\n                    var eventManager = this.eventManager;\n                    var legacyInstances = [];\n                    var idMap = {};\n                    var eventDef;\n                    var i;\n                    if (legacyQuery == null) {\n                        eventManager.removeAllEventDefs(); // persist=true\n                    }\n                    else {\n                        eventManager.getEventInstances().forEach(function (eventInstance) {\n                            legacyInstances.push(eventInstance.toLegacy());\n                        });\n                        legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);\n                        // compute unique IDs\n                        for (i = 0; i < legacyInstances.length; i++) {\n                            eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);\n                            idMap[eventDef.id] = true;\n                        }\n                        eventManager.freeze();\n                        for (i in idMap) {\n                            eventManager.removeEventDefsById(i); // persist=true\n                        }\n                        eventManager.thaw();\n                    }\n                };\n                // legacyQuery operates on legacy event instance objects\n                Calendar.prototype.clientEvents = function (legacyQuery) {\n                    var legacyEventInstances = [];\n                    this.eventManager.getEventInstances().forEach(function (eventInstance) {\n                        legacyEventInstances.push(eventInstance.toLegacy());\n                    });\n                    return filterLegacyEventInstances(legacyEventInstances, legacyQuery);\n                };\n                Calendar.prototype.updateEvents = function (eventPropsArray) {\n                    this.eventManager.freeze();\n                    for (var i = 0; i < eventPropsArray.length; i++) {\n                        this.updateEvent(eventPropsArray[i]);\n                    }\n                    this.eventManager.thaw();\n                };\n                Calendar.prototype.updateEvent = function (eventProps) {\n                    var eventDef = this.eventManager.getEventDefByUid(eventProps._id);\n                    var eventInstance;\n                    var eventDefMutation;\n                    if (eventDef instanceof SingleEventDef_1.default) {\n                        eventInstance = eventDef.buildInstance();\n                        eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props\n                        null // largeUnit -- who uses it?\n                        );\n                        this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release\n                    }\n                };\n                // Public Event Sources API\n                // ------------------------------------------------------------------------------------\n                Calendar.prototype.getEventSources = function () {\n                    return this.eventManager.otherSources.slice(); // clone\n                };\n                Calendar.prototype.getEventSourceById = function (id) {\n                    return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));\n                };\n                Calendar.prototype.addEventSource = function (sourceInput) {\n                    var source = EventSourceParser_1.default.parse(sourceInput, this);\n                    if (source) {\n                        this.eventManager.addSource(source);\n                    }\n                };\n                Calendar.prototype.removeEventSources = function (sourceMultiQuery) {\n                    var eventManager = this.eventManager;\n                    var sources;\n                    var i;\n                    if (sourceMultiQuery == null) {\n                        this.eventManager.removeAllSources();\n                    }\n                    else {\n                        sources = eventManager.multiQuerySources(sourceMultiQuery);\n                        eventManager.freeze();\n                        for (i = 0; i < sources.length; i++) {\n                            eventManager.removeSource(sources[i]);\n                        }\n                        eventManager.thaw();\n                    }\n                };\n                Calendar.prototype.removeEventSource = function (sourceQuery) {\n                    var eventManager = this.eventManager;\n                    var sources = eventManager.querySources(sourceQuery);\n                    var i;\n                    eventManager.freeze();\n                    for (i = 0; i < sources.length; i++) {\n                        eventManager.removeSource(sources[i]);\n                    }\n                    eventManager.thaw();\n                };\n                Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {\n                    var eventManager = this.eventManager;\n                    var sources = eventManager.multiQuerySources(sourceMultiQuery);\n                    var i;\n                    eventManager.freeze();\n                    for (i = 0; i < sources.length; i++) {\n                        eventManager.refetchSource(sources[i]);\n                    }\n                    eventManager.thaw();\n                };\n                // not for internal use. use options module directly instead.\n                Calendar.defaults = options_1.globalDefaults;\n                Calendar.englishDefaults = options_1.englishDefaults;\n                Calendar.rtlDefaults = options_1.rtlDefaults;\n                return Calendar;\n            }());\n            exports.default = Calendar;\n            EmitterMixin_1.default.mixInto(Calendar);\n            ListenerMixin_1.default.mixInto(Calendar);\n            function filterLegacyEventInstances(legacyEventInstances, legacyQuery) {\n                if (legacyQuery == null) {\n                    return legacyEventInstances;\n                }\n                else if ($.isFunction(legacyQuery)) {\n                    return legacyEventInstances.filter(legacyQuery);\n                }\n                else {\n                    legacyQuery += ''; // normalize to string\n                    return legacyEventInstances.filter(function (legacyEventInstance) {\n                        // soft comparison because id not be normalized to string\n                        // tslint:disable-next-line\n                        return legacyEventInstance.id == legacyQuery ||\n                            legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match\n                    });\n                }\n            }\n            /***/ \n        }),\n        /* 221 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var DateProfileGenerator = /*@__PURE__*/ (function () {\n                function DateProfileGenerator(_view) {\n                    this._view = _view;\n                }\n                DateProfileGenerator.prototype.opt = function (name) {\n                    return this._view.opt(name);\n                };\n                DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {\n                    return this._view.trimHiddenDays(unzonedRange);\n                };\n                DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {\n                    return this._view.calendar.msToUtcMoment(ms, forceAllDay);\n                };\n                /* Date Range Computation\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n                DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {\n                    var prevDate = currentDateProfile.date.clone()\n                        .startOf(currentDateProfile.currentRangeUnit)\n                        .subtract(currentDateProfile.dateIncrement);\n                    return this.build(prevDate, -1);\n                };\n                // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n                DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {\n                    var nextDate = currentDateProfile.date.clone()\n                        .startOf(currentDateProfile.currentRangeUnit)\n                        .add(currentDateProfile.dateIncrement);\n                    return this.build(nextDate, 1);\n                };\n                // Builds a structure holding dates/ranges for rendering around the given date.\n                // Optional direction param indicates whether the date is being incremented/decremented\n                // from its previous value. decremented = -1, incremented = 1 (default).\n                DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {\n                    if (forceToValid === void 0) {\n                        forceToValid = false;\n                    }\n                    var isDateAllDay = !date.hasTime();\n                    var validUnzonedRange;\n                    var minTime = null;\n                    var maxTime = null;\n                    var currentInfo;\n                    var isRangeAllDay;\n                    var renderUnzonedRange;\n                    var activeUnzonedRange;\n                    var isValid;\n                    validUnzonedRange = this.buildValidRange();\n                    validUnzonedRange = this.trimHiddenDays(validUnzonedRange);\n                    if (forceToValid) {\n                        date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS\n                        isDateAllDay);\n                    }\n                    currentInfo = this.buildCurrentRangeInfo(date, direction);\n                    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n                    renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);\n                    renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);\n                    activeUnzonedRange = renderUnzonedRange.clone();\n                    if (!this.opt('showNonCurrentDates')) {\n                        activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);\n                    }\n                    minTime = moment.duration(this.opt('minTime'));\n                    maxTime = moment.duration(this.opt('maxTime'));\n                    activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);\n                    activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null\n                    if (activeUnzonedRange) {\n                        date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS\n                        isDateAllDay);\n                    }\n                    // it's invalid if the originally requested date is not contained,\n                    // or if the range is completely outside of the valid range.\n                    isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);\n                    return {\n                        // constraint for where prev/next operations can go and where events can be dragged/resized to.\n                        // an object with optional start and end properties.\n                        validUnzonedRange: validUnzonedRange,\n                        // range the view is formally responsible for.\n                        // for example, a month view might have 1st-31st, excluding padded dates\n                        currentUnzonedRange: currentInfo.unzonedRange,\n                        // name of largest unit being displayed, like \"month\" or \"week\"\n                        currentRangeUnit: currentInfo.unit,\n                        isRangeAllDay: isRangeAllDay,\n                        // dates that display events and accept drag-n-drop\n                        // will be `null` if no dates accept events\n                        activeUnzonedRange: activeUnzonedRange,\n                        // date range with a rendered skeleton\n                        // includes not-active days that need some sort of DOM\n                        renderUnzonedRange: renderUnzonedRange,\n                        // Duration object that denotes the first visible time of any given day\n                        minTime: minTime,\n                        // Duration object that denotes the exclusive visible end time of any given day\n                        maxTime: maxTime,\n                        isValid: isValid,\n                        date: date,\n                        // how far the current date will move for a prev/next operation\n                        dateIncrement: this.buildDateIncrement(currentInfo.duration)\n                        // pass a fallback (might be null) ^\n                    };\n                };\n                // Builds an object with optional start/end properties.\n                // Indicates the minimum/maximum dates to display.\n                // not responsible for trimming hidden days.\n                DateProfileGenerator.prototype.buildValidRange = function () {\n                    return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||\n                        new UnzonedRange_1.default(); // completely open-ended\n                };\n                // Builds a structure with info about the \"current\" range, the range that is\n                // highlighted as being the current month for example.\n                // See build() for a description of `direction`.\n                // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n                // TODO: accept a MS-time instead of a moment `date`?\n                DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n                    var viewSpec = this._view.viewSpec;\n                    var duration = null;\n                    var unit = null;\n                    var unzonedRange = null;\n                    var dayCount;\n                    if (viewSpec.duration) {\n                        duration = viewSpec.duration;\n                        unit = viewSpec.durationUnit;\n                        unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\n                    }\n                    else if ((dayCount = this.opt('dayCount'))) {\n                        unit = 'day';\n                        unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);\n                    }\n                    else if ((unzonedRange = this.buildCustomVisibleRange(date))) {\n                        unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());\n                    }\n                    else {\n                        duration = this.getFallbackDuration();\n                        unit = util_1.computeGreatestUnit(duration);\n                        unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\n                    }\n                    return { duration: duration, unit: unit, unzonedRange: unzonedRange };\n                };\n                DateProfileGenerator.prototype.getFallbackDuration = function () {\n                    return moment.duration({ days: 1 });\n                };\n                // Returns a new activeUnzonedRange to have time values (un-ambiguate)\n                // minTime or maxTime causes the range to expand.\n                DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {\n                    var start = unzonedRange.getStart();\n                    var end = unzonedRange.getEnd();\n                    if (this._view.usesMinMaxTime) {\n                        if (minTime < 0) {\n                            start.time(0).add(minTime);\n                        }\n                        if (maxTime > 24 * 60 * 60 * 1000) {\n                            end.time(maxTime - (24 * 60 * 60 * 1000));\n                        }\n                    }\n                    return new UnzonedRange_1.default(start, end);\n                };\n                // Builds the \"current\" range when it is specified as an explicit duration.\n                // `unit` is the already-computed computeGreatestUnit value of duration.\n                // TODO: accept a MS-time instead of a moment `date`?\n                DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n                    var alignment = this.opt('dateAlignment');\n                    var dateIncrementInput;\n                    var dateIncrementDuration;\n                    var start;\n                    var end;\n                    var res;\n                    // compute what the alignment should be\n                    if (!alignment) {\n                        dateIncrementInput = this.opt('dateIncrement');\n                        if (dateIncrementInput) {\n                            dateIncrementDuration = moment.duration(dateIncrementInput);\n                            // use the smaller of the two units\n                            if (dateIncrementDuration < duration) {\n                                alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\n                            }\n                            else {\n                                alignment = unit;\n                            }\n                        }\n                        else {\n                            alignment = unit;\n                        }\n                    }\n                    // if the view displays a single day or smaller\n                    if (duration.as('days') <= 1) {\n                        if (this._view.isHiddenDay(start)) {\n                            start = this._view.skipHiddenDays(start, direction);\n                            start.startOf('day');\n                        }\n                    }\n                    function computeRes() {\n                        start = date.clone().startOf(alignment);\n                        end = start.clone().add(duration);\n                        res = new UnzonedRange_1.default(start, end);\n                    }\n                    computeRes();\n                    // if range is completely enveloped by hidden days, go past the hidden days\n                    if (!this.trimHiddenDays(res)) {\n                        date = this._view.skipHiddenDays(date, direction);\n                        computeRes();\n                    }\n                    return res;\n                };\n                // Builds the \"current\" range when a dayCount is specified.\n                // TODO: accept a MS-time instead of a moment `date`?\n                DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n                    var customAlignment = this.opt('dateAlignment');\n                    var runningCount = 0;\n                    var start = date.clone();\n                    var end;\n                    if (customAlignment) {\n                        start.startOf(customAlignment);\n                    }\n                    start.startOf('day');\n                    start = this._view.skipHiddenDays(start, direction);\n                    end = start.clone();\n                    do {\n                        end.add(1, 'day');\n                        if (!this._view.isHiddenDay(end)) {\n                            runningCount++;\n                        }\n                    } while (runningCount < dayCount);\n                    return new UnzonedRange_1.default(start, end);\n                };\n                // Builds a normalized range object for the \"visible\" range,\n                // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.\n                // TODO: accept a MS-time instead of a moment `date`?\n                DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n                    var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations\n                    );\n                    if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {\n                        return null;\n                    }\n                    return visibleUnzonedRange;\n                };\n                // Computes the range that will represent the element/cells for *rendering*,\n                // but which may have voided days/times.\n                // not responsible for trimming hidden days.\n                DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\n                    return currentUnzonedRange.clone();\n                };\n                // Compute the duration value that should be added/substracted to the current date\n                // when a prev/next operation happens.\n                DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n                    var dateIncrementInput = this.opt('dateIncrement');\n                    var customAlignment;\n                    if (dateIncrementInput) {\n                        return moment.duration(dateIncrementInput);\n                    }\n                    else if ((customAlignment = this.opt('dateAlignment'))) {\n                        return moment.duration(1, customAlignment);\n                    }\n                    else if (fallback) {\n                        return fallback;\n                    }\n                    else {\n                        return moment.duration({ days: 1 });\n                    }\n                };\n                return DateProfileGenerator;\n            }());\n            exports.default = DateProfileGenerator;\n            /***/ \n        }),\n        /* 222 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var exportHooks = __webpack_require__(16);\n            var util_1 = __webpack_require__(4);\n            var moment_ext_1 = __webpack_require__(10);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var HitDragListener_1 = __webpack_require__(23);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var EventInstanceGroup_1 = __webpack_require__(18);\n            var EventSource_1 = __webpack_require__(6);\n            var Interaction_1 = __webpack_require__(15);\n            var ExternalDropping = (function (_super) {\n                tslib_1.__extends(ExternalDropping, _super);\n                function ExternalDropping() {\n                    var _this = _super !== null && _super.apply(this, arguments) || this;\n                    _this.isDragging = false; // jqui-dragging an external element? boolean\n                    return _this;\n                }\n                /*\n                component impements:\n                  - eventRangesToEventFootprints\n                  - isEventInstanceGroupAllowed\n                  - isExternalInstanceGroupAllowed\n                  - renderDrag\n                  - unrenderDrag\n                */\n                ExternalDropping.prototype.end = function () {\n                    if (this.dragListener) {\n                        this.dragListener.endInteraction();\n                    }\n                };\n                ExternalDropping.prototype.bindToDocument = function () {\n                    this.listenTo($(document), {\n                        dragstart: this.handleDragStart,\n                        sortstart: this.handleDragStart // jqui\n                    });\n                };\n                ExternalDropping.prototype.unbindFromDocument = function () {\n                    this.stopListeningTo($(document));\n                };\n                // Called when a jQuery UI drag is initiated anywhere in the DOM\n                ExternalDropping.prototype.handleDragStart = function (ev, ui) {\n                    var el;\n                    var accept;\n                    if (this.opt('droppable')) {\n                        el = $((ui ? ui.item : null) || ev.target);\n                        // Test that the dragged element passes the dropAccept selector or filter function.\n                        // FYI, the default is \"*\" (matches all)\n                        accept = this.opt('dropAccept');\n                        if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\n                            if (!this.isDragging) {\n                                this.listenToExternalDrag(el, ev, ui);\n                            }\n                        }\n                    }\n                };\n                // Called when a jQuery UI drag starts and it needs to be monitored for dropping\n                ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {\n                    var _this = this;\n                    var component = this.component;\n                    var view = this.view;\n                    var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\n                    var singleEventDef; // a null value signals an unsuccessful drag\n                    // listener that tracks mouse movement over date-associated pixel regions\n                    var dragListener = this.dragListener = new HitDragListener_1.default(component, {\n                        interactionStart: function () {\n                            _this.isDragging = true;\n                        },\n                        hitOver: function (hit) {\n                            var isAllowed = true;\n                            var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid\n                            var mutatedEventInstanceGroup;\n                            if (hitFootprint) {\n                                singleEventDef = _this.computeExternalDrop(hitFootprint, meta);\n                                if (singleEventDef) {\n                                    mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());\n                                    isAllowed = meta.eventProps ? // isEvent?\n                                        component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :\n                                        component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);\n                                }\n                                else {\n                                    isAllowed = false;\n                                }\n                            }\n                            else {\n                                isAllowed = false;\n                            }\n                            if (!isAllowed) {\n                                singleEventDef = null;\n                                util_1.disableCursor();\n                            }\n                            if (singleEventDef) {\n                                component.renderDrag(// called without a seg parameter\n                                component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));\n                            }\n                        },\n                        hitOut: function () {\n                            singleEventDef = null; // signal unsuccessful\n                        },\n                        hitDone: function () {\n                            util_1.enableCursor();\n                            component.unrenderDrag();\n                        },\n                        interactionEnd: function (ev) {\n                            if (singleEventDef) {\n                                view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent\n                                Boolean(meta.stick), // isSticky\n                                el, ev, ui);\n                            }\n                            _this.isDragging = false;\n                            _this.dragListener = null;\n                        }\n                    });\n                    dragListener.startDrag(ev); // start listening immediately\n                };\n                // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\n                // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\n                // Returning a null value signals an invalid drop hit.\n                // DOES NOT consider overlap/constraint.\n                // Assumes both footprints are non-open-ended.\n                ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {\n                    var calendar = this.view.calendar;\n                    var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();\n                    var end;\n                    var eventDef;\n                    if (componentFootprint.isAllDay) {\n                        // if dropped on an all-day span, and element's metadata specified a time, set it\n                        if (meta.startTime) {\n                            start.time(meta.startTime);\n                        }\n                        else {\n                            start.stripTime();\n                        }\n                    }\n                    if (meta.duration) {\n                        end = start.clone().add(meta.duration);\n                    }\n                    start = calendar.applyTimezone(start);\n                    if (end) {\n                        end = calendar.applyTimezone(end);\n                    }\n                    eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {\n                        start: start,\n                        end: end\n                    }), new EventSource_1.default(calendar));\n                    return eventDef;\n                };\n                return ExternalDropping;\n            }(Interaction_1.default));\n            exports.default = ExternalDropping;\n            ListenerMixin_1.default.mixInto(ExternalDropping);\n            /* External-Dragging-Element Data\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\n            // A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\n            exportHooks.dataAttrPrefix = '';\n            // Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\n            // to be used for Event Object creation.\n            // A defined `.eventProps`, even when empty, indicates that an event should be created.\n            function getDraggedElMeta(el) {\n                var prefix = exportHooks.dataAttrPrefix;\n                var eventProps; // properties for creating the event, not related to date/time\n                var startTime; // a Duration\n                var duration;\n                var stick;\n                if (prefix) {\n                    prefix += '-';\n                }\n                eventProps = el.data(prefix + 'event') || null;\n                if (eventProps) {\n                    if (typeof eventProps === 'object') {\n                        eventProps = $.extend({}, eventProps); // make a copy\n                    }\n                    else {\n                        eventProps = {};\n                    }\n                    // pluck special-cased date/time properties\n                    startTime = eventProps.start;\n                    if (startTime == null) {\n                        startTime = eventProps.time;\n                    } // accept 'time' as well\n                    duration = eventProps.duration;\n                    stick = eventProps.stick;\n                    delete eventProps.start;\n                    delete eventProps.time;\n                    delete eventProps.duration;\n                    delete eventProps.stick;\n                }\n                // fallback to standalone attribute values for each of the date/time properties\n                if (startTime == null) {\n                    startTime = el.data(prefix + 'start');\n                }\n                if (startTime == null) {\n                    startTime = el.data(prefix + 'time');\n                } // accept 'time' as well\n                if (duration == null) {\n                    duration = el.data(prefix + 'duration');\n                }\n                if (stick == null) {\n                    stick = el.data(prefix + 'stick');\n                }\n                // massage into correct data types\n                startTime = startTime != null ? moment.duration(startTime) : null;\n                duration = duration != null ? moment.duration(duration) : null;\n                stick = Boolean(stick);\n                return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\n            }\n            /***/ \n        }),\n        /* 223 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var EventDefMutation_1 = __webpack_require__(37);\n            var EventDefDateMutation_1 = __webpack_require__(50);\n            var HitDragListener_1 = __webpack_require__(23);\n            var Interaction_1 = __webpack_require__(15);\n            var EventResizing = (function (_super) {\n                tslib_1.__extends(EventResizing, _super);\n                /*\n                component impements:\n                  - bindSegHandlerToEl\n                  - publiclyTrigger\n                  - diffDates\n                  - eventRangesToEventFootprints\n                  - isEventInstanceGroupAllowed\n                  - getSafeHitFootprint\n                */\n                function EventResizing(component, eventPointing) {\n                    var _this = _super.call(this, component) || this;\n                    _this.isResizing = false;\n                    _this.eventPointing = eventPointing;\n                    return _this;\n                }\n                EventResizing.prototype.end = function () {\n                    if (this.dragListener) {\n                        this.dragListener.endInteraction();\n                    }\n                };\n                EventResizing.prototype.bindToEl = function (el) {\n                    var component = this.component;\n                    component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));\n                    component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\n                };\n                EventResizing.prototype.handleMouseDown = function (seg, ev) {\n                    if (this.component.canStartResize(seg, ev)) {\n                        this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\n                            .startInteraction(ev, { distance: 5 });\n                    }\n                };\n                EventResizing.prototype.handleTouchStart = function (seg, ev) {\n                    if (this.component.canStartResize(seg, ev)) {\n                        this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\n                            .startInteraction(ev);\n                    }\n                };\n                // Creates a listener that tracks the user as they resize an event segment.\n                // Generic enough to work with any type of Grid.\n                EventResizing.prototype.buildDragListener = function (seg, isStart) {\n                    var _this = this;\n                    var component = this.component;\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var eventManager = calendar.eventManager;\n                    var el = seg.el;\n                    var eventDef = seg.footprint.eventDef;\n                    var eventInstance = seg.footprint.eventInstance;\n                    var isDragging;\n                    var resizeMutation; // zoned event date properties. falsy if invalid resize\n                    // Tracks mouse movement over the *grid's* coordinate map\n                    var dragListener = this.dragListener = new HitDragListener_1.default(component, {\n                        scroll: this.opt('dragScroll'),\n                        subjectEl: el,\n                        interactionStart: function () {\n                            isDragging = false;\n                        },\n                        dragStart: function (ev) {\n                            isDragging = true;\n                            // ensure a mouseout on the manipulated event has been reported\n                            _this.eventPointing.handleMouseout(seg, ev);\n                            _this.segResizeStart(seg, ev);\n                        },\n                        hitOver: function (hit, isOrig, origHit) {\n                            var isAllowed = true;\n                            var origHitFootprint = component.getSafeHitFootprint(origHit);\n                            var hitFootprint = component.getSafeHitFootprint(hit);\n                            var mutatedEventInstanceGroup;\n                            if (origHitFootprint && hitFootprint) {\n                                resizeMutation = isStart ?\n                                    _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :\n                                    _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);\n                                if (resizeMutation) {\n                                    mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);\n                                    isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\n                                }\n                                else {\n                                    isAllowed = false;\n                                }\n                            }\n                            else {\n                                isAllowed = false;\n                            }\n                            if (!isAllowed) {\n                                resizeMutation = null;\n                                util_1.disableCursor();\n                            }\n                            else if (resizeMutation.isEmpty()) {\n                                // no change. (FYI, event dates might have zones)\n                                resizeMutation = null;\n                            }\n                            if (resizeMutation) {\n                                view.hideEventsWithId(seg.footprint.eventDef.id);\n                                view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);\n                            }\n                        },\n                        hitOut: function () {\n                            resizeMutation = null;\n                        },\n                        hitDone: function () {\n                            view.unrenderEventResize(seg);\n                            view.showEventsWithId(seg.footprint.eventDef.id);\n                            util_1.enableCursor();\n                        },\n                        interactionEnd: function (ev) {\n                            if (isDragging) {\n                                _this.segResizeStop(seg, ev);\n                            }\n                            if (resizeMutation) {\n                                // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\n                                view.reportEventResize(eventInstance, resizeMutation, el, ev);\n                            }\n                            _this.dragListener = null;\n                        }\n                    });\n                    return dragListener;\n                };\n                // Called before event segment resizing starts\n                EventResizing.prototype.segResizeStart = function (seg, ev) {\n                    this.isResizing = true;\n                    this.component.publiclyTrigger('eventResizeStart', {\n                        context: seg.el[0],\n                        args: [\n                            seg.footprint.getEventLegacy(),\n                            ev,\n                            {},\n                            this.view\n                        ]\n                    });\n                };\n                // Called after event segment resizing stops\n                EventResizing.prototype.segResizeStop = function (seg, ev) {\n                    this.isResizing = false;\n                    this.component.publiclyTrigger('eventResizeStop', {\n                        context: seg.el[0],\n                        args: [\n                            seg.footprint.getEventLegacy(),\n                            ev,\n                            {},\n                            this.view\n                        ]\n                    });\n                };\n                // Returns new date-information for an event segment being resized from its start\n                EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\n                    var origRange = origEventFootprint.componentFootprint.unzonedRange;\n                    var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());\n                    var dateMutation;\n                    var eventDefMutation;\n                    if (origRange.getStart().add(startDelta) < origRange.getEnd()) {\n                        dateMutation = new EventDefDateMutation_1.default();\n                        dateMutation.setStartDelta(startDelta);\n                        eventDefMutation = new EventDefMutation_1.default();\n                        eventDefMutation.setDateMutation(dateMutation);\n                        return eventDefMutation;\n                    }\n                    return false;\n                };\n                // Returns new date-information for an event segment being resized from its end\n                EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\n                    var origRange = origEventFootprint.componentFootprint.unzonedRange;\n                    var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());\n                    var dateMutation;\n                    var eventDefMutation;\n                    if (origRange.getEnd().add(endDelta) > origRange.getStart()) {\n                        dateMutation = new EventDefDateMutation_1.default();\n                        dateMutation.setEndDelta(endDelta);\n                        eventDefMutation = new EventDefMutation_1.default();\n                        eventDefMutation.setDateMutation(dateMutation);\n                        return eventDefMutation;\n                    }\n                    return false;\n                };\n                return EventResizing;\n            }(Interaction_1.default));\n            exports.default = EventResizing;\n            /***/ \n        }),\n        /* 224 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var EventDefMutation_1 = __webpack_require__(37);\n            var EventDefDateMutation_1 = __webpack_require__(50);\n            var DragListener_1 = __webpack_require__(54);\n            var HitDragListener_1 = __webpack_require__(23);\n            var MouseFollower_1 = __webpack_require__(244);\n            var Interaction_1 = __webpack_require__(15);\n            var EventDragging = (function (_super) {\n                tslib_1.__extends(EventDragging, _super);\n                /*\n                component implements:\n                  - bindSegHandlerToEl\n                  - publiclyTrigger\n                  - diffDates\n                  - eventRangesToEventFootprints\n                  - isEventInstanceGroupAllowed\n                */\n                function EventDragging(component, eventPointing) {\n                    var _this = _super.call(this, component) || this;\n                    _this.isDragging = false;\n                    _this.eventPointing = eventPointing;\n                    return _this;\n                }\n                EventDragging.prototype.end = function () {\n                    if (this.dragListener) {\n                        this.dragListener.endInteraction();\n                    }\n                };\n                EventDragging.prototype.getSelectionDelay = function () {\n                    var delay = this.opt('eventLongPressDelay');\n                    if (delay == null) {\n                        delay = this.opt('longPressDelay'); // fallback\n                    }\n                    return delay;\n                };\n                EventDragging.prototype.bindToEl = function (el) {\n                    var component = this.component;\n                    component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));\n                    component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\n                };\n                EventDragging.prototype.handleMousedown = function (seg, ev) {\n                    if (!this.component.shouldIgnoreMouse() &&\n                        this.component.canStartDrag(seg, ev)) {\n                        this.buildDragListener(seg).startInteraction(ev, { distance: 5 });\n                    }\n                };\n                EventDragging.prototype.handleTouchStart = function (seg, ev) {\n                    var component = this.component;\n                    var settings = {\n                        delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?\n                            0 : this.getSelectionDelay()\n                    };\n                    if (component.canStartDrag(seg, ev)) {\n                        this.buildDragListener(seg).startInteraction(ev, settings);\n                    }\n                    else if (component.canStartSelection(seg, ev)) {\n                        this.buildSelectListener(seg).startInteraction(ev, settings);\n                    }\n                };\n                // seg isn't draggable, but let's use a generic DragListener\n                // simply for the delay, so it can be selected.\n                // Has side effect of setting/unsetting `dragListener`\n                EventDragging.prototype.buildSelectListener = function (seg) {\n                    var _this = this;\n                    var view = this.view;\n                    var eventDef = seg.footprint.eventDef;\n                    var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\n                    if (this.dragListener) {\n                        return this.dragListener;\n                    }\n                    var dragListener = this.dragListener = new DragListener_1.default({\n                        dragStart: function (ev) {\n                            if (dragListener.isTouch &&\n                                !view.isEventDefSelected(eventDef) &&\n                                eventInstance) {\n                                // if not previously selected, will fire after a delay. then, select the event\n                                view.selectEventInstance(eventInstance);\n                            }\n                        },\n                        interactionEnd: function (ev) {\n                            _this.dragListener = null;\n                        }\n                    });\n                    return dragListener;\n                };\n                // Builds a listener that will track user-dragging on an event segment.\n                // Generic enough to work with any type of Grid.\n                // Has side effect of setting/unsetting `dragListener`\n                EventDragging.prototype.buildDragListener = function (seg) {\n                    var _this = this;\n                    var component = this.component;\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var eventManager = calendar.eventManager;\n                    var el = seg.el;\n                    var eventDef = seg.footprint.eventDef;\n                    var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\n                    var isDragging;\n                    var mouseFollower; // A clone of the original element that will move with the mouse\n                    var eventDefMutation;\n                    if (this.dragListener) {\n                        return this.dragListener;\n                    }\n                    // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\n                    // of the view.\n                    var dragListener = this.dragListener = new HitDragListener_1.default(view, {\n                        scroll: this.opt('dragScroll'),\n                        subjectEl: el,\n                        subjectCenter: true,\n                        interactionStart: function (ev) {\n                            seg.component = component; // for renderDrag\n                            isDragging = false;\n                            mouseFollower = new MouseFollower_1.default(seg.el, {\n                                additionalClass: 'fc-dragging',\n                                parentEl: view.el,\n                                opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),\n                                revertDuration: _this.opt('dragRevertDuration'),\n                                zIndex: 2 // one above the .fc-view\n                            });\n                            mouseFollower.hide(); // don't show until we know this is a real drag\n                            mouseFollower.start(ev);\n                        },\n                        dragStart: function (ev) {\n                            if (dragListener.isTouch &&\n                                !view.isEventDefSelected(eventDef) &&\n                                eventInstance) {\n                                // if not previously selected, will fire after a delay. then, select the event\n                                view.selectEventInstance(eventInstance);\n                            }\n                            isDragging = true;\n                            // ensure a mouseout on the manipulated event has been reported\n                            _this.eventPointing.handleMouseout(seg, ev);\n                            _this.segDragStart(seg, ev);\n                            view.hideEventsWithId(seg.footprint.eventDef.id);\n                        },\n                        hitOver: function (hit, isOrig, origHit) {\n                            var isAllowed = true;\n                            var origFootprint;\n                            var footprint;\n                            var mutatedEventInstanceGroup;\n                            // starting hit could be forced (DayGrid.limit)\n                            if (seg.hit) {\n                                origHit = seg.hit;\n                            }\n                            // hit might not belong to this grid, so query origin grid\n                            origFootprint = origHit.component.getSafeHitFootprint(origHit);\n                            footprint = hit.component.getSafeHitFootprint(hit);\n                            if (origFootprint && footprint) {\n                                eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);\n                                if (eventDefMutation) {\n                                    mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);\n                                    isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\n                                }\n                                else {\n                                    isAllowed = false;\n                                }\n                            }\n                            else {\n                                isAllowed = false;\n                            }\n                            if (!isAllowed) {\n                                eventDefMutation = null;\n                                util_1.disableCursor();\n                            }\n                            // if a valid drop location, have the subclass render a visual indication\n                            if (eventDefMutation &&\n                                view.renderDrag(// truthy if rendered something\n                                component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {\n                                mouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\n                            }\n                            else {\n                                mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\n                            }\n                            if (isOrig) {\n                                // needs to have moved hits to be a valid drop\n                                eventDefMutation = null;\n                            }\n                        },\n                        hitOut: function () {\n                            view.unrenderDrag(seg); // unrender whatever was done in renderDrag\n                            mouseFollower.show(); // show in case we are moving out of all hits\n                            eventDefMutation = null;\n                        },\n                        hitDone: function () {\n                            util_1.enableCursor();\n                        },\n                        interactionEnd: function (ev) {\n                            delete seg.component; // prevent side effects\n                            // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\n                            mouseFollower.stop(!eventDefMutation, function () {\n                                if (isDragging) {\n                                    view.unrenderDrag(seg);\n                                    _this.segDragStop(seg, ev);\n                                }\n                                view.showEventsWithId(seg.footprint.eventDef.id);\n                                if (eventDefMutation) {\n                                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\n                                    view.reportEventDrop(eventInstance, eventDefMutation, el, ev);\n                                }\n                            });\n                            _this.dragListener = null;\n                        }\n                    });\n                    return dragListener;\n                };\n                // Called before event segment dragging starts\n                EventDragging.prototype.segDragStart = function (seg, ev) {\n                    this.isDragging = true;\n                    this.component.publiclyTrigger('eventDragStart', {\n                        context: seg.el[0],\n                        args: [\n                            seg.footprint.getEventLegacy(),\n                            ev,\n                            {},\n                            this.view\n                        ]\n                    });\n                };\n                // Called after event segment dragging stops\n                EventDragging.prototype.segDragStop = function (seg, ev) {\n                    this.isDragging = false;\n                    this.component.publiclyTrigger('eventDragStop', {\n                        context: seg.el[0],\n                        args: [\n                            seg.footprint.getEventLegacy(),\n                            ev,\n                            {},\n                            this.view\n                        ]\n                    });\n                };\n                // DOES NOT consider overlap/constraint\n                EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {\n                    var eventDefMutation = new EventDefMutation_1.default();\n                    eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));\n                    return eventDefMutation;\n                };\n                EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {\n                    var date0 = startFootprint.unzonedRange.getStart();\n                    var date1 = endFootprint.unzonedRange.getStart();\n                    var clearEnd = false;\n                    var forceTimed = false;\n                    var forceAllDay = false;\n                    var dateDelta;\n                    var dateMutation;\n                    if (startFootprint.isAllDay !== endFootprint.isAllDay) {\n                        clearEnd = true;\n                        if (endFootprint.isAllDay) {\n                            forceAllDay = true;\n                            date0.stripTime();\n                        }\n                        else {\n                            forceTimed = true;\n                        }\n                    }\n                    dateDelta = this.component.diffDates(date1, date0);\n                    dateMutation = new EventDefDateMutation_1.default();\n                    dateMutation.clearEnd = clearEnd;\n                    dateMutation.forceTimed = forceTimed;\n                    dateMutation.forceAllDay = forceAllDay;\n                    dateMutation.setDateDelta(dateDelta);\n                    return dateMutation;\n                };\n                return EventDragging;\n            }(Interaction_1.default));\n            exports.default = EventDragging;\n            /***/ \n        }),\n        /* 225 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var HitDragListener_1 = __webpack_require__(23);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var Interaction_1 = __webpack_require__(15);\n            var DateSelecting = (function (_super) {\n                tslib_1.__extends(DateSelecting, _super);\n                /*\n                component must implement:\n                  - bindDateHandlerToEl\n                  - getSafeHitFootprint\n                  - renderHighlight\n                  - unrenderHighlight\n                */\n                function DateSelecting(component) {\n                    var _this = _super.call(this, component) || this;\n                    _this.dragListener = _this.buildDragListener();\n                    return _this;\n                }\n                DateSelecting.prototype.end = function () {\n                    this.dragListener.endInteraction();\n                };\n                DateSelecting.prototype.getDelay = function () {\n                    var delay = this.opt('selectLongPressDelay');\n                    if (delay == null) {\n                        delay = this.opt('longPressDelay'); // fallback\n                    }\n                    return delay;\n                };\n                DateSelecting.prototype.bindToEl = function (el) {\n                    var _this = this;\n                    var component = this.component;\n                    var dragListener = this.dragListener;\n                    component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\n                        if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {\n                            dragListener.startInteraction(ev, {\n                                distance: _this.opt('selectMinDistance')\n                            });\n                        }\n                    });\n                    component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\n                        if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {\n                            dragListener.startInteraction(ev, {\n                                delay: _this.getDelay()\n                            });\n                        }\n                    });\n                    util_1.preventSelection(el);\n                };\n                // Creates a listener that tracks the user's drag across day elements, for day selecting.\n                DateSelecting.prototype.buildDragListener = function () {\n                    var _this = this;\n                    var component = this.component;\n                    var selectionFootprint; // null if invalid selection\n                    var dragListener = new HitDragListener_1.default(component, {\n                        scroll: this.opt('dragScroll'),\n                        interactionStart: function () {\n                            selectionFootprint = null;\n                        },\n                        dragStart: function (ev) {\n                            _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one\n                        },\n                        hitOver: function (hit, isOrig, origHit) {\n                            var origHitFootprint;\n                            var hitFootprint;\n                            if (origHit) {\n                                origHitFootprint = component.getSafeHitFootprint(origHit);\n                                hitFootprint = component.getSafeHitFootprint(hit);\n                                if (origHitFootprint && hitFootprint) {\n                                    selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);\n                                }\n                                else {\n                                    selectionFootprint = null;\n                                }\n                                if (selectionFootprint) {\n                                    component.renderSelectionFootprint(selectionFootprint);\n                                }\n                                else if (selectionFootprint === false) {\n                                    util_1.disableCursor();\n                                }\n                            }\n                        },\n                        hitOut: function () {\n                            selectionFootprint = null;\n                            component.unrenderSelection();\n                        },\n                        hitDone: function () {\n                            util_1.enableCursor();\n                        },\n                        interactionEnd: function (ev, isCancelled) {\n                            if (!isCancelled && selectionFootprint) {\n                                // the selection will already have been rendered. just report it\n                                _this.view.reportSelection(selectionFootprint, ev);\n                            }\n                        }\n                    });\n                    return dragListener;\n                };\n                // Given the first and last date-spans of a selection, returns another date-span object.\n                // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().\n                // Will return false if the selection is invalid and this should be indicated to the user.\n                // Will return null/undefined if a selection invalid but no error should be reported.\n                DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {\n                    var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);\n                    if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {\n                        return false;\n                    }\n                    return wholeFootprint;\n                };\n                // Given two spans, must return the combination of the two.\n                // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\n                // Assumes both footprints are non-open-ended.\n                DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {\n                    var ms = [\n                        footprint0.unzonedRange.startMs,\n                        footprint0.unzonedRange.endMs,\n                        footprint1.unzonedRange.startMs,\n                        footprint1.unzonedRange.endMs\n                    ];\n                    ms.sort(util_1.compareNumbers);\n                    return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);\n                };\n                DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\n                    return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&\n                        this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);\n                };\n                return DateSelecting;\n            }(Interaction_1.default));\n            exports.default = DateSelecting;\n            /***/ \n        }),\n        /* 226 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var moment = __webpack_require__(0);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Scroller_1 = __webpack_require__(39);\n            var View_1 = __webpack_require__(41);\n            var TimeGrid_1 = __webpack_require__(227);\n            var DayGrid_1 = __webpack_require__(61);\n            var AGENDA_ALL_DAY_EVENT_LIMIT = 5;\n            var agendaTimeGridMethods;\n            var agendaDayGridMethods;\n            /* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n            // Responsible for managing width/height.\n            var AgendaView = (function (_super) {\n                tslib_1.__extends(AgendaView, _super);\n                function AgendaView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering\n                    _this.timeGrid = _this.instantiateTimeGrid();\n                    _this.addChild(_this.timeGrid);\n                    if (_this.opt('allDaySlot')) {\n                        _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view\n                        _this.addChild(_this.dayGrid);\n                    }\n                    _this.scroller = new Scroller_1.default({\n                        overflowX: 'hidden',\n                        overflowY: 'auto'\n                    });\n                    return _this;\n                }\n                // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\n                AgendaView.prototype.instantiateTimeGrid = function () {\n                    var timeGrid = new this.timeGridClass(this);\n                    util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);\n                    return timeGrid;\n                };\n                // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\n                AgendaView.prototype.instantiateDayGrid = function () {\n                    var dayGrid = new this.dayGridClass(this);\n                    util_1.copyOwnProps(agendaDayGridMethods, dayGrid);\n                    return dayGrid;\n                };\n                /* Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                AgendaView.prototype.renderSkeleton = function () {\n                    var timeGridWrapEl;\n                    var timeGridEl;\n                    this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\n                    this.scroller.render();\n                    timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\n                    timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\n                    this.el.find('.fc-body > tr > td').append(timeGridWrapEl);\n                    this.timeGrid.headContainerEl = this.el.find('.fc-head-container');\n                    this.timeGrid.setElement(timeGridEl);\n                    if (this.dayGrid) {\n                        this.dayGrid.setElement(this.el.find('.fc-day-grid'));\n                        // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n                        this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\n                    }\n                };\n                AgendaView.prototype.unrenderSkeleton = function () {\n                    this.timeGrid.removeElement();\n                    if (this.dayGrid) {\n                        this.dayGrid.removeElement();\n                    }\n                    this.scroller.destroy();\n                };\n                // Builds the HTML skeleton for the view.\n                // The day-grid and time-grid components will render inside containers defined by this HTML.\n                AgendaView.prototype.renderSkeletonHtml = function () {\n                    var theme = this.calendar.theme;\n                    return '' +\n                        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        (this.opt('columnHeader') ?\n                            '<thead class=\"fc-head\">' +\n                                '<tr>' +\n                                '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\n                                '</tr>' +\n                                '</thead>' :\n                            '') +\n                        '<tbody class=\"fc-body\">' +\n                        '<tr>' +\n                        '<td class=\"' + theme.getClass('widgetContent') + '\">' +\n                        (this.dayGrid ?\n                            '<div class=\"fc-day-grid\"/>' +\n                                '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\"/>' :\n                            '') +\n                        '</td>' +\n                        '</tr>' +\n                        '</tbody>' +\n                        '</table>';\n                };\n                // Generates an HTML attribute string for setting the width of the axis, if it is known\n                AgendaView.prototype.axisStyleAttr = function () {\n                    if (this.axisWidth != null) {\n                        return 'style=\"width:' + this.axisWidth + 'px\"';\n                    }\n                    return '';\n                };\n                /* Now Indicator\n                ------------------------------------------------------------------------------------------------------------------*/\n                AgendaView.prototype.getNowIndicatorUnit = function () {\n                    return this.timeGrid.getNowIndicatorUnit();\n                };\n                /* Dimensions\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Adjusts the vertical dimensions of the view to the specified values\n                AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    var eventLimit;\n                    var scrollerHeight;\n                    var scrollbarWidths;\n                    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    // make all axis cells line up, and record the width so newly created axis cells will have it\n                    this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));\n                    // hack to give the view some height prior to timeGrid's columns being rendered\n                    // TODO: separate setting height from scroller VS timeGrid.\n                    if (!this.timeGrid.colEls) {\n                        if (!isAuto) {\n                            scrollerHeight = this.computeScrollerHeight(totalHeight);\n                            this.scroller.setHeight(scrollerHeight);\n                        }\n                        return;\n                    }\n                    // set of fake row elements that must compensate when scroller has scrollbars\n                    var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');\n                    // reset all dimensions back to the original state\n                    this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\n                    this.scroller.clear(); // sets height to 'auto' and clears overflow\n                    util_1.uncompensateScroll(noScrollRowEls);\n                    // limit number of events in the all-day area\n                    if (this.dayGrid) {\n                        this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n                        eventLimit = this.opt('eventLimit');\n                        if (eventLimit && typeof eventLimit !== 'number') {\n                            eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n                        }\n                        if (eventLimit) {\n                            this.dayGrid.limitRows(eventLimit);\n                        }\n                    }\n                    if (!isAuto) {\n                        scrollerHeight = this.computeScrollerHeight(totalHeight);\n                        this.scroller.setHeight(scrollerHeight);\n                        scrollbarWidths = this.scroller.getScrollbarWidths();\n                        if (scrollbarWidths.left || scrollbarWidths.right) {\n                            // make the all-day and header rows lines up\n                            util_1.compensateScroll(noScrollRowEls, scrollbarWidths);\n                            // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n                            // and reapply the desired height to the scroller.\n                            scrollerHeight = this.computeScrollerHeight(totalHeight);\n                            this.scroller.setHeight(scrollerHeight);\n                        }\n                        // guarantees the same scrollbar widths\n                        this.scroller.lockOverflow(scrollbarWidths);\n                        // if there's any space below the slats, show the horizontal rule.\n                        // this won't cause any new overflow, because lockOverflow already called.\n                        if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n                            this.timeGrid.bottomRuleEl.show();\n                        }\n                    }\n                };\n                // given a desired total height of the view, returns what the height of the scroller should be\n                AgendaView.prototype.computeScrollerHeight = function (totalHeight) {\n                    return totalHeight -\n                        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n                };\n                /* Scroll\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Computes the initial pre-configured scroll state prior to allowing the user to change it\n                AgendaView.prototype.computeInitialDateScroll = function () {\n                    var scrollTime = moment.duration(this.opt('scrollTime'));\n                    var top = this.timeGrid.computeTimeTop(scrollTime);\n                    // zoom can give weird floating-point values. rather scroll a little bit further\n                    top = Math.ceil(top);\n                    if (top) {\n                        top++; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    return { top: top };\n                };\n                AgendaView.prototype.queryDateScroll = function () {\n                    return { top: this.scroller.getScrollTop() };\n                };\n                AgendaView.prototype.applyDateScroll = function (scroll) {\n                    if (scroll.top !== undefined) {\n                        this.scroller.setScrollTop(scroll.top);\n                    }\n                };\n                /* Hit Areas\n                ------------------------------------------------------------------------------------------------------------------*/\n                // forward all hit-related method calls to the grids (dayGrid might not be defined)\n                AgendaView.prototype.getHitFootprint = function (hit) {\n                    // TODO: hit.component is set as a hack to identify where the hit came from\n                    return hit.component.getHitFootprint(hit);\n                };\n                AgendaView.prototype.getHitEl = function (hit) {\n                    // TODO: hit.component is set as a hack to identify where the hit came from\n                    return hit.component.getHitEl(hit);\n                };\n                /* Event Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                AgendaView.prototype.executeEventRender = function (eventsPayload) {\n                    var dayEventsPayload = {};\n                    var timedEventsPayload = {};\n                    var id;\n                    var eventInstanceGroup;\n                    // separate the events into all-day and timed\n                    for (id in eventsPayload) {\n                        eventInstanceGroup = eventsPayload[id];\n                        if (eventInstanceGroup.getEventDef().isAllDay()) {\n                            dayEventsPayload[id] = eventInstanceGroup;\n                        }\n                        else {\n                            timedEventsPayload[id] = eventInstanceGroup;\n                        }\n                    }\n                    this.timeGrid.executeEventRender(timedEventsPayload);\n                    if (this.dayGrid) {\n                        this.dayGrid.executeEventRender(dayEventsPayload);\n                    }\n                };\n                /* Dragging/Resizing Routing\n                ------------------------------------------------------------------------------------------------------------------*/\n                // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n                AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    var groups = groupEventFootprintsByAllDay(eventFootprints);\n                    var renderedHelper = false;\n                    renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);\n                    if (this.dayGrid) {\n                        renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;\n                    }\n                    return renderedHelper;\n                };\n                AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    var groups = groupEventFootprintsByAllDay(eventFootprints);\n                    this.timeGrid.renderEventResize(groups.timed, seg, isTouch);\n                    if (this.dayGrid) {\n                        this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);\n                    }\n                };\n                /* Selection\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of a selection\n                AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {\n                    if (!componentFootprint.isAllDay) {\n                        this.timeGrid.renderSelectionFootprint(componentFootprint);\n                    }\n                    else if (this.dayGrid) {\n                        this.dayGrid.renderSelectionFootprint(componentFootprint);\n                    }\n                };\n                return AgendaView;\n            }(View_1.default));\n            exports.default = AgendaView;\n            AgendaView.prototype.timeGridClass = TimeGrid_1.default;\n            AgendaView.prototype.dayGridClass = DayGrid_1.default;\n            // Will customize the rendering behavior of the AgendaView's timeGrid\n            agendaTimeGridMethods = {\n                // Generates the HTML that will go before the day-of week header cells\n                renderHeadIntroHtml: function () {\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);\n                    var weekText;\n                    if (this.opt('weekNumbers')) {\n                        weekText = weekStart.format(this.opt('smallWeekFormat'));\n                        return '' +\n                            '<th class=\"fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '>' +\n                            view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\n                            { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML\n                            ) +\n                            '</th>';\n                    }\n                    else {\n                        return '<th class=\"fc-axis ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '></th>';\n                    }\n                },\n                // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n                renderBgIntroHtml: function () {\n                    var view = this.view;\n                    return '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '></td>';\n                },\n                // Generates the HTML that goes before all other types of cells.\n                // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n                renderIntroHtml: function () {\n                    var view = this.view;\n                    return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n                }\n            };\n            // Will customize the rendering behavior of the AgendaView's dayGrid\n            agendaDayGridMethods = {\n                // Generates the HTML that goes before the all-day cells\n                renderBgIntroHtml: function () {\n                    var view = this.view;\n                    return '' +\n                        '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\n                        '<span>' + // needed for matchCellWidths\n                        view.getAllDayHtml() +\n                        '</span>' +\n                        '</td>';\n                },\n                // Generates the HTML that goes before all other types of cells.\n                // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n                renderIntroHtml: function () {\n                    var view = this.view;\n                    return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n                }\n            };\n            function groupEventFootprintsByAllDay(eventFootprints) {\n                var allDay = [];\n                var timed = [];\n                var i;\n                for (i = 0; i < eventFootprints.length; i++) {\n                    if (eventFootprints[i].componentFootprint.isAllDay) {\n                        allDay.push(eventFootprints[i]);\n                    }\n                    else {\n                        timed.push(eventFootprints[i]);\n                    }\n                }\n                return { allDay: allDay, timed: timed };\n            }\n            /***/ \n        }),\n        /* 227 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var InteractiveDateComponent_1 = __webpack_require__(40);\n            var BusinessHourRenderer_1 = __webpack_require__(56);\n            var StandardInteractionsMixin_1 = __webpack_require__(60);\n            var DayTableMixin_1 = __webpack_require__(55);\n            var CoordCache_1 = __webpack_require__(53);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var ComponentFootprint_1 = __webpack_require__(12);\n            var TimeGridEventRenderer_1 = __webpack_require__(246);\n            var TimeGridHelperRenderer_1 = __webpack_require__(247);\n            var TimeGridFillRenderer_1 = __webpack_require__(248);\n            /* A component that renders one or more columns of vertical time slots\n            ----------------------------------------------------------------------------------------------------------------------*/\n            // We mixin DayTable, even though there is only a single row of days\n            // potential nice values for the slot-duration and interval-duration\n            // from largest to smallest\n            var AGENDA_STOCK_SUB_DURATIONS = [\n                { hours: 1 },\n                { minutes: 30 },\n                { minutes: 15 },\n                { seconds: 30 },\n                { seconds: 15 }\n            ];\n            var TimeGrid = (function (_super) {\n                tslib_1.__extends(TimeGrid, _super);\n                function TimeGrid(view) {\n                    var _this = _super.call(this, view) || this;\n                    _this.processOptions();\n                    return _this;\n                }\n                // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n                TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\n                    var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);\n                    var i;\n                    for (i = 0; i < segs.length; i++) {\n                        if (this.isRTL) {\n                            segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\n                        }\n                        else {\n                            segs[i].col = segs[i].dayIndex;\n                        }\n                    }\n                    return segs;\n                };\n                /* Date Handling\n                ------------------------------------------------------------------------------------------------------------------*/\n                TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {\n                    var segs = [];\n                    var segRange;\n                    var dayIndex;\n                    for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\n                        segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);\n                        if (segRange) {\n                            segs.push({\n                                startMs: segRange.startMs,\n                                endMs: segRange.endMs,\n                                isStart: segRange.isStart,\n                                isEnd: segRange.isEnd,\n                                dayIndex: dayIndex\n                            });\n                        }\n                    }\n                    return segs;\n                };\n                /* Options\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Parses various options into properties of this object\n                TimeGrid.prototype.processOptions = function () {\n                    var slotDuration = this.opt('slotDuration');\n                    var snapDuration = this.opt('snapDuration');\n                    var input;\n                    slotDuration = moment.duration(slotDuration);\n                    snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\n                    this.slotDuration = slotDuration;\n                    this.snapDuration = snapDuration;\n                    this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\n                    // might be an array value (for TimelineView).\n                    // if so, getting the most granular entry (the last one probably).\n                    input = this.opt('slotLabelFormat');\n                    if ($.isArray(input)) {\n                        input = input[input.length - 1];\n                    }\n                    this.labelFormat = input ||\n                        this.opt('smallTimeFormat'); // the computed default\n                    input = this.opt('slotLabelInterval');\n                    this.labelInterval = input ?\n                        moment.duration(input) :\n                        this.computeLabelInterval(slotDuration);\n                };\n                // Computes an automatic value for slotLabelInterval\n                TimeGrid.prototype.computeLabelInterval = function (slotDuration) {\n                    var i;\n                    var labelInterval;\n                    var slotsPerLabel;\n                    // find the smallest stock label interval that results in more than one slots-per-label\n                    for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n                        labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\n                        slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);\n                        if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {\n                            return labelInterval;\n                        }\n                    }\n                    return moment.duration(slotDuration); // fall back. clone\n                };\n                /* Date Rendering\n                ------------------------------------------------------------------------------------------------------------------*/\n                TimeGrid.prototype.renderDates = function (dateProfile) {\n                    this.dateProfile = dateProfile;\n                    this.updateDayTable();\n                    this.renderSlats();\n                    this.renderColumns();\n                };\n                TimeGrid.prototype.unrenderDates = function () {\n                    // this.unrenderSlats(); // don't need this because repeated .html() calls clear\n                    this.unrenderColumns();\n                };\n                TimeGrid.prototype.renderSkeleton = function () {\n                    var theme = this.view.calendar.theme;\n                    this.el.html('<div class=\"fc-bg\"></div>' +\n                        '<div class=\"fc-slats\"></div>' +\n                        '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" style=\"display:none\" />');\n                    this.bottomRuleEl = this.el.find('hr');\n                };\n                TimeGrid.prototype.renderSlats = function () {\n                    var theme = this.view.calendar.theme;\n                    this.slatContainerEl = this.el.find('> .fc-slats')\n                        .html(// avoids needing ::unrenderSlats()\n                    '<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        this.renderSlatRowHtml() +\n                        '</table>');\n                    this.slatEls = this.slatContainerEl.find('tr');\n                    this.slatCoordCache = new CoordCache_1.default({\n                        els: this.slatEls,\n                        isVertical: true\n                    });\n                };\n                // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n                TimeGrid.prototype.renderSlatRowHtml = function () {\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var theme = calendar.theme;\n                    var isRTL = this.isRTL;\n                    var dateProfile = this.dateProfile;\n                    var html = '';\n                    var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations\n                    var slotIterator = moment.duration(0);\n                    var slotDate; // will be on the view's first day, but we only care about its time\n                    var isLabeled;\n                    var axisHtml;\n                    // Calculate the time for each slot\n                    while (slotTime < dateProfile.maxTime) {\n                        slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);\n                        isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));\n                        axisHtml =\n                            '<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\n                                (isLabeled ?\n                                    '<span>' + // for matchCellWidths\n                                        util_1.htmlEscape(slotDate.format(this.labelFormat)) +\n                                        '</span>' :\n                                    '') +\n                                '</td>';\n                        html +=\n                            '<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\n                                (isLabeled ? '' : ' class=\"fc-minor\"') +\n                                '>' +\n                                (!isRTL ? axisHtml : '') +\n                                '<td class=\"' + theme.getClass('widgetContent') + '\"/>' +\n                                (isRTL ? axisHtml : '') +\n                                '</tr>';\n                        slotTime.add(this.slotDuration);\n                        slotIterator.add(this.slotDuration);\n                    }\n                    return html;\n                };\n                TimeGrid.prototype.renderColumns = function () {\n                    var dateProfile = this.dateProfile;\n                    var theme = this.view.calendar.theme;\n                    this.dayRanges = this.dayDates.map(function (dayDate) {\n                        return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));\n                    });\n                    if (this.headContainerEl) {\n                        this.headContainerEl.html(this.renderHeadHtml());\n                    }\n                    this.el.find('> .fc-bg').html('<table class=\"' + theme.getClass('tableGrid') + '\">' +\n                        this.renderBgTrHtml(0) + // row=0\n                        '</table>');\n                    this.colEls = this.el.find('.fc-day, .fc-disabled-day');\n                    this.colCoordCache = new CoordCache_1.default({\n                        els: this.colEls,\n                        isHorizontal: true\n                    });\n                    this.renderContentSkeleton();\n                };\n                TimeGrid.prototype.unrenderColumns = function () {\n                    this.unrenderContentSkeleton();\n                };\n                /* Content Skeleton\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders the DOM that the view's content will live in\n                TimeGrid.prototype.renderContentSkeleton = function () {\n                    var cellHtml = '';\n                    var i;\n                    var skeletonEl;\n                    for (i = 0; i < this.colCnt; i++) {\n                        cellHtml +=\n                            '<td>' +\n                                '<div class=\"fc-content-col\">' +\n                                '<div class=\"fc-event-container fc-helper-container\"></div>' +\n                                '<div class=\"fc-event-container\"></div>' +\n                                '<div class=\"fc-highlight-container\"></div>' +\n                                '<div class=\"fc-bgevent-container\"></div>' +\n                                '<div class=\"fc-business-container\"></div>' +\n                                '</div>' +\n                                '</td>';\n                    }\n                    skeletonEl = this.contentSkeletonEl = $('<div class=\"fc-content-skeleton\">' +\n                        '<table>' +\n                        '<tr>' + cellHtml + '</tr>' +\n                        '</table>' +\n                        '</div>');\n                    this.colContainerEls = skeletonEl.find('.fc-content-col');\n                    this.helperContainerEls = skeletonEl.find('.fc-helper-container');\n                    this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\n                    this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\n                    this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\n                    this.businessContainerEls = skeletonEl.find('.fc-business-container');\n                    this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\n                    this.el.append(skeletonEl);\n                };\n                TimeGrid.prototype.unrenderContentSkeleton = function () {\n                    if (this.contentSkeletonEl) {\n                        this.contentSkeletonEl.remove();\n                        this.contentSkeletonEl = null;\n                        this.colContainerEls = null;\n                        this.helperContainerEls = null;\n                        this.fgContainerEls = null;\n                        this.bgContainerEls = null;\n                        this.highlightContainerEls = null;\n                        this.businessContainerEls = null;\n                    }\n                };\n                // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n                TimeGrid.prototype.groupSegsByCol = function (segs) {\n                    var segsByCol = [];\n                    var i;\n                    for (i = 0; i < this.colCnt; i++) {\n                        segsByCol.push([]);\n                    }\n                    for (i = 0; i < segs.length; i++) {\n                        segsByCol[segs[i].col].push(segs[i]);\n                    }\n                    return segsByCol;\n                };\n                // Given segments grouped by column, insert the segments' elements into a parallel array of container\n                // elements, each living within a column.\n                TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {\n                    var col;\n                    var segs;\n                    var i;\n                    for (col = 0; col < this.colCnt; col++) {\n                        segs = segsByCol[col];\n                        for (i = 0; i < segs.length; i++) {\n                            containerEls.eq(col).append(segs[i].el);\n                        }\n                    }\n                };\n                /* Now Indicator\n                ------------------------------------------------------------------------------------------------------------------*/\n                TimeGrid.prototype.getNowIndicatorUnit = function () {\n                    return 'minute'; // will refresh on the minute\n                };\n                TimeGrid.prototype.renderNowIndicator = function (date) {\n                    // HACK: if date columns not ready for some reason (scheduler)\n                    if (!this.colContainerEls) {\n                        return;\n                    }\n                    // seg system might be overkill, but it handles scenario where line needs to be rendered\n                    //  more than once because of columns with the same date (resources columns for example)\n                    var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range\n                    false // all-day\n                    ));\n                    var top = this.computeDateTop(date, date);\n                    var nodes = [];\n                    var i;\n                    // render lines within the columns\n                    for (i = 0; i < segs.length; i++) {\n                        nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\n                            .css('top', top)\n                            .appendTo(this.colContainerEls.eq(segs[i].col))[0]);\n                    }\n                    // render an arrow over the axis\n                    if (segs.length > 0) {\n                        nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\n                            .css('top', top)\n                            .appendTo(this.el.find('.fc-content-skeleton'))[0]);\n                    }\n                    this.nowIndicatorEls = $(nodes);\n                };\n                TimeGrid.prototype.unrenderNowIndicator = function () {\n                    if (this.nowIndicatorEls) {\n                        this.nowIndicatorEls.remove();\n                        this.nowIndicatorEls = null;\n                    }\n                };\n                /* Coordinates\n                ------------------------------------------------------------------------------------------------------------------*/\n                TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    this.slatCoordCache.build();\n                    if (isResize) {\n                        this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));\n                    }\n                };\n                TimeGrid.prototype.getTotalSlatHeight = function () {\n                    return this.slatContainerEl.outerHeight();\n                };\n                // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n                // `ms` can be a millisecond UTC time OR a UTC moment.\n                // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n                TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {\n                    return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));\n                };\n                // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n                TimeGrid.prototype.computeTimeTop = function (time) {\n                    var len = this.slatEls.length;\n                    var dateProfile = this.dateProfile;\n                    var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered\n                    var slatIndex;\n                    var slatRemainder;\n                    // compute a floating-point number for how many slats should be progressed through.\n                    // from 0 to number of slats (inclusive)\n                    // constrained because minTime/maxTime might be customized.\n                    slatCoverage = Math.max(0, slatCoverage);\n                    slatCoverage = Math.min(len, slatCoverage);\n                    // an integer index of the furthest whole slat\n                    // from 0 to number slats (*exclusive*, so len-1)\n                    slatIndex = Math.floor(slatCoverage);\n                    slatIndex = Math.min(slatIndex, len - 1);\n                    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n                    // could be 1.0 if slatCoverage is covering *all* the slots\n                    slatRemainder = slatCoverage - slatIndex;\n                    return this.slatCoordCache.getTopPosition(slatIndex) +\n                        this.slatCoordCache.getHeight(slatIndex) * slatRemainder;\n                };\n                // Refreshes the CSS top/bottom coordinates for each segment element.\n                // Works when called after initial render, after a window resize/zoom for example.\n                TimeGrid.prototype.updateSegVerticals = function (segs) {\n                    this.computeSegVerticals(segs);\n                    this.assignSegVerticals(segs);\n                };\n                // For each segment in an array, computes and assigns its top and bottom properties\n                TimeGrid.prototype.computeSegVerticals = function (segs) {\n                    var eventMinHeight = this.opt('agendaEventMinHeight');\n                    var i;\n                    var seg;\n                    var dayDate;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        dayDate = this.dayDates[seg.dayIndex];\n                        seg.top = this.computeDateTop(seg.startMs, dayDate);\n                        seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));\n                    }\n                };\n                // Given segments that already have their top/bottom properties computed, applies those values to\n                // the segments' elements.\n                TimeGrid.prototype.assignSegVerticals = function (segs) {\n                    var i;\n                    var seg;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        seg.el.css(this.generateSegVerticalCss(seg));\n                    }\n                };\n                // Generates an object with CSS properties for the top/bottom coordinates of a segment element\n                TimeGrid.prototype.generateSegVerticalCss = function (seg) {\n                    return {\n                        top: seg.top,\n                        bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n                    };\n                };\n                /* Hit System\n                ------------------------------------------------------------------------------------------------------------------*/\n                TimeGrid.prototype.prepareHits = function () {\n                    this.colCoordCache.build();\n                    this.slatCoordCache.build();\n                };\n                TimeGrid.prototype.releaseHits = function () {\n                    this.colCoordCache.clear();\n                    // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\n                };\n                TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {\n                    var snapsPerSlot = this.snapsPerSlot;\n                    var colCoordCache = this.colCoordCache;\n                    var slatCoordCache = this.slatCoordCache;\n                    if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\n                        var colIndex = colCoordCache.getHorizontalIndex(leftOffset);\n                        var slatIndex = slatCoordCache.getVerticalIndex(topOffset);\n                        if (colIndex != null && slatIndex != null) {\n                            var slatTop = slatCoordCache.getTopOffset(slatIndex);\n                            var slatHeight = slatCoordCache.getHeight(slatIndex);\n                            var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\n                            var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n                            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n                            var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\n                            var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\n                            return {\n                                col: colIndex,\n                                snap: snapIndex,\n                                component: this,\n                                left: colCoordCache.getLeftOffset(colIndex),\n                                right: colCoordCache.getRightOffset(colIndex),\n                                top: snapTop,\n                                bottom: snapBottom\n                            };\n                        }\n                    }\n                };\n                TimeGrid.prototype.getHitFootprint = function (hit) {\n                    var start = this.getCellDate(0, hit.col); // row=0\n                    var time = this.computeSnapTime(hit.snap); // pass in the snap-index\n                    var end;\n                    start.time(time);\n                    end = start.clone().add(this.snapDuration);\n                    return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?\n                    );\n                };\n                // Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\n                TimeGrid.prototype.computeSnapTime = function (snapIndex) {\n                    return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);\n                };\n                TimeGrid.prototype.getHitEl = function (hit) {\n                    return this.colEls.eq(hit.col);\n                };\n                /* Event Drag Visualization\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of an event being dragged over the specified date(s).\n                // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n                TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\n                    var i;\n                    if (seg) {\n                        if (eventFootprints.length) {\n                            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\n                            // signal that a helper has been rendered\n                            return true;\n                        }\n                    }\n                    else {\n                        for (i = 0; i < eventFootprints.length; i++) {\n                            this.renderHighlight(eventFootprints[i].componentFootprint);\n                        }\n                    }\n                };\n                // Unrenders any visual indication of an event being dragged\n                TimeGrid.prototype.unrenderDrag = function () {\n                    this.unrenderHighlight();\n                    this.helperRenderer.unrender();\n                };\n                /* Event Resize Visualization\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of an event being resized\n                TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\n                    this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\n                };\n                // Unrenders any visual indication of an event being resized\n                TimeGrid.prototype.unrenderEventResize = function () {\n                    this.helperRenderer.unrender();\n                };\n                /* Selection\n                ------------------------------------------------------------------------------------------------------------------*/\n                // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n                TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {\n                    if (this.opt('selectHelper')) {\n                        this.helperRenderer.renderComponentFootprint(componentFootprint);\n                    }\n                    else {\n                        this.renderHighlight(componentFootprint);\n                    }\n                };\n                // Unrenders any visual indication of a selection\n                TimeGrid.prototype.unrenderSelection = function () {\n                    this.helperRenderer.unrender();\n                    this.unrenderHighlight();\n                };\n                return TimeGrid;\n            }(InteractiveDateComponent_1.default));\n            exports.default = TimeGrid;\n            TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;\n            TimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\n            TimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;\n            TimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;\n            StandardInteractionsMixin_1.default.mixInto(TimeGrid);\n            DayTableMixin_1.default.mixInto(TimeGrid);\n            /***/ \n        }),\n        /* 228 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var DateProfileGenerator_1 = __webpack_require__(221);\n            var BasicViewDateProfileGenerator = (function (_super) {\n                tslib_1.__extends(BasicViewDateProfileGenerator, _super);\n                function BasicViewDateProfileGenerator() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // Computes the date range that will be rendered.\n                BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\n                    var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange\n                    var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\n                    var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\n                    // year and month views should be aligned with weeks. this is already done for week\n                    if (/^(year|month)$/.test(currentRangeUnit)) {\n                        start.startOf('week');\n                        // make end-of-week if not already\n                        if (end.weekday()) {\n                            end.add(1, 'week').startOf('week'); // exclusively move backwards\n                        }\n                    }\n                    return new UnzonedRange_1.default(start, end);\n                };\n                return BasicViewDateProfileGenerator;\n            }(DateProfileGenerator_1.default));\n            exports.default = BasicViewDateProfileGenerator;\n            /***/ \n        }),\n        /* 229 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var moment = __webpack_require__(0);\n            var util_1 = __webpack_require__(4);\n            var BasicView_1 = __webpack_require__(62);\n            var MonthViewDateProfileGenerator_1 = __webpack_require__(253);\n            /* A month view with day cells running in rows (one-per-week) and columns\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var MonthView = (function (_super) {\n                tslib_1.__extends(MonthView, _super);\n                function MonthView() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // Overrides the default BasicView behavior to have special multi-week auto-height logic\n                MonthView.prototype.setGridHeight = function (height, isAuto) {\n                    // if auto, make the height of each row the height that it would be if there were 6 weeks\n                    if (isAuto) {\n                        height *= this.dayGrid.rowCnt / 6;\n                    }\n                    util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n                };\n                MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {\n                    return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize\n                };\n                return MonthView;\n            }(BasicView_1.default));\n            exports.default = MonthView;\n            MonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator_1.default;\n            /***/ \n        }),\n        /* 230 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var View_1 = __webpack_require__(41);\n            var Scroller_1 = __webpack_require__(39);\n            var ListEventRenderer_1 = __webpack_require__(254);\n            var ListEventPointing_1 = __webpack_require__(255);\n            /*\n            Responsible for the scroller, and forwarding event-related actions into the \"grid\".\n            */\n            var ListView = (function (_super) {\n                tslib_1.__extends(ListView, _super);\n                function ListView(calendar, viewSpec) {\n                    var _this = _super.call(this, calendar, viewSpec) || this;\n                    _this.segSelector = '.fc-list-item'; // which elements accept event actions\n                    _this.scroller = new Scroller_1.default({\n                        overflowX: 'hidden',\n                        overflowY: 'auto'\n                    });\n                    return _this;\n                }\n                ListView.prototype.renderSkeleton = function () {\n                    this.el.addClass('fc-list-view ' +\n                        this.calendar.theme.getClass('listView'));\n                    this.scroller.render();\n                    this.scroller.el.appendTo(this.el);\n                    this.contentEl = this.scroller.scrollEl; // shortcut\n                };\n                ListView.prototype.unrenderSkeleton = function () {\n                    this.scroller.destroy(); // will remove the Grid too\n                };\n                ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\n                    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\n                    this.scroller.clear(); // sets height to 'auto' and clears overflow\n                    if (!isAuto) {\n                        this.scroller.setHeight(this.computeScrollerHeight(totalHeight));\n                    }\n                };\n                ListView.prototype.computeScrollerHeight = function (totalHeight) {\n                    return totalHeight -\n                        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n                };\n                ListView.prototype.renderDates = function (dateProfile) {\n                    var calendar = this.calendar;\n                    var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);\n                    var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);\n                    var dayDates = [];\n                    var dayRanges = [];\n                    while (dayStart < viewEnd) {\n                        dayDates.push(dayStart.clone());\n                        dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));\n                        dayStart.add(1, 'day');\n                    }\n                    this.dayDates = dayDates;\n                    this.dayRanges = dayRanges;\n                    // all real rendering happens in EventRenderer\n                };\n                // slices by day\n                ListView.prototype.componentFootprintToSegs = function (footprint) {\n                    var dayRanges = this.dayRanges;\n                    var dayIndex;\n                    var segRange;\n                    var seg;\n                    var segs = [];\n                    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {\n                        segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);\n                        if (segRange) {\n                            seg = {\n                                startMs: segRange.startMs,\n                                endMs: segRange.endMs,\n                                isStart: segRange.isStart,\n                                isEnd: segRange.isEnd,\n                                dayIndex: dayIndex\n                            };\n                            segs.push(seg);\n                            // detect when footprint won't go fully into the next day,\n                            // and mutate the latest seg to the be the end.\n                            if (!seg.isEnd && !footprint.isAllDay &&\n                                dayIndex + 1 < dayRanges.length &&\n                                footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {\n                                seg.endMs = footprint.unzonedRange.endMs;\n                                seg.isEnd = true;\n                                break;\n                            }\n                        }\n                    }\n                    return segs;\n                };\n                ListView.prototype.renderEmptyMessage = function () {\n                    this.contentEl.html('<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\n                        '<div class=\"fc-list-empty-wrap1\">' +\n                        '<div class=\"fc-list-empty\">' +\n                        util_1.htmlEscape(this.opt('noEventsMessage')) +\n                        '</div>' +\n                        '</div>' +\n                        '</div>');\n                };\n                // render the event segments in the view\n                ListView.prototype.renderSegList = function (allSegs) {\n                    var segsByDay = this.groupSegsByDay(allSegs); // sparse array\n                    var dayIndex;\n                    var daySegs;\n                    var i;\n                    var tableEl = $('<table class=\"fc-list-table ' + this.calendar.theme.getClass('tableList') + '\"><tbody/></table>');\n                    var tbodyEl = tableEl.find('tbody');\n                    for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\n                        daySegs = segsByDay[dayIndex];\n                        if (daySegs) {\n                            // append a day header\n                            tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));\n                            this.eventRenderer.sortEventSegs(daySegs);\n                            for (i = 0; i < daySegs.length; i++) {\n                                tbodyEl.append(daySegs[i].el); // append event row\n                            }\n                        }\n                    }\n                    this.contentEl.empty().append(tableEl);\n                };\n                // Returns a sparse array of arrays, segs grouped by their dayIndex\n                ListView.prototype.groupSegsByDay = function (segs) {\n                    var segsByDay = []; // sparse array\n                    var i;\n                    var seg;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\n                            .push(seg);\n                    }\n                    return segsByDay;\n                };\n                // generates the HTML for the day headers that live amongst the event rows\n                ListView.prototype.dayHeaderHtml = function (dayDate) {\n                    var mainFormat = this.opt('listDayFormat');\n                    var altFormat = this.opt('listDayAltFormat');\n                    return '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\n                        '<td class=\"' + (this.calendar.theme.getClass('tableListHeading') ||\n                        this.calendar.theme.getClass('widgetHeader')) + '\" colspan=\"3\">' +\n                        (mainFormat ?\n                            this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML\n                            ) :\n                            '') +\n                        (altFormat ?\n                            this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML\n                            ) :\n                            '') +\n                        '</td>' +\n                        '</tr>';\n                };\n                return ListView;\n            }(View_1.default));\n            exports.default = ListView;\n            ListView.prototype.eventRendererClass = ListEventRenderer_1.default;\n            ListView.prototype.eventPointingClass = ListEventPointing_1.default;\n            /***/ \n        }),\n        /* 231 */ ,\n        /* 232 */ ,\n        /* 233 */ ,\n        /* 234 */ ,\n        /* 235 */ ,\n        /* 236 */\n        /***/ (function (module, exports, __webpack_require__) {\n            var $ = __webpack_require__(3);\n            var exportHooks = __webpack_require__(16);\n            var util_1 = __webpack_require__(4);\n            var Calendar_1 = __webpack_require__(220);\n            // for intentional side-effects\n            __webpack_require__(10);\n            __webpack_require__(47);\n            __webpack_require__(256);\n            __webpack_require__(257);\n            __webpack_require__(260);\n            __webpack_require__(261);\n            __webpack_require__(262);\n            __webpack_require__(263);\n            $.fullCalendar = exportHooks;\n            $.fn.fullCalendar = function (options) {\n                var args = Array.prototype.slice.call(arguments, 1); // for a possible method call\n                var res = this; // what this function will return (this jQuery object by default)\n                this.each(function (i, _element) {\n                    var element = $(_element);\n                    var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\n                    var singleRes; // the returned value of this single method call\n                    // a method call\n                    if (typeof options === 'string') {\n                        if (options === 'getCalendar') {\n                            if (!i) {\n                                res = calendar;\n                            }\n                        }\n                        else if (options === 'destroy') {\n                            if (calendar) {\n                                calendar.destroy();\n                                element.removeData('fullCalendar');\n                            }\n                        }\n                        else if (!calendar) {\n                            util_1.warn('Attempting to call a FullCalendar method on an element with no calendar.');\n                        }\n                        else if ($.isFunction(calendar[options])) {\n                            singleRes = calendar[options].apply(calendar, args);\n                            if (!i) {\n                                res = singleRes; // record the first method call result\n                            }\n                            if (options === 'destroy') {\n                                element.removeData('fullCalendar');\n                            }\n                        }\n                        else {\n                            util_1.warn(\"'\" + options + \"' is an unknown FullCalendar method.\");\n                        }\n                    }\n                    else if (!calendar) {\n                        calendar = new Calendar_1.default(element, options);\n                        element.data('fullCalendar', calendar);\n                        calendar.render();\n                    }\n                });\n                return res;\n            };\n            module.exports = exportHooks;\n            /***/ \n        }),\n        /* 237 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Model_1 = __webpack_require__(48);\n            var Component = (function (_super) {\n                tslib_1.__extends(Component, _super);\n                function Component() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                Component.prototype.setElement = function (el) {\n                    this.el = el;\n                    this.bindGlobalHandlers();\n                    this.renderSkeleton();\n                    this.set('isInDom', true);\n                };\n                Component.prototype.removeElement = function () {\n                    this.unset('isInDom');\n                    this.unrenderSkeleton();\n                    this.unbindGlobalHandlers();\n                    this.el.remove();\n                    // NOTE: don't null-out this.el in case the View was destroyed within an API callback.\n                    // We don't null-out the View's other jQuery element references upon destroy,\n                    //  so we shouldn't kill this.el either.\n                };\n                Component.prototype.bindGlobalHandlers = function () {\n                    // subclasses can override\n                };\n                Component.prototype.unbindGlobalHandlers = function () {\n                    // subclasses can override\n                };\n                /*\n                NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender\n                */\n                // Renders the basic structure of the view before any content is rendered\n                Component.prototype.renderSkeleton = function () {\n                    // subclasses should implement\n                };\n                // Unrenders the basic structure of the view\n                Component.prototype.unrenderSkeleton = function () {\n                    // subclasses should implement\n                };\n                return Component;\n            }(Model_1.default));\n            exports.default = Component;\n            /***/ \n        }),\n        /* 238 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var Iterator = /*@__PURE__*/ (function () {\n                function Iterator(items) {\n                    this.items = items || [];\n                }\n                /* Calls a method on every item passing the arguments through */\n                Iterator.prototype.proxyCall = function (methodName) {\n                    var args = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        args[_i - 1] = arguments[_i];\n                    }\n                    var results = [];\n                    this.items.forEach(function (item) {\n                        results.push(item[methodName].apply(item, args));\n                    });\n                    return results;\n                };\n                return Iterator;\n            }());\n            exports.default = Iterator;\n            /***/ \n        }),\n        /* 239 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            /* Toolbar with buttons and title\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var Toolbar = /*@__PURE__*/ (function () {\n                function Toolbar(calendar, toolbarOptions) {\n                    this.el = null; // mirrors local `el`\n                    this.viewsWithButtons = [];\n                    this.calendar = calendar;\n                    this.toolbarOptions = toolbarOptions;\n                }\n                // method to update toolbar-specific options, not calendar-wide options\n                Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {\n                    this.toolbarOptions = newToolbarOptions;\n                };\n                // can be called repeatedly and will rerender\n                Toolbar.prototype.render = function () {\n                    var sections = this.toolbarOptions.layout;\n                    var el = this.el;\n                    if (sections) {\n                        if (!el) {\n                            el = this.el = $(\"<div class='fc-toolbar \" + this.toolbarOptions.extraClasses + \"'/>\");\n                        }\n                        else {\n                            el.empty();\n                        }\n                        el.append(this.renderSection('left'))\n                            .append(this.renderSection('right'))\n                            .append(this.renderSection('center'))\n                            .append('<div class=\"fc-clear\"/>');\n                    }\n                    else {\n                        this.removeElement();\n                    }\n                };\n                Toolbar.prototype.removeElement = function () {\n                    if (this.el) {\n                        this.el.remove();\n                        this.el = null;\n                    }\n                };\n                Toolbar.prototype.renderSection = function (position) {\n                    var _this = this;\n                    var calendar = this.calendar;\n                    var theme = calendar.theme;\n                    var optionsManager = calendar.optionsManager;\n                    var viewSpecManager = calendar.viewSpecManager;\n                    var sectionEl = $('<div class=\"fc-' + position + '\"/>');\n                    var buttonStr = this.toolbarOptions.layout[position];\n                    var calendarCustomButtons = optionsManager.get('customButtons') || {};\n                    var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};\n                    var calendarButtonText = optionsManager.get('buttonText') || {};\n                    if (buttonStr) {\n                        $.each(buttonStr.split(' '), function (i, buttonGroupStr) {\n                            var groupChildren = $();\n                            var isOnlyButtons = true;\n                            var groupEl;\n                            $.each(buttonGroupStr.split(','), function (j, buttonName) {\n                                var customButtonProps;\n                                var viewSpec;\n                                var buttonClick;\n                                var buttonIcon; // only one of these will be set\n                                var buttonText; // \"\n                                var buttonInnerHtml;\n                                var buttonClasses;\n                                var buttonEl;\n                                var buttonAriaAttr;\n                                if (buttonName === 'title') {\n                                    groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\n                                    isOnlyButtons = false;\n                                }\n                                else {\n                                    if ((customButtonProps = calendarCustomButtons[buttonName])) {\n                                        buttonClick = function (ev) {\n                                            if (customButtonProps.click) {\n                                                customButtonProps.click.call(buttonEl[0], ev);\n                                            }\n                                        };\n                                        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\n                                            (buttonIcon = theme.getIconClass(buttonName)) ||\n                                            (buttonText = customButtonProps.text);\n                                    }\n                                    else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {\n                                        _this.viewsWithButtons.push(buttonName);\n                                        buttonClick = function () {\n                                            calendar.changeView(buttonName);\n                                        };\n                                        (buttonText = viewSpec.buttonTextOverride) ||\n                                            (buttonIcon = theme.getIconClass(buttonName)) ||\n                                            (buttonText = viewSpec.buttonTextDefault);\n                                    }\n                                    else if (calendar[buttonName]) {\n                                        buttonClick = function () {\n                                            calendar[buttonName]();\n                                        };\n                                        (buttonText = calendarButtonTextOverrides[buttonName]) ||\n                                            (buttonIcon = theme.getIconClass(buttonName)) ||\n                                            (buttonText = calendarButtonText[buttonName]);\n                                        //            ^ everything else is considered default\n                                    }\n                                    if (buttonClick) {\n                                        buttonClasses = [\n                                            'fc-' + buttonName + '-button',\n                                            theme.getClass('button'),\n                                            theme.getClass('stateDefault')\n                                        ];\n                                        if (buttonText) {\n                                            buttonInnerHtml = util_1.htmlEscape(buttonText);\n                                            buttonAriaAttr = '';\n                                        }\n                                        else if (buttonIcon) {\n                                            buttonInnerHtml = \"<span class='\" + buttonIcon + \"'></span>\";\n                                            buttonAriaAttr = ' aria-label=\"' + buttonName + '\"';\n                                        }\n                                        buttonEl = $(// type=\"button\" so that it doesn't submit a form\n                                        '<button type=\"button\" class=\"' + buttonClasses.join(' ') + '\"' +\n                                            buttonAriaAttr +\n                                            '>' + buttonInnerHtml + '</button>')\n                                            .click(function (ev) {\n                                            // don't process clicks for disabled buttons\n                                            if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {\n                                                buttonClick(ev);\n                                                // after the click action, if the button becomes the \"active\" tab, or disabled,\n                                                // it should never have a hover class, so remove it now.\n                                                if (buttonEl.hasClass(theme.getClass('stateActive')) ||\n                                                    buttonEl.hasClass(theme.getClass('stateDisabled'))) {\n                                                    buttonEl.removeClass(theme.getClass('stateHover'));\n                                                }\n                                            }\n                                        })\n                                            .mousedown(function () {\n                                            // the *down* effect (mouse pressed in).\n                                            // only on buttons that are not the \"active\" tab, or disabled\n                                            buttonEl\n                                                .not('.' + theme.getClass('stateActive'))\n                                                .not('.' + theme.getClass('stateDisabled'))\n                                                .addClass(theme.getClass('stateDown'));\n                                        })\n                                            .mouseup(function () {\n                                            // undo the *down* effect\n                                            buttonEl.removeClass(theme.getClass('stateDown'));\n                                        })\n                                            .hover(function () {\n                                            // the *hover* effect.\n                                            // only on buttons that are not the \"active\" tab, or disabled\n                                            buttonEl\n                                                .not('.' + theme.getClass('stateActive'))\n                                                .not('.' + theme.getClass('stateDisabled'))\n                                                .addClass(theme.getClass('stateHover'));\n                                        }, function () {\n                                            // undo the *hover* effect\n                                            buttonEl\n                                                .removeClass(theme.getClass('stateHover'))\n                                                .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup\n                                        });\n                                        groupChildren = groupChildren.add(buttonEl);\n                                    }\n                                }\n                            });\n                            if (isOnlyButtons) {\n                                groupChildren\n                                    .first().addClass(theme.getClass('cornerLeft')).end()\n                                    .last().addClass(theme.getClass('cornerRight')).end();\n                            }\n                            if (groupChildren.length > 1) {\n                                groupEl = $('<div/>');\n                                if (isOnlyButtons) {\n                                    groupEl.addClass(theme.getClass('buttonGroup'));\n                                }\n                                groupEl.append(groupChildren);\n                                sectionEl.append(groupEl);\n                            }\n                            else {\n                                sectionEl.append(groupChildren); // 1 or 0 children\n                            }\n                        });\n                    }\n                    return sectionEl;\n                };\n                Toolbar.prototype.updateTitle = function (text) {\n                    if (this.el) {\n                        this.el.find('h2').text(text);\n                    }\n                };\n                Toolbar.prototype.activateButton = function (buttonName) {\n                    if (this.el) {\n                        this.el.find('.fc-' + buttonName + '-button')\n                            .addClass(this.calendar.theme.getClass('stateActive'));\n                    }\n                };\n                Toolbar.prototype.deactivateButton = function (buttonName) {\n                    if (this.el) {\n                        this.el.find('.fc-' + buttonName + '-button')\n                            .removeClass(this.calendar.theme.getClass('stateActive'));\n                    }\n                };\n                Toolbar.prototype.disableButton = function (buttonName) {\n                    if (this.el) {\n                        this.el.find('.fc-' + buttonName + '-button')\n                            .prop('disabled', true)\n                            .addClass(this.calendar.theme.getClass('stateDisabled'));\n                    }\n                };\n                Toolbar.prototype.enableButton = function (buttonName) {\n                    if (this.el) {\n                        this.el.find('.fc-' + buttonName + '-button')\n                            .prop('disabled', false)\n                            .removeClass(this.calendar.theme.getClass('stateDisabled'));\n                    }\n                };\n                Toolbar.prototype.getViewsWithButtons = function () {\n                    return this.viewsWithButtons;\n                };\n                return Toolbar;\n            }());\n            exports.default = Toolbar;\n            /***/ \n        }),\n        /* 240 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var options_1 = __webpack_require__(32);\n            var locale_1 = __webpack_require__(31);\n            var Model_1 = __webpack_require__(48);\n            var OptionsManager = (function (_super) {\n                tslib_1.__extends(OptionsManager, _super);\n                function OptionsManager(_calendar, overrides) {\n                    var _this = _super.call(this) || this;\n                    _this._calendar = _calendar;\n                    _this.overrides = $.extend({}, overrides); // make a copy\n                    _this.dynamicOverrides = {};\n                    _this.compute();\n                    return _this;\n                }\n                OptionsManager.prototype.add = function (newOptionHash) {\n                    var optionCnt = 0;\n                    var optionName;\n                    this.recordOverrides(newOptionHash); // will trigger this model's watchers\n                    for (optionName in newOptionHash) {\n                        optionCnt++;\n                    }\n                    // special-case handling of single option change.\n                    // if only one option change, `optionName` will be its name.\n                    if (optionCnt === 1) {\n                        if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\n                            this._calendar.updateViewSize(true); // isResize=true\n                            return;\n                        }\n                        else if (optionName === 'defaultDate') {\n                            return; // can't change date this way. use gotoDate instead\n                        }\n                        else if (optionName === 'businessHours') {\n                            return; // this model already reacts to this\n                        }\n                        else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {\n                            return; // doesn't affect rendering. only interactions.\n                        }\n                        else if (optionName === 'timezone') {\n                            this._calendar.view.flash('initialEvents');\n                            return;\n                        }\n                    }\n                    // catch-all. rerender the header and footer and rebuild/rerender the current view\n                    this._calendar.renderHeader();\n                    this._calendar.renderFooter();\n                    // even non-current views will be affected by this option change. do before rerender\n                    // TODO: detangle\n                    this._calendar.viewsByType = {};\n                    this._calendar.reinitView();\n                };\n                // Computes the flattened options hash for the calendar and assigns to `this.options`.\n                // Assumes this.overrides and this.dynamicOverrides have already been initialized.\n                OptionsManager.prototype.compute = function () {\n                    var locale;\n                    var localeDefaults;\n                    var isRTL;\n                    var dirDefaults;\n                    var rawOptions;\n                    locale = util_1.firstDefined(// explicit locale option given?\n                    this.dynamicOverrides.locale, this.overrides.locale);\n                    localeDefaults = locale_1.localeOptionHash[locale];\n                    if (!localeDefaults) {\n                        locale = options_1.globalDefaults.locale;\n                        localeDefaults = locale_1.localeOptionHash[locale] || {};\n                    }\n                    isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?\n                    this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);\n                    dirDefaults = isRTL ? options_1.rtlDefaults : {};\n                    this.dirDefaults = dirDefaults;\n                    this.localeDefaults = localeDefaults;\n                    rawOptions = options_1.mergeOptions([\n                        options_1.globalDefaults,\n                        dirDefaults,\n                        localeDefaults,\n                        this.overrides,\n                        this.dynamicOverrides\n                    ]);\n                    locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\n                    this.reset(rawOptions);\n                };\n                // stores the new options internally, but does not rerender anything.\n                OptionsManager.prototype.recordOverrides = function (newOptionHash) {\n                    var optionName;\n                    for (optionName in newOptionHash) {\n                        this.dynamicOverrides[optionName] = newOptionHash[optionName];\n                    }\n                    this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it\n                    this.compute(); // this.options needs to be recomputed after the dynamic override\n                };\n                return OptionsManager;\n            }(Model_1.default));\n            exports.default = OptionsManager;\n            /***/ \n        }),\n        /* 241 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var moment = __webpack_require__(0);\n            var $ = __webpack_require__(3);\n            var ViewRegistry_1 = __webpack_require__(22);\n            var util_1 = __webpack_require__(4);\n            var options_1 = __webpack_require__(32);\n            var locale_1 = __webpack_require__(31);\n            var ViewSpecManager = /*@__PURE__*/ (function () {\n                function ViewSpecManager(optionsManager, _calendar) {\n                    this.optionsManager = optionsManager;\n                    this._calendar = _calendar;\n                    this.clearCache();\n                }\n                ViewSpecManager.prototype.clearCache = function () {\n                    this.viewSpecCache = {};\n                };\n                // Gets information about how to create a view. Will use a cache.\n                ViewSpecManager.prototype.getViewSpec = function (viewType) {\n                    var cache = this.viewSpecCache;\n                    return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\n                };\n                // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n                // Preference is given to views that have corresponding buttons.\n                ViewSpecManager.prototype.getUnitViewSpec = function (unit) {\n                    var viewTypes;\n                    var i;\n                    var spec;\n                    if ($.inArray(unit, util_1.unitsDesc) !== -1) {\n                        // put views that have buttons first. there will be duplicates, but oh well\n                        viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?\n                        $.each(ViewRegistry_1.viewHash, function (viewType) {\n                            viewTypes.push(viewType);\n                        });\n                        for (i = 0; i < viewTypes.length; i++) {\n                            spec = this.getViewSpec(viewTypes[i]);\n                            if (spec) {\n                                if (spec.singleUnit === unit) {\n                                    return spec;\n                                }\n                            }\n                        }\n                    }\n                };\n                // Builds an object with information on how to create a given view\n                ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {\n                    var viewOverrides = this.optionsManager.overrides.views || {};\n                    var specChain = []; // for the view. lowest to highest priority\n                    var defaultsChain = []; // for the view. lowest to highest priority\n                    var overridesChain = []; // for the view. lowest to highest priority\n                    var viewType = requestedViewType;\n                    var spec; // for the view\n                    var overrides; // for the view\n                    var durationInput;\n                    var duration;\n                    var unit;\n                    // iterate from the specific view definition to a more general one until we hit an actual View class\n                    while (viewType) {\n                        spec = ViewRegistry_1.viewHash[viewType];\n                        overrides = viewOverrides[viewType];\n                        viewType = null; // clear. might repopulate for another iteration\n                        if (typeof spec === 'function') {\n                            spec = { 'class': spec };\n                        }\n                        if (spec) {\n                            specChain.unshift(spec);\n                            defaultsChain.unshift(spec.defaults || {});\n                            durationInput = durationInput || spec.duration;\n                            viewType = viewType || spec.type;\n                        }\n                        if (overrides) {\n                            overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\n                            durationInput = durationInput || overrides.duration;\n                            viewType = viewType || overrides.type;\n                        }\n                    }\n                    spec = util_1.mergeProps(specChain);\n                    spec.type = requestedViewType;\n                    if (!spec['class']) {\n                        return false;\n                    }\n                    // fall back to top-level `duration` option\n                    durationInput = durationInput ||\n                        this.optionsManager.dynamicOverrides.duration ||\n                        this.optionsManager.overrides.duration;\n                    if (durationInput) {\n                        duration = moment.duration(durationInput);\n                        if (duration.valueOf()) {\n                            unit = util_1.computeDurationGreatestUnit(duration, durationInput);\n                            spec.duration = duration;\n                            spec.durationUnit = unit;\n                            // view is a single-unit duration, like \"week\" or \"day\"\n                            // incorporate options for this. lowest priority\n                            if (duration.as(unit) === 1) {\n                                spec.singleUnit = unit;\n                                overridesChain.unshift(viewOverrides[unit] || {});\n                            }\n                        }\n                    }\n                    spec.defaults = options_1.mergeOptions(defaultsChain);\n                    spec.overrides = options_1.mergeOptions(overridesChain);\n                    this.buildViewSpecOptions(spec);\n                    this.buildViewSpecButtonText(spec, requestedViewType);\n                    return spec;\n                };\n                // Builds and assigns a view spec's options object from its already-assigned defaults and overrides\n                ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {\n                    var optionsManager = this.optionsManager;\n                    spec.options = options_1.mergeOptions([\n                        options_1.globalDefaults,\n                        spec.defaults,\n                        optionsManager.dirDefaults,\n                        optionsManager.localeDefaults,\n                        optionsManager.overrides,\n                        spec.overrides,\n                        optionsManager.dynamicOverrides // dynamically set via setter. highest precedence\n                    ]);\n                    locale_1.populateInstanceComputableOptions(spec.options);\n                };\n                // Computes and assigns a view spec's buttonText-related options\n                ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {\n                    var optionsManager = this.optionsManager;\n                    // given an options object with a possible `buttonText` hash, lookup the buttonText for the\n                    // requested view, falling back to a generic unit entry like \"week\" or \"day\"\n                    function queryButtonText(options) {\n                        var buttonText = options.buttonText || {};\n                        return buttonText[requestedViewType] ||\n                            // view can decide to look up a certain key\n                            (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\n                            // a key like \"month\"\n                            (spec.singleUnit ? buttonText[spec.singleUnit] : null);\n                    }\n                    // highest to lowest priority\n                    spec.buttonTextOverride =\n                        queryButtonText(optionsManager.dynamicOverrides) ||\n                            queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence\n                            spec.overrides.buttonText; // `buttonText` for view-specific options is a string\n                    // highest to lowest priority. mirrors buildViewSpecOptions\n                    spec.buttonTextDefault =\n                        queryButtonText(optionsManager.localeDefaults) ||\n                            queryButtonText(optionsManager.dirDefaults) ||\n                            spec.defaults.buttonText || // a single string. from ViewSubclass.defaults\n                            queryButtonText(options_1.globalDefaults) ||\n                            (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like \"3 days\"\n                            requestedViewType; // fall back to given view name\n                };\n                return ViewSpecManager;\n            }());\n            exports.default = ViewSpecManager;\n            /***/ \n        }),\n        /* 242 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var EventPeriod_1 = __webpack_require__(243);\n            var ArrayEventSource_1 = __webpack_require__(52);\n            var EventSource_1 = __webpack_require__(6);\n            var EventSourceParser_1 = __webpack_require__(38);\n            var SingleEventDef_1 = __webpack_require__(13);\n            var EventInstanceGroup_1 = __webpack_require__(18);\n            var EmitterMixin_1 = __webpack_require__(11);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var EventManager = /*@__PURE__*/ (function () {\n                function EventManager(calendar) {\n                    this.calendar = calendar;\n                    this.stickySource = new ArrayEventSource_1.default(calendar);\n                    this.otherSources = [];\n                }\n                EventManager.prototype.requestEvents = function (start, end, timezone, force) {\n                    if (force ||\n                        !this.currentPeriod ||\n                        !this.currentPeriod.isWithinRange(start, end) ||\n                        timezone !== this.currentPeriod.timezone) {\n                        this.setPeriod(// will change this.currentPeriod\n                        new EventPeriod_1.default(start, end, timezone));\n                    }\n                    return this.currentPeriod.whenReleased();\n                };\n                // Source Adding/Removing\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.addSource = function (eventSource) {\n                    this.otherSources.push(eventSource);\n                    if (this.currentPeriod) {\n                        this.currentPeriod.requestSource(eventSource); // might release\n                    }\n                };\n                EventManager.prototype.removeSource = function (doomedSource) {\n                    util_1.removeExact(this.otherSources, doomedSource);\n                    if (this.currentPeriod) {\n                        this.currentPeriod.purgeSource(doomedSource); // might release\n                    }\n                };\n                EventManager.prototype.removeAllSources = function () {\n                    this.otherSources = [];\n                    if (this.currentPeriod) {\n                        this.currentPeriod.purgeAllSources(); // might release\n                    }\n                };\n                // Source Refetching\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.refetchSource = function (eventSource) {\n                    var currentPeriod = this.currentPeriod;\n                    if (currentPeriod) {\n                        currentPeriod.freeze();\n                        currentPeriod.purgeSource(eventSource);\n                        currentPeriod.requestSource(eventSource);\n                        currentPeriod.thaw();\n                    }\n                };\n                EventManager.prototype.refetchAllSources = function () {\n                    var currentPeriod = this.currentPeriod;\n                    if (currentPeriod) {\n                        currentPeriod.freeze();\n                        currentPeriod.purgeAllSources();\n                        currentPeriod.requestSources(this.getSources());\n                        currentPeriod.thaw();\n                    }\n                };\n                // Source Querying\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.getSources = function () {\n                    return [this.stickySource].concat(this.otherSources);\n                };\n                // like querySources, but accepts multple match criteria (like multiple IDs)\n                EventManager.prototype.multiQuerySources = function (matchInputs) {\n                    // coerce into an array\n                    if (!matchInputs) {\n                        matchInputs = [];\n                    }\n                    else if (!$.isArray(matchInputs)) {\n                        matchInputs = [matchInputs];\n                    }\n                    var matchingSources = [];\n                    var i;\n                    // resolve raw inputs to real event source objects\n                    for (i = 0; i < matchInputs.length; i++) {\n                        matchingSources.push.apply(// append\n                        matchingSources, this.querySources(matchInputs[i]));\n                    }\n                    return matchingSources;\n                };\n                // matchInput can either by a real event source object, an ID, or the function/URL for the source.\n                // returns an array of matching source objects.\n                EventManager.prototype.querySources = function (matchInput) {\n                    var sources = this.otherSources;\n                    var i;\n                    var source;\n                    // given a proper event source object\n                    for (i = 0; i < sources.length; i++) {\n                        source = sources[i];\n                        if (source === matchInput) {\n                            return [source];\n                        }\n                    }\n                    // an ID match\n                    source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));\n                    if (source) {\n                        return [source];\n                    }\n                    // parse as an event source\n                    matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);\n                    if (matchInput) {\n                        return $.grep(sources, function (source) {\n                            return isSourcesEquivalent(matchInput, source);\n                        });\n                    }\n                };\n                /*\n                ID assumed to already be normalized\n                */\n                EventManager.prototype.getSourceById = function (id) {\n                    return $.grep(this.otherSources, function (source) {\n                        return source.id && source.id === id;\n                    })[0];\n                };\n                // Event-Period\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.setPeriod = function (eventPeriod) {\n                    if (this.currentPeriod) {\n                        this.unbindPeriod(this.currentPeriod);\n                        this.currentPeriod = null;\n                    }\n                    this.currentPeriod = eventPeriod;\n                    this.bindPeriod(eventPeriod);\n                    eventPeriod.requestSources(this.getSources());\n                };\n                EventManager.prototype.bindPeriod = function (eventPeriod) {\n                    this.listenTo(eventPeriod, 'release', function (eventsPayload) {\n                        this.trigger('release', eventsPayload);\n                    });\n                };\n                EventManager.prototype.unbindPeriod = function (eventPeriod) {\n                    this.stopListeningTo(eventPeriod);\n                };\n                // Event Getting/Adding/Removing\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.getEventDefByUid = function (uid) {\n                    if (this.currentPeriod) {\n                        return this.currentPeriod.getEventDefByUid(uid);\n                    }\n                };\n                EventManager.prototype.addEventDef = function (eventDef, isSticky) {\n                    if (isSticky) {\n                        this.stickySource.addEventDef(eventDef);\n                    }\n                    if (this.currentPeriod) {\n                        this.currentPeriod.addEventDef(eventDef); // might release\n                    }\n                };\n                EventManager.prototype.removeEventDefsById = function (eventId) {\n                    this.getSources().forEach(function (eventSource) {\n                        eventSource.removeEventDefsById(eventId);\n                    });\n                    if (this.currentPeriod) {\n                        this.currentPeriod.removeEventDefsById(eventId); // might release\n                    }\n                };\n                EventManager.prototype.removeAllEventDefs = function () {\n                    this.getSources().forEach(function (eventSource) {\n                        eventSource.removeAllEventDefs();\n                    });\n                    if (this.currentPeriod) {\n                        this.currentPeriod.removeAllEventDefs();\n                    }\n                };\n                // Event Mutating\n                // -----------------------------------------------------------------------------------------------------------------\n                /*\n                Returns an undo function.\n                */\n                EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {\n                    var currentPeriod = this.currentPeriod;\n                    var eventDefs;\n                    var undoFuncs = [];\n                    if (currentPeriod) {\n                        currentPeriod.freeze();\n                        eventDefs = currentPeriod.getEventDefsById(eventDefId);\n                        eventDefs.forEach(function (eventDef) {\n                            // add/remove esp because id might change\n                            currentPeriod.removeEventDef(eventDef);\n                            undoFuncs.push(eventDefMutation.mutateSingle(eventDef));\n                            currentPeriod.addEventDef(eventDef);\n                        });\n                        currentPeriod.thaw();\n                        return function () {\n                            currentPeriod.freeze();\n                            for (var i = 0; i < eventDefs.length; i++) {\n                                currentPeriod.removeEventDef(eventDefs[i]);\n                                undoFuncs[i]();\n                                currentPeriod.addEventDef(eventDefs[i]);\n                            }\n                            currentPeriod.thaw();\n                        };\n                    }\n                    return function () { };\n                };\n                /*\n                copies and then mutates\n                */\n                EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {\n                    var eventDefs = this.getEventDefsById(eventDefId);\n                    var i;\n                    var defCopy;\n                    var allInstances = [];\n                    for (i = 0; i < eventDefs.length; i++) {\n                        defCopy = eventDefs[i].clone();\n                        if (defCopy instanceof SingleEventDef_1.default) {\n                            eventDefMutation.mutateSingle(defCopy);\n                            allInstances.push.apply(allInstances, // append\n                            defCopy.buildInstances());\n                        }\n                    }\n                    return new EventInstanceGroup_1.default(allInstances);\n                };\n                // Freezing\n                // -----------------------------------------------------------------------------------------------------------------\n                EventManager.prototype.freeze = function () {\n                    if (this.currentPeriod) {\n                        this.currentPeriod.freeze();\n                    }\n                };\n                EventManager.prototype.thaw = function () {\n                    if (this.currentPeriod) {\n                        this.currentPeriod.thaw();\n                    }\n                };\n                // methods that simply forward to EventPeriod\n                EventManager.prototype.getEventDefsById = function (eventDefId) {\n                    return this.currentPeriod.getEventDefsById(eventDefId);\n                };\n                EventManager.prototype.getEventInstances = function () {\n                    return this.currentPeriod.getEventInstances();\n                };\n                EventManager.prototype.getEventInstancesWithId = function (eventDefId) {\n                    return this.currentPeriod.getEventInstancesWithId(eventDefId);\n                };\n                EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {\n                    return this.currentPeriod.getEventInstancesWithoutId(eventDefId);\n                };\n                return EventManager;\n            }());\n            exports.default = EventManager;\n            EmitterMixin_1.default.mixInto(EventManager);\n            ListenerMixin_1.default.mixInto(EventManager);\n            function isSourcesEquivalent(source0, source1) {\n                return source0.getPrimitive() === source1.getPrimitive();\n            }\n            /***/ \n        }),\n        /* 243 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var Promise_1 = __webpack_require__(20);\n            var EmitterMixin_1 = __webpack_require__(11);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var EventInstanceGroup_1 = __webpack_require__(18);\n            var EventPeriod = /*@__PURE__*/ (function () {\n                function EventPeriod(start, end, timezone) {\n                    this.pendingCnt = 0;\n                    this.freezeDepth = 0;\n                    this.stuntedReleaseCnt = 0;\n                    this.releaseCnt = 0;\n                    this.start = start;\n                    this.end = end;\n                    this.timezone = timezone;\n                    this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());\n                    this.requestsByUid = {};\n                    this.eventDefsByUid = {};\n                    this.eventDefsById = {};\n                    this.eventInstanceGroupsById = {};\n                }\n                EventPeriod.prototype.isWithinRange = function (start, end) {\n                    // TODO: use a range util function?\n                    return !start.isBefore(this.start) && !end.isAfter(this.end);\n                };\n                // Requesting and Purging\n                // -----------------------------------------------------------------------------------------------------------------\n                EventPeriod.prototype.requestSources = function (sources) {\n                    this.freeze();\n                    for (var i = 0; i < sources.length; i++) {\n                        this.requestSource(sources[i]);\n                    }\n                    this.thaw();\n                };\n                EventPeriod.prototype.requestSource = function (source) {\n                    var _this = this;\n                    var request = { source: source, status: 'pending', eventDefs: null };\n                    this.requestsByUid[source.uid] = request;\n                    this.pendingCnt += 1;\n                    source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {\n                        if (request.status !== 'cancelled') {\n                            request.status = 'completed';\n                            request.eventDefs = eventDefs;\n                            _this.addEventDefs(eventDefs);\n                            _this.pendingCnt--;\n                            _this.tryRelease();\n                        }\n                    }, function () {\n                        if (request.status !== 'cancelled') {\n                            request.status = 'failed';\n                            _this.pendingCnt--;\n                            _this.tryRelease();\n                        }\n                    });\n                };\n                EventPeriod.prototype.purgeSource = function (source) {\n                    var request = this.requestsByUid[source.uid];\n                    if (request) {\n                        delete this.requestsByUid[source.uid];\n                        if (request.status === 'pending') {\n                            request.status = 'cancelled';\n                            this.pendingCnt--;\n                            this.tryRelease();\n                        }\n                        else if (request.status === 'completed') {\n                            request.eventDefs.forEach(this.removeEventDef.bind(this));\n                        }\n                    }\n                };\n                EventPeriod.prototype.purgeAllSources = function () {\n                    var requestsByUid = this.requestsByUid;\n                    var uid;\n                    var request;\n                    var completedCnt = 0;\n                    for (uid in requestsByUid) {\n                        request = requestsByUid[uid];\n                        if (request.status === 'pending') {\n                            request.status = 'cancelled';\n                        }\n                        else if (request.status === 'completed') {\n                            completedCnt++;\n                        }\n                    }\n                    this.requestsByUid = {};\n                    this.pendingCnt = 0;\n                    if (completedCnt) {\n                        this.removeAllEventDefs(); // might release\n                    }\n                };\n                // Event Definitions\n                // -----------------------------------------------------------------------------------------------------------------\n                EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {\n                    return this.eventDefsByUid[eventDefUid];\n                };\n                EventPeriod.prototype.getEventDefsById = function (eventDefId) {\n                    var a = this.eventDefsById[eventDefId];\n                    if (a) {\n                        return a.slice(); // clone\n                    }\n                    return [];\n                };\n                EventPeriod.prototype.addEventDefs = function (eventDefs) {\n                    for (var i = 0; i < eventDefs.length; i++) {\n                        this.addEventDef(eventDefs[i]);\n                    }\n                };\n                EventPeriod.prototype.addEventDef = function (eventDef) {\n                    var eventDefsById = this.eventDefsById;\n                    var eventDefId = eventDef.id;\n                    var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);\n                    var eventInstances = eventDef.buildInstances(this.unzonedRange);\n                    var i;\n                    eventDefs.push(eventDef);\n                    this.eventDefsByUid[eventDef.uid] = eventDef;\n                    for (i = 0; i < eventInstances.length; i++) {\n                        this.addEventInstance(eventInstances[i], eventDefId);\n                    }\n                };\n                EventPeriod.prototype.removeEventDefsById = function (eventDefId) {\n                    var _this = this;\n                    this.getEventDefsById(eventDefId).forEach(function (eventDef) {\n                        _this.removeEventDef(eventDef);\n                    });\n                };\n                EventPeriod.prototype.removeAllEventDefs = function () {\n                    var isEmpty = $.isEmptyObject(this.eventDefsByUid);\n                    this.eventDefsByUid = {};\n                    this.eventDefsById = {};\n                    this.eventInstanceGroupsById = {};\n                    if (!isEmpty) {\n                        this.tryRelease();\n                    }\n                };\n                EventPeriod.prototype.removeEventDef = function (eventDef) {\n                    var eventDefsById = this.eventDefsById;\n                    var eventDefs = eventDefsById[eventDef.id];\n                    delete this.eventDefsByUid[eventDef.uid];\n                    if (eventDefs) {\n                        util_1.removeExact(eventDefs, eventDef);\n                        if (!eventDefs.length) {\n                            delete eventDefsById[eventDef.id];\n                        }\n                        this.removeEventInstancesForDef(eventDef);\n                    }\n                };\n                // Event Instances\n                // -----------------------------------------------------------------------------------------------------------------\n                EventPeriod.prototype.getEventInstances = function () {\n                    var eventInstanceGroupsById = this.eventInstanceGroupsById;\n                    var eventInstances = [];\n                    var id;\n                    for (id in eventInstanceGroupsById) {\n                        eventInstances.push.apply(eventInstances, // append\n                        eventInstanceGroupsById[id].eventInstances);\n                    }\n                    return eventInstances;\n                };\n                EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {\n                    var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];\n                    if (eventInstanceGroup) {\n                        return eventInstanceGroup.eventInstances.slice(); // clone\n                    }\n                    return [];\n                };\n                EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {\n                    var eventInstanceGroupsById = this.eventInstanceGroupsById;\n                    var matchingInstances = [];\n                    var id;\n                    for (id in eventInstanceGroupsById) {\n                        if (id !== eventDefId) {\n                            matchingInstances.push.apply(matchingInstances, // append\n                            eventInstanceGroupsById[id].eventInstances);\n                        }\n                    }\n                    return matchingInstances;\n                };\n                EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {\n                    var eventInstanceGroupsById = this.eventInstanceGroupsById;\n                    var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||\n                        (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());\n                    eventInstanceGroup.eventInstances.push(eventInstance);\n                    this.tryRelease();\n                };\n                EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {\n                    var eventInstanceGroupsById = this.eventInstanceGroupsById;\n                    var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];\n                    var removeCnt;\n                    if (eventInstanceGroup) {\n                        removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {\n                            return currentEventInstance.def === eventDef;\n                        });\n                        if (!eventInstanceGroup.eventInstances.length) {\n                            delete eventInstanceGroupsById[eventDef.id];\n                        }\n                        if (removeCnt) {\n                            this.tryRelease();\n                        }\n                    }\n                };\n                // Releasing and Freezing\n                // -----------------------------------------------------------------------------------------------------------------\n                EventPeriod.prototype.tryRelease = function () {\n                    if (!this.pendingCnt) {\n                        if (!this.freezeDepth) {\n                            this.release();\n                        }\n                        else {\n                            this.stuntedReleaseCnt++;\n                        }\n                    }\n                };\n                EventPeriod.prototype.release = function () {\n                    this.releaseCnt++;\n                    this.trigger('release', this.eventInstanceGroupsById);\n                };\n                EventPeriod.prototype.whenReleased = function () {\n                    var _this = this;\n                    if (this.releaseCnt) {\n                        return Promise_1.default.resolve(this.eventInstanceGroupsById);\n                    }\n                    else {\n                        return Promise_1.default.construct(function (onResolve) {\n                            _this.one('release', onResolve);\n                        });\n                    }\n                };\n                EventPeriod.prototype.freeze = function () {\n                    if (!(this.freezeDepth++)) {\n                        this.stuntedReleaseCnt = 0;\n                    }\n                };\n                EventPeriod.prototype.thaw = function () {\n                    if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {\n                        this.release();\n                    }\n                };\n                return EventPeriod;\n            }());\n            exports.default = EventPeriod;\n            EmitterMixin_1.default.mixInto(EventPeriod);\n            /***/ \n        }),\n        /* 244 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var ListenerMixin_1 = __webpack_require__(7);\n            /* Creates a clone of an element and lets it track the mouse as it moves\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var MouseFollower = /*@__PURE__*/ (function () {\n                function MouseFollower(sourceEl, options) {\n                    this.isFollowing = false;\n                    this.isHidden = false;\n                    this.isAnimating = false; // doing the revert animation?\n                    this.options = options = options || {};\n                    this.sourceEl = sourceEl;\n                    this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\n                }\n                // Causes the element to start following the mouse\n                MouseFollower.prototype.start = function (ev) {\n                    if (!this.isFollowing) {\n                        this.isFollowing = true;\n                        this.y0 = util_1.getEvY(ev);\n                        this.x0 = util_1.getEvX(ev);\n                        this.topDelta = 0;\n                        this.leftDelta = 0;\n                        if (!this.isHidden) {\n                            this.updatePosition();\n                        }\n                        if (util_1.getEvIsTouch(ev)) {\n                            this.listenTo($(document), 'touchmove', this.handleMove);\n                        }\n                        else {\n                            this.listenTo($(document), 'mousemove', this.handleMove);\n                        }\n                    }\n                };\n                // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\n                // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\n                MouseFollower.prototype.stop = function (shouldRevert, callback) {\n                    var _this = this;\n                    var revertDuration = this.options.revertDuration;\n                    var complete = function () {\n                        _this.isAnimating = false;\n                        _this.removeElement();\n                        _this.top0 = _this.left0 = null; // reset state for future updatePosition calls\n                        if (callback) {\n                            callback();\n                        }\n                    };\n                    if (this.isFollowing && !this.isAnimating) {\n                        this.isFollowing = false;\n                        this.stopListeningTo($(document));\n                        if (shouldRevert && revertDuration && !this.isHidden) {\n                            this.isAnimating = true;\n                            this.el.animate({\n                                top: this.top0,\n                                left: this.left0\n                            }, {\n                                duration: revertDuration,\n                                complete: complete\n                            });\n                        }\n                        else {\n                            complete();\n                        }\n                    }\n                };\n                // Gets the tracking element. Create it if necessary\n                MouseFollower.prototype.getEl = function () {\n                    var el = this.el;\n                    if (!el) {\n                        el = this.el = this.sourceEl.clone()\n                            .addClass(this.options.additionalClass || '')\n                            .css({\n                            position: 'absolute',\n                            visibility: '',\n                            display: this.isHidden ? 'none' : '',\n                            margin: 0,\n                            right: 'auto',\n                            bottom: 'auto',\n                            width: this.sourceEl.width(),\n                            height: this.sourceEl.height(),\n                            opacity: this.options.opacity || '',\n                            zIndex: this.options.zIndex\n                        });\n                        // we don't want long taps or any mouse interaction causing selection/menus.\n                        // would use preventSelection(), but that prevents selectstart, causing problems.\n                        el.addClass('fc-unselectable');\n                        el.appendTo(this.parentEl);\n                    }\n                    return el;\n                };\n                // Removes the tracking element if it has already been created\n                MouseFollower.prototype.removeElement = function () {\n                    if (this.el) {\n                        this.el.remove();\n                        this.el = null;\n                    }\n                };\n                // Update the CSS position of the tracking element\n                MouseFollower.prototype.updatePosition = function () {\n                    var sourceOffset;\n                    var origin;\n                    this.getEl(); // ensure this.el\n                    // make sure origin info was computed\n                    if (this.top0 == null) {\n                        sourceOffset = this.sourceEl.offset();\n                        origin = this.el.offsetParent().offset();\n                        this.top0 = sourceOffset.top - origin.top;\n                        this.left0 = sourceOffset.left - origin.left;\n                    }\n                    this.el.css({\n                        top: this.top0 + this.topDelta,\n                        left: this.left0 + this.leftDelta\n                    });\n                };\n                // Gets called when the user moves the mouse\n                MouseFollower.prototype.handleMove = function (ev) {\n                    this.topDelta = util_1.getEvY(ev) - this.y0;\n                    this.leftDelta = util_1.getEvX(ev) - this.x0;\n                    if (!this.isHidden) {\n                        this.updatePosition();\n                    }\n                };\n                // Temporarily makes the tracking element invisible. Can be called before following starts\n                MouseFollower.prototype.hide = function () {\n                    if (!this.isHidden) {\n                        this.isHidden = true;\n                        if (this.el) {\n                            this.el.hide();\n                        }\n                    }\n                };\n                // Show the tracking element after it has been temporarily hidden\n                MouseFollower.prototype.show = function () {\n                    if (this.isHidden) {\n                        this.isHidden = false;\n                        this.updatePosition();\n                        this.getEl().show();\n                    }\n                };\n                return MouseFollower;\n            }());\n            exports.default = MouseFollower;\n            ListenerMixin_1.default.mixInto(MouseFollower);\n            /***/ \n        }),\n        /* 245 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var HitDragListener_1 = __webpack_require__(23);\n            var Interaction_1 = __webpack_require__(15);\n            var DateClicking = (function (_super) {\n                tslib_1.__extends(DateClicking, _super);\n                /*\n                component must implement:\n                  - bindDateHandlerToEl\n                  - getSafeHitFootprint\n                  - getHitEl\n                */\n                function DateClicking(component) {\n                    var _this = _super.call(this, component) || this;\n                    _this.dragListener = _this.buildDragListener();\n                    return _this;\n                }\n                DateClicking.prototype.end = function () {\n                    this.dragListener.endInteraction();\n                };\n                DateClicking.prototype.bindToEl = function (el) {\n                    var component = this.component;\n                    var dragListener = this.dragListener;\n                    component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\n                        if (!component.shouldIgnoreMouse()) {\n                            dragListener.startInteraction(ev);\n                        }\n                    });\n                    component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\n                        if (!component.shouldIgnoreTouch()) {\n                            dragListener.startInteraction(ev);\n                        }\n                    });\n                };\n                // Creates a listener that tracks the user's drag across day elements, for day clicking.\n                DateClicking.prototype.buildDragListener = function () {\n                    var _this = this;\n                    var component = this.component;\n                    var dayClickHit; // null if invalid dayClick\n                    var dragListener = new HitDragListener_1.default(component, {\n                        scroll: this.opt('dragScroll'),\n                        interactionStart: function () {\n                            dayClickHit = dragListener.origHit;\n                        },\n                        hitOver: function (hit, isOrig, origHit) {\n                            // if user dragged to another cell at any point, it can no longer be a dayClick\n                            if (!isOrig) {\n                                dayClickHit = null;\n                            }\n                        },\n                        hitOut: function () {\n                            dayClickHit = null;\n                        },\n                        interactionEnd: function (ev, isCancelled) {\n                            var componentFootprint;\n                            if (!isCancelled && dayClickHit) {\n                                componentFootprint = component.getSafeHitFootprint(dayClickHit);\n                                if (componentFootprint) {\n                                    _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);\n                                }\n                            }\n                        }\n                    });\n                    // because dragListener won't be called with any time delay, \"dragging\" will begin immediately,\n                    // which will kill any touchmoving/scrolling. Prevent this.\n                    dragListener.shouldCancelTouchScroll = false;\n                    dragListener.scrollAlwaysKills = true;\n                    return dragListener;\n                };\n                return DateClicking;\n            }(Interaction_1.default));\n            exports.default = DateClicking;\n            /***/ \n        }),\n        /* 246 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var EventRenderer_1 = __webpack_require__(42);\n            /*\n            Only handles foreground segs.\n            Does not own rendering. Use for low-level util methods by TimeGrid.\n            */\n            var TimeGridEventRenderer = (function (_super) {\n                tslib_1.__extends(TimeGridEventRenderer, _super);\n                function TimeGridEventRenderer(timeGrid, fillRenderer) {\n                    var _this = _super.call(this, timeGrid, fillRenderer) || this;\n                    _this.timeGrid = timeGrid;\n                    return _this;\n                }\n                TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {\n                    this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);\n                };\n                // Given an array of foreground segments, render a DOM element for each, computes position,\n                // and attaches to the column inner-container elements.\n                TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {\n                    var segsByCol;\n                    var col;\n                    segsByCol = this.timeGrid.groupSegsByCol(segs);\n                    for (col = 0; col < this.timeGrid.colCnt; col++) {\n                        this.updateFgSegCoords(segsByCol[col]);\n                    }\n                    this.timeGrid.attachSegsByCol(segsByCol, containerEls);\n                };\n                TimeGridEventRenderer.prototype.unrenderFgSegs = function () {\n                    if (this.fgSegs) {\n                        this.fgSegs.forEach(function (seg) {\n                            seg.el.remove();\n                        });\n                    }\n                };\n                // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n                TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {\n                    return this.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\n                };\n                // Computes a default `displayEventEnd` value if one is not expliclty defined\n                TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n                    return true;\n                };\n                // Renders the HTML for a single event segment's default rendering\n                TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var componentFootprint = seg.footprint.componentFootprint;\n                    var isAllDay = componentFootprint.isAllDay;\n                    var eventDef = seg.footprint.eventDef;\n                    var isDraggable = view.isEventDefDraggable(eventDef);\n                    var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);\n                    var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\n                    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n                    var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\n                    var timeText;\n                    var fullTimeText; // more verbose time text. for the print stylesheet\n                    var startTimeText; // just the start time text\n                    classes.unshift('fc-time-grid-event', 'fc-v-event');\n                    // if the event appears to span more than one day...\n                    if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\n                        // Don't display time text on segments that run entirely through a day.\n                        // That would appear as midnight-midnight and would look dumb.\n                        // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n                        if (seg.isStart || seg.isEnd) {\n                            var zonedStart = calendar.msToMoment(seg.startMs);\n                            var zonedEnd = calendar.msToMoment(seg.endMs);\n                            timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);\n                            fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');\n                            startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false\n                        }\n                    }\n                    else {\n                        // Display the normal time text for the *event's* times\n                        timeText = this.getTimeText(seg.footprint);\n                        fullTimeText = this.getTimeText(seg.footprint, 'LT');\n                        startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false\n                    }\n                    return '<a class=\"' + classes.join(' ') + '\"' +\n                        (eventDef.url ?\n                            ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\n                            '') +\n                        (skinCss ?\n                            ' style=\"' + skinCss + '\"' :\n                            '') +\n                        '>' +\n                        '<div class=\"fc-content\">' +\n                        (timeText ?\n                            '<div class=\"fc-time\"' +\n                                ' data-start=\"' + util_1.htmlEscape(startTimeText) + '\"' +\n                                ' data-full=\"' + util_1.htmlEscape(fullTimeText) + '\"' +\n                                '>' +\n                                '<span>' + util_1.htmlEscape(timeText) + '</span>' +\n                                '</div>' :\n                            '') +\n                        (eventDef.title ?\n                            '<div class=\"fc-title\">' +\n                                util_1.htmlEscape(eventDef.title) +\n                                '</div>' :\n                            '') +\n                        '</div>' +\n                        '<div class=\"fc-bg\"/>' +\n                        /* TODO: write CSS for this\n                        (isResizableFromStart ?\n                          '<div class=\"fc-resizer fc-start-resizer\" />' :\n                          ''\n                          ) +\n                        */\n                        (isResizableFromEnd ?\n                            '<div class=\"fc-resizer fc-end-resizer\" />' :\n                            '') +\n                        '</a>';\n                };\n                // Given segments that are assumed to all live in the *same column*,\n                // compute their verical/horizontal coordinates and assign to their elements.\n                TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {\n                    this.timeGrid.computeSegVerticals(segs); // horizontals relies on this\n                    this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\n                    this.timeGrid.assignSegVerticals(segs);\n                    this.assignFgSegHorizontals(segs);\n                };\n                // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n                // NOTE: Also reorders the given array by date!\n                TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {\n                    var levels;\n                    var level0;\n                    var i;\n                    this.sortEventSegs(segs); // order by certain criteria\n                    levels = buildSlotSegLevels(segs);\n                    computeForwardSlotSegs(levels);\n                    if ((level0 = levels[0])) {\n                        for (i = 0; i < level0.length; i++) {\n                            computeSlotSegPressures(level0[i]);\n                        }\n                        for (i = 0; i < level0.length; i++) {\n                            this.computeFgSegForwardBack(level0[i], 0, 0);\n                        }\n                    }\n                };\n                // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n                // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n                // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n                //\n                // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n                // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n                // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n                // coordinate of the first segment in the series.\n                TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {\n                    var forwardSegs = seg.forwardSegs;\n                    var i;\n                    if (seg.forwardCoord === undefined) {\n                        if (!forwardSegs.length) {\n                            // if there are no forward segments, this segment should butt up against the edge\n                            seg.forwardCoord = 1;\n                        }\n                        else {\n                            // sort highest pressure first\n                            this.sortForwardSegs(forwardSegs);\n                            // this segment's forwardCoord will be calculated from the backwardCoord of the\n                            // highest-pressure forward segment.\n                            this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n                            seg.forwardCoord = forwardSegs[0].backwardCoord;\n                        }\n                        // calculate the backwardCoord from the forwardCoord. consider the series\n                        seg.backwardCoord = seg.forwardCoord -\n                            (seg.forwardCoord - seriesBackwardCoord) / // available width for series\n                                (seriesBackwardPressure + 1); // # of segments in the series\n                        // use this segment's coordinates to computed the coordinates of the less-pressurized\n                        // forward segments\n                        for (i = 0; i < forwardSegs.length; i++) {\n                            this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n                        }\n                    }\n                };\n                TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {\n                    forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));\n                };\n                // A cmp function for determining which forward segment to rely on more when computing coordinates.\n                TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {\n                    // put higher-pressure first\n                    return seg2.forwardPressure - seg1.forwardPressure ||\n                        // put segments that are closer to initial edge first (and favor ones with no coords yet)\n                        (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\n                        // do normal sorting...\n                        this.compareEventSegs(seg1, seg2);\n                };\n                // Given foreground event segments that have already had their position coordinates computed,\n                // assigns position-related CSS values to their elements.\n                TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {\n                    var i;\n                    var seg;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        seg.el.css(this.generateFgSegHorizontalCss(seg));\n                        // if the height is short, add a className for alternate styling\n                        if (seg.bottom - seg.top < 30) {\n                            seg.el.addClass('fc-short');\n                        }\n                    }\n                };\n                // Generates an object with CSS properties/values that should be applied to an event segment element.\n                // Contains important positioning-related properties that should be applied to any event element, customized or not.\n                TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {\n                    var shouldOverlap = this.opt('slotEventOverlap');\n                    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n                    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n                    var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\n                    var isRTL = this.timeGrid.isRTL;\n                    var left; // amount of space from left edge, a fraction of the total width\n                    var right; // amount of space from right edge, a fraction of the total width\n                    if (shouldOverlap) {\n                        // double the width, but don't go beyond the maximum forward coordinate (1.0)\n                        forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n                    }\n                    if (isRTL) {\n                        left = 1 - forwardCoord;\n                        right = backwardCoord;\n                    }\n                    else {\n                        left = backwardCoord;\n                        right = 1 - forwardCoord;\n                    }\n                    props.zIndex = seg.level + 1; // convert from 0-base to 1-based\n                    props.left = left * 100 + '%';\n                    props.right = right * 100 + '%';\n                    if (shouldOverlap && seg.forwardPressure) {\n                        // add padding to the edge so that forward stacked events don't cover the resizer's icon\n                        props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n                    }\n                    return props;\n                };\n                return TimeGridEventRenderer;\n            }(EventRenderer_1.default));\n            exports.default = TimeGridEventRenderer;\n            // Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n            // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n            function buildSlotSegLevels(segs) {\n                var levels = [];\n                var i;\n                var seg;\n                var j;\n                for (i = 0; i < segs.length; i++) {\n                    seg = segs[i];\n                    // go through all the levels and stop on the first level where there are no collisions\n                    for (j = 0; j < levels.length; j++) {\n                        if (!computeSlotSegCollisions(seg, levels[j]).length) {\n                            break;\n                        }\n                    }\n                    seg.level = j;\n                    (levels[j] || (levels[j] = [])).push(seg);\n                }\n                return levels;\n            }\n            // For every segment, figure out the other segments that are in subsequent\n            // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n            function computeForwardSlotSegs(levels) {\n                var i;\n                var level;\n                var j;\n                var seg;\n                var k;\n                for (i = 0; i < levels.length; i++) {\n                    level = levels[i];\n                    for (j = 0; j < level.length; j++) {\n                        seg = level[j];\n                        seg.forwardSegs = [];\n                        for (k = i + 1; k < levels.length; k++) {\n                            computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n                        }\n                    }\n                }\n            }\n            // Figure out which path forward (via seg.forwardSegs) results in the longest path until\n            // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n            function computeSlotSegPressures(seg) {\n                var forwardSegs = seg.forwardSegs;\n                var forwardPressure = 0;\n                var i;\n                var forwardSeg;\n                if (seg.forwardPressure === undefined) {\n                    for (i = 0; i < forwardSegs.length; i++) {\n                        forwardSeg = forwardSegs[i];\n                        // figure out the child's maximum forward path\n                        computeSlotSegPressures(forwardSeg);\n                        // either use the existing maximum, or use the child's forward pressure\n                        // plus one (for the forwardSeg itself)\n                        forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n                    }\n                    seg.forwardPressure = forwardPressure;\n                }\n            }\n            // Find all the segments in `otherSegs` that vertically collide with `seg`.\n            // Append into an optionally-supplied `results` array and return.\n            function computeSlotSegCollisions(seg, otherSegs, results) {\n                if (results === void 0) {\n                    results = [];\n                }\n                for (var i = 0; i < otherSegs.length; i++) {\n                    if (isSlotSegCollision(seg, otherSegs[i])) {\n                        results.push(otherSegs[i]);\n                    }\n                }\n                return results;\n            }\n            // Do these segments occupy the same vertical space?\n            function isSlotSegCollision(seg1, seg2) {\n                return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n            }\n            /***/ \n        }),\n        /* 247 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var HelperRenderer_1 = __webpack_require__(58);\n            var TimeGridHelperRenderer = (function (_super) {\n                tslib_1.__extends(TimeGridHelperRenderer, _super);\n                function TimeGridHelperRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\n                    var helperNodes = [];\n                    var i;\n                    var seg;\n                    var sourceEl;\n                    // TODO: not good to call eventRenderer this way\n                    this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);\n                    // Try to make the segment that is in the same row as sourceSeg look the same\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        if (sourceSeg && sourceSeg.col === seg.col) {\n                            sourceEl = sourceSeg.el;\n                            seg.el.css({\n                                left: sourceEl.css('left'),\n                                right: sourceEl.css('right'),\n                                'margin-left': sourceEl.css('margin-left'),\n                                'margin-right': sourceEl.css('margin-right')\n                            });\n                        }\n                        helperNodes.push(seg.el[0]);\n                    }\n                    return $(helperNodes); // must return the elements rendered\n                };\n                return TimeGridHelperRenderer;\n            }(HelperRenderer_1.default));\n            exports.default = TimeGridHelperRenderer;\n            /***/ \n        }),\n        /* 248 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var FillRenderer_1 = __webpack_require__(57);\n            var TimeGridFillRenderer = (function (_super) {\n                tslib_1.__extends(TimeGridFillRenderer, _super);\n                function TimeGridFillRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {\n                    var timeGrid = this.component;\n                    var containerEls;\n                    // TODO: more efficient lookup\n                    if (type === 'bgEvent') {\n                        containerEls = timeGrid.bgContainerEls;\n                    }\n                    else if (type === 'businessHours') {\n                        containerEls = timeGrid.businessContainerEls;\n                    }\n                    else if (type === 'highlight') {\n                        containerEls = timeGrid.highlightContainerEls;\n                    }\n                    timeGrid.updateSegVerticals(segs);\n                    timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\n                    return segs.map(function (seg) {\n                        return seg.el[0];\n                    });\n                };\n                return TimeGridFillRenderer;\n            }(FillRenderer_1.default));\n            exports.default = TimeGridFillRenderer;\n            /***/ \n        }),\n        /* 249 */\n        /***/ (function (module, exports, __webpack_require__) {\n            /* A rectangular panel that is absolutely positioned over other content\n            ------------------------------------------------------------------------------------------------------------------------\n            Options:\n              - className (string)\n              - content (HTML string or jQuery element set)\n              - parentEl\n              - top\n              - left\n              - right (the x coord of where the right edge should be. not a \"CSS\" right)\n              - autoHide (boolean)\n              - show (callback)\n              - hide (callback)\n            */\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var ListenerMixin_1 = __webpack_require__(7);\n            var Popover = /*@__PURE__*/ (function () {\n                function Popover(options) {\n                    this.isHidden = true;\n                    this.margin = 10; // the space required between the popover and the edges of the scroll container\n                    this.options = options || {};\n                }\n                // Shows the popover on the specified position. Renders it if not already\n                Popover.prototype.show = function () {\n                    if (this.isHidden) {\n                        if (!this.el) {\n                            this.render();\n                        }\n                        this.el.show();\n                        this.position();\n                        this.isHidden = false;\n                        this.trigger('show');\n                    }\n                };\n                // Hides the popover, through CSS, but does not remove it from the DOM\n                Popover.prototype.hide = function () {\n                    if (!this.isHidden) {\n                        this.el.hide();\n                        this.isHidden = true;\n                        this.trigger('hide');\n                    }\n                };\n                // Creates `this.el` and renders content inside of it\n                Popover.prototype.render = function () {\n                    var _this = this;\n                    var options = this.options;\n                    this.el = $('<div class=\"fc-popover\"/>')\n                        .addClass(options.className || '')\n                        .css({\n                        // position initially to the top left to avoid creating scrollbars\n                        top: 0,\n                        left: 0\n                    })\n                        .append(options.content)\n                        .appendTo(options.parentEl);\n                    // when a click happens on anything inside with a 'fc-close' className, hide the popover\n                    this.el.on('click', '.fc-close', function () {\n                        _this.hide();\n                    });\n                    if (options.autoHide) {\n                        this.listenTo($(document), 'mousedown', this.documentMousedown);\n                    }\n                };\n                // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n                Popover.prototype.documentMousedown = function (ev) {\n                    // only hide the popover if the click happened outside the popover\n                    if (this.el && !$(ev.target).closest(this.el).length) {\n                        this.hide();\n                    }\n                };\n                // Hides and unregisters any handlers\n                Popover.prototype.removeElement = function () {\n                    this.hide();\n                    if (this.el) {\n                        this.el.remove();\n                        this.el = null;\n                    }\n                    this.stopListeningTo($(document), 'mousedown');\n                };\n                // Positions the popover optimally, using the top/left/right options\n                Popover.prototype.position = function () {\n                    var options = this.options;\n                    var origin = this.el.offsetParent().offset();\n                    var width = this.el.outerWidth();\n                    var height = this.el.outerHeight();\n                    var windowEl = $(window);\n                    var viewportEl = util_1.getScrollParent(this.el);\n                    var viewportTop;\n                    var viewportLeft;\n                    var viewportOffset;\n                    var top; // the \"position\" (not \"offset\") values for the popover\n                    var left; //\n                    // compute top and left\n                    top = options.top || 0;\n                    if (options.left !== undefined) {\n                        left = options.left;\n                    }\n                    else if (options.right !== undefined) {\n                        left = options.right - width; // derive the left value from the right value\n                    }\n                    else {\n                        left = 0;\n                    }\n                    if (viewportEl.is(window) || viewportEl.is(document)) {\n                        viewportEl = windowEl;\n                        viewportTop = 0; // the window is always at the top left\n                        viewportLeft = 0; // (and .offset() won't work if called here)\n                    }\n                    else {\n                        viewportOffset = viewportEl.offset();\n                        viewportTop = viewportOffset.top;\n                        viewportLeft = viewportOffset.left;\n                    }\n                    // if the window is scrolled, it causes the visible area to be further down\n                    viewportTop += windowEl.scrollTop();\n                    viewportLeft += windowEl.scrollLeft();\n                    // constrain to the view port. if constrained by two edges, give precedence to top/left\n                    if (options.viewportConstrain !== false) {\n                        top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\n                        top = Math.max(top, viewportTop + this.margin);\n                        left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\n                        left = Math.max(left, viewportLeft + this.margin);\n                    }\n                    this.el.css({\n                        top: top - origin.top,\n                        left: left - origin.left\n                    });\n                };\n                // Triggers a callback. Calls a function in the option hash of the same name.\n                // Arguments beyond the first `name` are forwarded on.\n                // TODO: better code reuse for this. Repeat code\n                Popover.prototype.trigger = function (name) {\n                    if (this.options[name]) {\n                        this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n                    }\n                };\n                return Popover;\n            }());\n            exports.default = Popover;\n            ListenerMixin_1.default.mixInto(Popover);\n            /***/ \n        }),\n        /* 250 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var util_1 = __webpack_require__(4);\n            var EventRenderer_1 = __webpack_require__(42);\n            /* Event-rendering methods for the DayGrid class\n            ----------------------------------------------------------------------------------------------------------------------*/\n            var DayGridEventRenderer = (function (_super) {\n                tslib_1.__extends(DayGridEventRenderer, _super);\n                function DayGridEventRenderer(dayGrid, fillRenderer) {\n                    var _this = _super.call(this, dayGrid, fillRenderer) || this;\n                    _this.dayGrid = dayGrid;\n                    return _this;\n                }\n                DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {\n                    // don't render timed background events\n                    eventRanges = $.grep(eventRanges, function (eventRange) {\n                        return eventRange.eventDef.isAllDay();\n                    });\n                    _super.prototype.renderBgRanges.call(this, eventRanges);\n                };\n                // Renders the given foreground event segments onto the grid\n                DayGridEventRenderer.prototype.renderFgSegs = function (segs) {\n                    var rowStructs = this.rowStructs = this.renderSegRows(segs);\n                    // append to each row's content skeleton\n                    this.dayGrid.rowEls.each(function (i, rowNode) {\n                        $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);\n                    });\n                };\n                // Unrenders all currently rendered foreground event segments\n                DayGridEventRenderer.prototype.unrenderFgSegs = function () {\n                    var rowStructs = this.rowStructs || [];\n                    var rowStruct;\n                    while ((rowStruct = rowStructs.pop())) {\n                        rowStruct.tbodyEl.remove();\n                    }\n                    this.rowStructs = null;\n                };\n                // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n                // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n                // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n                DayGridEventRenderer.prototype.renderSegRows = function (segs) {\n                    var rowStructs = [];\n                    var segRows;\n                    var row;\n                    segRows = this.groupSegRows(segs); // group into nested arrays\n                    // iterate each row of segment groupings\n                    for (row = 0; row < segRows.length; row++) {\n                        rowStructs.push(this.renderSegRow(row, segRows[row]));\n                    }\n                    return rowStructs;\n                };\n                // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n                // the segments. Returns object with a bunch of internal data about how the render was calculated.\n                // NOTE: modifies rowSegs\n                DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\n                    var colCnt = this.dayGrid.colCnt;\n                    var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n                    var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n                    var tbody = $('<tbody/>');\n                    var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n                    var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n                    var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n                    var i;\n                    var levelSegs;\n                    var col;\n                    var tr;\n                    var j;\n                    var seg;\n                    var td;\n                    // populates empty cells from the current column (`col`) to `endCol`\n                    function emptyCellsUntil(endCol) {\n                        while (col < endCol) {\n                            // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n                            td = (loneCellMatrix[i - 1] || [])[col];\n                            if (td) {\n                                td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);\n                            }\n                            else {\n                                td = $('<td/>');\n                                tr.append(td);\n                            }\n                            cellMatrix[i][col] = td;\n                            loneCellMatrix[i][col] = td;\n                            col++;\n                        }\n                    }\n                    for (i = 0; i < levelCnt; i++) {\n                        levelSegs = segLevels[i];\n                        col = 0;\n                        tr = $('<tr/>');\n                        segMatrix.push([]);\n                        cellMatrix.push([]);\n                        loneCellMatrix.push([]);\n                        // levelCnt might be 1 even though there are no actual levels. protect against this.\n                        // this single empty row is useful for styling.\n                        if (levelSegs) {\n                            for (j = 0; j < levelSegs.length; j++) {\n                                seg = levelSegs[j];\n                                emptyCellsUntil(seg.leftCol);\n                                // create a container that occupies or more columns. append the event element.\n                                td = $('<td class=\"fc-event-container\"/>').append(seg.el);\n                                if (seg.leftCol !== seg.rightCol) {\n                                    td.attr('colspan', seg.rightCol - seg.leftCol + 1);\n                                }\n                                else {\n                                    loneCellMatrix[i][col] = td;\n                                }\n                                while (col <= seg.rightCol) {\n                                    cellMatrix[i][col] = td;\n                                    segMatrix[i][col] = seg;\n                                    col++;\n                                }\n                                tr.append(td);\n                            }\n                        }\n                        emptyCellsUntil(colCnt); // finish off the row\n                        this.dayGrid.bookendCells(tr);\n                        tbody.append(tr);\n                    }\n                    return {\n                        row: row,\n                        tbodyEl: tbody,\n                        cellMatrix: cellMatrix,\n                        segMatrix: segMatrix,\n                        segLevels: segLevels,\n                        segs: rowSegs\n                    };\n                };\n                // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n                // NOTE: modifies segs\n                DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\n                    var levels = [];\n                    var i;\n                    var seg;\n                    var j;\n                    // Give preference to elements with certain criteria, so they have\n                    // a chance to be closer to the top.\n                    this.sortEventSegs(segs);\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n                        for (j = 0; j < levels.length; j++) {\n                            if (!isDaySegCollision(seg, levels[j])) {\n                                break;\n                            }\n                        }\n                        // `j` now holds the desired subrow index\n                        seg.level = j;\n                        // create new level array if needed and append segment\n                        (levels[j] || (levels[j] = [])).push(seg);\n                    }\n                    // order segments left-to-right. very important if calendar is RTL\n                    for (j = 0; j < levels.length; j++) {\n                        levels[j].sort(compareDaySegCols);\n                    }\n                    return levels;\n                };\n                // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n                DayGridEventRenderer.prototype.groupSegRows = function (segs) {\n                    var segRows = [];\n                    var i;\n                    for (i = 0; i < this.dayGrid.rowCnt; i++) {\n                        segRows.push([]);\n                    }\n                    for (i = 0; i < segs.length; i++) {\n                        segRows[segs[i].row].push(segs[i]);\n                    }\n                    return segRows;\n                };\n                // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n                DayGridEventRenderer.prototype.computeEventTimeFormat = function () {\n                    return this.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\n                };\n                // Computes a default `displayEventEnd` value if one is not expliclty defined\n                DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n                    return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\n                };\n                // Builds the HTML to be used for the default element for an individual segment\n                DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\n                    var view = this.view;\n                    var eventDef = seg.footprint.eventDef;\n                    var isAllDay = seg.footprint.componentFootprint.isAllDay;\n                    var isDraggable = view.isEventDefDraggable(eventDef);\n                    var isResizableFromStart = !disableResizing && isAllDay &&\n                        seg.isStart && view.isEventDefResizableFromStart(eventDef);\n                    var isResizableFromEnd = !disableResizing && isAllDay &&\n                        seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\n                    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n                    var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\n                    var timeHtml = '';\n                    var timeText;\n                    var titleHtml;\n                    classes.unshift('fc-day-grid-event', 'fc-h-event');\n                    // Only display a timed events time if it is the starting segment\n                    if (seg.isStart) {\n                        timeText = this.getTimeText(seg.footprint);\n                        if (timeText) {\n                            timeHtml = '<span class=\"fc-time\">' + util_1.htmlEscape(timeText) + '</span>';\n                        }\n                    }\n                    titleHtml =\n                        '<span class=\"fc-title\">' +\n                            (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\n                            '</span>';\n                    return '<a class=\"' + classes.join(' ') + '\"' +\n                        (eventDef.url ?\n                            ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\n                            '') +\n                        (skinCss ?\n                            ' style=\"' + skinCss + '\"' :\n                            '') +\n                        '>' +\n                        '<div class=\"fc-content\">' +\n                        (this.dayGrid.isRTL ?\n                            titleHtml + ' ' + timeHtml : // put a natural space in between\n                            timeHtml + ' ' + titleHtml //\n                        ) +\n                        '</div>' +\n                        (isResizableFromStart ?\n                            '<div class=\"fc-resizer fc-start-resizer\" />' :\n                            '') +\n                        (isResizableFromEnd ?\n                            '<div class=\"fc-resizer fc-end-resizer\" />' :\n                            '') +\n                        '</a>';\n                };\n                return DayGridEventRenderer;\n            }(EventRenderer_1.default));\n            exports.default = DayGridEventRenderer;\n            // Computes whether two segments' columns collide. They are assumed to be in the same row.\n            function isDaySegCollision(seg, otherSegs) {\n                var i;\n                var otherSeg;\n                for (i = 0; i < otherSegs.length; i++) {\n                    otherSeg = otherSegs[i];\n                    if (otherSeg.leftCol <= seg.rightCol &&\n                        otherSeg.rightCol >= seg.leftCol) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            // A cmp function for determining the leftmost event\n            function compareDaySegCols(a, b) {\n                return a.leftCol - b.leftCol;\n            }\n            /***/ \n        }),\n        /* 251 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var HelperRenderer_1 = __webpack_require__(58);\n            var DayGridHelperRenderer = (function (_super) {\n                tslib_1.__extends(DayGridHelperRenderer, _super);\n                function DayGridHelperRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\n                DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\n                    var helperNodes = [];\n                    var rowStructs;\n                    // TODO: not good to call eventRenderer this way\n                    rowStructs = this.eventRenderer.renderSegRows(segs);\n                    // inject each new event skeleton into each associated row\n                    this.component.rowEls.each(function (row, rowNode) {\n                        var rowEl = $(rowNode); // the .fc-row\n                        var skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\n                        var skeletonTopEl;\n                        var skeletonTop;\n                        // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n                        if (sourceSeg && sourceSeg.row === row) {\n                            skeletonTop = sourceSeg.el.position().top;\n                        }\n                        else {\n                            skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');\n                            if (!skeletonTopEl.length) {\n                                skeletonTopEl = rowEl.find('.fc-content-skeleton table');\n                            }\n                            skeletonTop = skeletonTopEl.position().top;\n                        }\n                        skeletonEl.css('top', skeletonTop)\n                            .find('table')\n                            .append(rowStructs[row].tbodyEl);\n                        rowEl.append(skeletonEl);\n                        helperNodes.push(skeletonEl[0]);\n                    });\n                    return $(helperNodes); // must return the elements rendered\n                };\n                return DayGridHelperRenderer;\n            }(HelperRenderer_1.default));\n            exports.default = DayGridHelperRenderer;\n            /***/ \n        }),\n        /* 252 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var FillRenderer_1 = __webpack_require__(57);\n            var DayGridFillRenderer = (function (_super) {\n                tslib_1.__extends(DayGridFillRenderer, _super);\n                function DayGridFillRenderer() {\n                    var _this = _super !== null && _super.apply(this, arguments) || this;\n                    _this.fillSegTag = 'td'; // override the default tag name\n                    return _this;\n                }\n                DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {\n                    var nodes = [];\n                    var i;\n                    var seg;\n                    var skeletonEl;\n                    for (i = 0; i < segs.length; i++) {\n                        seg = segs[i];\n                        skeletonEl = this.renderFillRow(type, seg);\n                        this.component.rowEls.eq(seg.row).append(skeletonEl);\n                        nodes.push(skeletonEl[0]);\n                    }\n                    return nodes;\n                };\n                // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n                DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\n                    var colCnt = this.component.colCnt;\n                    var startCol = seg.leftCol;\n                    var endCol = seg.rightCol + 1;\n                    var className;\n                    var skeletonEl;\n                    var trEl;\n                    if (type === 'businessHours') {\n                        className = 'bgevent';\n                    }\n                    else {\n                        className = type.toLowerCase();\n                    }\n                    skeletonEl = $('<div class=\"fc-' + className + '-skeleton\">' +\n                        '<table><tr/></table>' +\n                        '</div>');\n                    trEl = skeletonEl.find('tr');\n                    if (startCol > 0) {\n                        trEl.append('<td colspan=\"' + startCol + '\"/>');\n                    }\n                    trEl.append(seg.el.attr('colspan', endCol - startCol));\n                    if (endCol < colCnt) {\n                        trEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\n                    }\n                    this.component.bookendCells(trEl);\n                    return skeletonEl;\n                };\n                return DayGridFillRenderer;\n            }(FillRenderer_1.default));\n            exports.default = DayGridFillRenderer;\n            /***/ \n        }),\n        /* 253 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var BasicViewDateProfileGenerator_1 = __webpack_require__(228);\n            var UnzonedRange_1 = __webpack_require__(5);\n            var MonthViewDateProfileGenerator = (function (_super) {\n                tslib_1.__extends(MonthViewDateProfileGenerator, _super);\n                function MonthViewDateProfileGenerator() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // Computes the date range that will be rendered.\n                MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\n                    var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);\n                    var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\n                    var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\n                    var rowCnt;\n                    // ensure 6 weeks\n                    if (this.opt('fixedWeekCount')) {\n                        rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\n                        end.diff(start, 'weeks', true) // dontRound=true\n                        );\n                        end.add(6 - rowCnt, 'weeks');\n                    }\n                    return new UnzonedRange_1.default(start, end);\n                };\n                return MonthViewDateProfileGenerator;\n            }(BasicViewDateProfileGenerator_1.default));\n            exports.default = MonthViewDateProfileGenerator;\n            /***/ \n        }),\n        /* 254 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var util_1 = __webpack_require__(4);\n            var EventRenderer_1 = __webpack_require__(42);\n            var ListEventRenderer = (function (_super) {\n                tslib_1.__extends(ListEventRenderer, _super);\n                function ListEventRenderer() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ListEventRenderer.prototype.renderFgSegs = function (segs) {\n                    if (!segs.length) {\n                        this.component.renderEmptyMessage();\n                    }\n                    else {\n                        this.component.renderSegList(segs);\n                    }\n                };\n                // generates the HTML for a single event row\n                ListEventRenderer.prototype.fgSegHtml = function (seg) {\n                    var view = this.view;\n                    var calendar = view.calendar;\n                    var theme = calendar.theme;\n                    var eventFootprint = seg.footprint;\n                    var eventDef = eventFootprint.eventDef;\n                    var componentFootprint = eventFootprint.componentFootprint;\n                    var url = eventDef.url;\n                    var classes = ['fc-list-item'].concat(this.getClasses(eventDef));\n                    var bgColor = this.getBgColor(eventDef);\n                    var timeHtml;\n                    if (componentFootprint.isAllDay) {\n                        timeHtml = view.getAllDayHtml();\n                    }\n                    else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\n                        if (seg.isStart || seg.isEnd) {\n                            timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));\n                        }\n                        else {\n                            timeHtml = view.getAllDayHtml();\n                        }\n                    }\n                    else {\n                        // Display the normal time text for the *event's* times\n                        timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));\n                    }\n                    if (url) {\n                        classes.push('fc-has-url');\n                    }\n                    return '<tr class=\"' + classes.join(' ') + '\">' +\n                        (this.displayEventTime ?\n                            '<td class=\"fc-list-item-time ' + theme.getClass('widgetContent') + '\">' +\n                                (timeHtml || '') +\n                                '</td>' :\n                            '') +\n                        '<td class=\"fc-list-item-marker ' + theme.getClass('widgetContent') + '\">' +\n                        '<span class=\"fc-event-dot\"' +\n                        (bgColor ?\n                            ' style=\"background-color:' + bgColor + '\"' :\n                            '') +\n                        '></span>' +\n                        '</td>' +\n                        '<td class=\"fc-list-item-title ' + theme.getClass('widgetContent') + '\">' +\n                        '<a' + (url ? ' href=\"' + util_1.htmlEscape(url) + '\"' : '') + '>' +\n                        util_1.htmlEscape(eventDef.title || '') +\n                        '</a>' +\n                        '</td>' +\n                        '</tr>';\n                };\n                // like \"4:00am\"\n                ListEventRenderer.prototype.computeEventTimeFormat = function () {\n                    return this.opt('mediumTimeFormat');\n                };\n                return ListEventRenderer;\n            }(EventRenderer_1.default));\n            exports.default = ListEventRenderer;\n            /***/ \n        }),\n        /* 255 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var $ = __webpack_require__(3);\n            var EventPointing_1 = __webpack_require__(59);\n            var ListEventPointing = (function (_super) {\n                tslib_1.__extends(ListEventPointing, _super);\n                function ListEventPointing() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // for events with a url, the whole <tr> should be clickable,\n                // but it's impossible to wrap with an <a> tag. simulate this.\n                ListEventPointing.prototype.handleClick = function (seg, ev) {\n                    var url;\n                    _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action\n                    // not clicking on or within an <a> with an href\n                    if (!$(ev.target).closest('a[href]').length) {\n                        url = seg.footprint.eventDef.url;\n                        if (url && !ev.isDefaultPrevented()) {\n                            window.location.href = url; // simulate link click\n                        }\n                    }\n                };\n                return ListEventPointing;\n            }(EventPointing_1.default));\n            exports.default = ListEventPointing;\n            /***/ \n        }),\n        /* 256 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var EventSourceParser_1 = __webpack_require__(38);\n            var ArrayEventSource_1 = __webpack_require__(52);\n            var FuncEventSource_1 = __webpack_require__(215);\n            var JsonFeedEventSource_1 = __webpack_require__(216);\n            EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);\n            EventSourceParser_1.default.registerClass(FuncEventSource_1.default);\n            EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);\n            /***/ \n        }),\n        /* 257 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var ThemeRegistry_1 = __webpack_require__(51);\n            var StandardTheme_1 = __webpack_require__(213);\n            var JqueryUiTheme_1 = __webpack_require__(214);\n            var Bootstrap3Theme_1 = __webpack_require__(258);\n            var Bootstrap4Theme_1 = __webpack_require__(259);\n            ThemeRegistry_1.defineThemeSystem('standard', StandardTheme_1.default);\n            ThemeRegistry_1.defineThemeSystem('jquery-ui', JqueryUiTheme_1.default);\n            ThemeRegistry_1.defineThemeSystem('bootstrap3', Bootstrap3Theme_1.default);\n            ThemeRegistry_1.defineThemeSystem('bootstrap4', Bootstrap4Theme_1.default);\n            /***/ \n        }),\n        /* 258 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Theme_1 = __webpack_require__(19);\n            var Bootstrap3Theme = (function (_super) {\n                tslib_1.__extends(Bootstrap3Theme, _super);\n                function Bootstrap3Theme() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return Bootstrap3Theme;\n            }(Theme_1.default));\n            exports.default = Bootstrap3Theme;\n            Bootstrap3Theme.prototype.classes = {\n                widget: 'fc-bootstrap3',\n                tableGrid: 'table-bordered',\n                tableList: 'table',\n                tableListHeading: 'active',\n                buttonGroup: 'btn-group',\n                button: 'btn btn-default',\n                stateActive: 'active',\n                stateDisabled: 'disabled',\n                today: 'alert alert-info',\n                popover: 'panel panel-default',\n                popoverHeader: 'panel-heading',\n                popoverContent: 'panel-body',\n                // day grid\n                // for left/right border color when border is inset from edges (all-day in agenda view)\n                // avoid `panel` class b/c don't want margins/radius. only border color.\n                headerRow: 'panel-default',\n                dayRow: 'panel-default',\n                // list view\n                listView: 'panel panel-default'\n            };\n            Bootstrap3Theme.prototype.baseIconClass = 'glyphicon';\n            Bootstrap3Theme.prototype.iconClasses = {\n                close: 'glyphicon-remove',\n                prev: 'glyphicon-chevron-left',\n                next: 'glyphicon-chevron-right',\n                prevYear: 'glyphicon-backward',\n                nextYear: 'glyphicon-forward'\n            };\n            Bootstrap3Theme.prototype.iconOverrideOption = 'bootstrapGlyphicons';\n            Bootstrap3Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';\n            Bootstrap3Theme.prototype.iconOverridePrefix = 'glyphicon-';\n            /***/ \n        }),\n        /* 259 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tslib_1 = __webpack_require__(2);\n            var Theme_1 = __webpack_require__(19);\n            var Bootstrap4Theme = (function (_super) {\n                tslib_1.__extends(Bootstrap4Theme, _super);\n                function Bootstrap4Theme() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return Bootstrap4Theme;\n            }(Theme_1.default));\n            exports.default = Bootstrap4Theme;\n            Bootstrap4Theme.prototype.classes = {\n                widget: 'fc-bootstrap4',\n                tableGrid: 'table-bordered',\n                tableList: 'table',\n                tableListHeading: 'table-active',\n                buttonGroup: 'btn-group',\n                button: 'btn btn-primary',\n                stateActive: 'active',\n                stateDisabled: 'disabled',\n                today: 'alert alert-info',\n                popover: 'card card-primary',\n                popoverHeader: 'card-header',\n                popoverContent: 'card-body',\n                // day grid\n                // for left/right border color when border is inset from edges (all-day in agenda view)\n                // avoid `table` class b/c don't want margins/padding/structure. only border color.\n                headerRow: 'table-bordered',\n                dayRow: 'table-bordered',\n                // list view\n                listView: 'card card-primary'\n            };\n            Bootstrap4Theme.prototype.baseIconClass = 'fa';\n            Bootstrap4Theme.prototype.iconClasses = {\n                close: 'fa-times',\n                prev: 'fa-chevron-left',\n                next: 'fa-chevron-right',\n                prevYear: 'fa-angle-double-left',\n                nextYear: 'fa-angle-double-right'\n            };\n            Bootstrap4Theme.prototype.iconOverrideOption = 'bootstrapFontAwesome';\n            Bootstrap4Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';\n            Bootstrap4Theme.prototype.iconOverridePrefix = 'fa-';\n            /***/ \n        }),\n        /* 260 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var ViewRegistry_1 = __webpack_require__(22);\n            var BasicView_1 = __webpack_require__(62);\n            var MonthView_1 = __webpack_require__(229);\n            ViewRegistry_1.defineView('basic', {\n                'class': BasicView_1.default\n            });\n            ViewRegistry_1.defineView('basicDay', {\n                type: 'basic',\n                duration: { days: 1 }\n            });\n            ViewRegistry_1.defineView('basicWeek', {\n                type: 'basic',\n                duration: { weeks: 1 }\n            });\n            ViewRegistry_1.defineView('month', {\n                'class': MonthView_1.default,\n                duration: { months: 1 },\n                defaults: {\n                    fixedWeekCount: true\n                }\n            });\n            /***/ \n        }),\n        /* 261 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var ViewRegistry_1 = __webpack_require__(22);\n            var AgendaView_1 = __webpack_require__(226);\n            ViewRegistry_1.defineView('agenda', {\n                'class': AgendaView_1.default,\n                defaults: {\n                    allDaySlot: true,\n                    slotDuration: '00:30:00',\n                    slotEventOverlap: true // a bad name. confused with overlap/constraint system\n                }\n            });\n            ViewRegistry_1.defineView('agendaDay', {\n                type: 'agenda',\n                duration: { days: 1 }\n            });\n            ViewRegistry_1.defineView('agendaWeek', {\n                type: 'agenda',\n                duration: { weeks: 1 }\n            });\n            /***/ \n        }),\n        /* 262 */\n        /***/ (function (module, exports, __webpack_require__) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var ViewRegistry_1 = __webpack_require__(22);\n            var ListView_1 = __webpack_require__(230);\n            ViewRegistry_1.defineView('list', {\n                'class': ListView_1.default,\n                buttonTextKey: 'list',\n                defaults: {\n                    buttonText: 'list',\n                    listDayFormat: 'LL',\n                    noEventsMessage: 'No events to display'\n                }\n            });\n            ViewRegistry_1.defineView('listDay', {\n                type: 'list',\n                duration: { days: 1 },\n                defaults: {\n                    listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\n                }\n            });\n            ViewRegistry_1.defineView('listWeek', {\n                type: 'list',\n                duration: { weeks: 1 },\n                defaults: {\n                    listDayFormat: 'dddd',\n                    listDayAltFormat: 'LL'\n                }\n            });\n            ViewRegistry_1.defineView('listMonth', {\n                type: 'list',\n                duration: { month: 1 },\n                defaults: {\n                    listDayAltFormat: 'dddd' // day-of-week is nice-to-have\n                }\n            });\n            ViewRegistry_1.defineView('listYear', {\n                type: 'list',\n                duration: { year: 1 },\n                defaults: {\n                    listDayAltFormat: 'dddd' // day-of-week is nice-to-have\n                }\n            });\n            /***/ \n        }),\n        /* 263 */\n        /***/ (function (module, exports) {\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /***/ \n        })\n        /******/ \n    ]);\n});\n",null]}